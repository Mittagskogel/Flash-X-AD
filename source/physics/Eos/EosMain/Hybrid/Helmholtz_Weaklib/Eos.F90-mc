!!****if* source/physics/Eos/EosMain/hybrid/Helmholtz_WeakLib/Eos
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!! NAME
!!
!!  Eos
!!
!!  This routine implements the hybrid (Helmholtz+WeakLib) equation of state.
!!
!!***
!!NOVARIANTS

subroutine Eos(mode, vecLen, eosData, massFrac, mask, vecB, vecE, diagFlag)

   use Driver_interface, ONLY: Driver_abort
   use Eos_data, ONLY: eos_meshMe, eos_type
   use eos_hybridData, ONLY: eos_hybTransitionDensLo, eos_hybTransitionDensHi
   use eos_localInterface, ONLY: eos_helmYe, eos_weaklib
   use eos_hybridInterface, ONLY: eos_hybridSetFlag

   implicit none

#include "constants.h"
#include "Eos.h"
#include "Simulation.h"

   integer, INTENT(in) :: mode, vecLen
   real, INTENT(inout), dimension(EOS_NUM*vecLen) :: eosData
   logical, optional, INTENT(in), target, dimension(EOS_VARS + 1:EOS_NUM) :: mask
   real, optional, INTENT(in), dimension(NSPECIES*vecLen) :: massFrac
   integer, optional, INTENT(in) :: vecB, vecE
   integer, optional, INTENT(out) :: diagFlag

   integer :: vecBegin, vecEnd
   logical :: pMassFrac_and_mask, pMassFrac, pMask
   integer :: eos_hybFlag(vecLen)

   integer :: k_WL, vecLen_WL, kVec_WL(vecLen)
   integer :: k_HLM, vecLen_HLM, kVec_HLM(vecLen)
   real, allocatable :: eosData_WL(:), massFrac_WL(:)
   real, allocatable :: eosData_HLM(:), massFrac_HLM(:)
   real, dimension(EOS_NUM) :: eosData_k

   real :: dens_in, fac, facLo, facHi
   real :: temp_WL, temp_HLM
   real :: pres_WL, pres_HLM
   real :: eint_WL, eint_HLM
   real :: entr_WL, entr_HLM
   real :: gamc_WL, gamc_HLM

   integer :: i, k

   real :: a, b, r

   vecBegin = 1
   vecEnd = vecLen
   if (present(vecB)) vecBegin = vecB
   if (present(vecE)) vecEnd = vecE

   if (present(diagFlag)) diagFlag = 0

   if (mode == MODE_EOS_NOP) return ! * Return immediately for MODE_EOS_NOP! *
   if (mode == MODE_EOS_WRAPPERONLY) return ! * Return immediately for MODE_EOS_WRAPPERONLY! *

   pMassFrac = present(massFrac)
   pMask = present(mask)
   pMassFrac_and_mask = pMassFrac .and. pMask

   call eos_hybridSetFlag(mode, vecLen, eosData, massFrac, mask, vecBegin, vecEnd, eos_hybFlag)

   ! pack eosData into separate eosData vectors for each EoS
   vecLen_WL = COUNT(eos_hybFlag == EOS_WL .or. eos_hybFlag == EOS_HYB)
   vecLen_HLM = COUNT(eos_hybFlag == EOS_HLM .or. eos_hybFlag == EOS_HYB)
   ! print *, vecLen_WL, vecLen_HLM, count(eos_hybFlag == EOS_HYB)
   allocate (eosData_WL(EOS_NUM*vecLen_WL))
   allocate (eosData_HLM(EOS_NUM*vecLen_HLM))
   if (pMassFrac) then
      allocate (massFrac_WL(NSPECIES*vecLen_WL))
      allocate (massFrac_HLM(NSPECIES*vecLen_HLM))
   end if

   eosData_WL = 0.0
   eosData_HLM = 0.0

   k_WL = 0
   k_HLM = 0
   do k = vecBegin, vecEnd
      if (eos_hybFlag(k) == EOS_WL .or. eos_hybFlag(k) == EOS_HYB) then
         k_WL = k_WL + 1
         kVec_WL(k) = k_WL
         do i = 1, EOS_NUM
            eosData_WL((i - 1)*vecLen_WL + k_WL) = eosData((i - 1)*vecLen + k)
         end do
         if (pMassFrac) then
            do i = 1, NSPECIES
               massFrac_WL((k_WL - 1)*NSPECIES + i) = massFrac((k - 1)*NSPECIES + i)
            end do
         end if
      end if
      if (eos_hybFlag(k) == EOS_HLM .or. eos_hybFlag(k) == EOS_HYB) then
         k_HLM = k_HLM + 1
         kVec_HLM(k) = k_HLM
         do i = 1, EOS_NUM
            eosData_HLM((i - 1)*vecLen_HLM + k_HLM) = eosData((i - 1)*vecLen + k)
         end do
         if (pMassFrac) then
            do i = 1, NSPECIES
               massFrac_HLM((k_HLM - 1)*NSPECIES + i) = massFrac((k - 1)*NSPECIES + i)
            end do
         end if
      end if
   end do

   ! Call each EoS with its own vector
   if (pMassFrac_and_mask) then
      call eos_weaklib(mode, vecLen_WL, eosData_WL, massFrac_WL, mask)
      call eos_helmYe(mode, vecLen_HLM, eosData_HLM, massFrac_HLM, mask)
   else if (pMassFrac) then
      call eos_weaklib(mode, vecLen_WL, eosData_WL, massFrac_WL)
      call eos_helmYe(mode, vecLen_HLM, eosData_HLM, massFrac_HLM)
   else if (pMask) then
      call eos_weaklib(mode, vecLen_WL, eosData_WL, mask=mask)
      call eos_helmYe(mode, vecLen_HLM, eosData_HLM, mask=mask)
   else
      call eos_weaklib(mode, vecLen_WL, eosData_WL)
      call eos_helmYe(mode, vecLen_HLM, eosData_HLM)
   end if

   ! Unpack and blend both EoS calls into single eosData
   do k = vecBegin, vecEnd

      ! Fill single cell eosData
      do i = 1, EOS_NUM
         eosData_k(i) = eosData((i - 1)*vecLen + k)
      end do

      if (eos_hybFlag(k) == EOS_WL) then

         k_WL = kVec_WL(k)
         do i = 1, EOS_NUM
            eosData_k(i) = eosData_WL((i - 1)*vecLen_WL + k_WL)
         end do

      else if (eos_hybFlag(k) == EOS_HYB) then

         k_WL = kVec_WL(k)
         k_HLM = kVec_HLM(k)

         dens_in = eosData((EOS_DENS - 1)*vecLen + k)

         temp_WL = eosData_WL((EOS_TEMP - 1)*vecLen_WL + k_WL)
         pres_WL = eosData_WL((EOS_PRES - 1)*vecLen_WL + k_WL)
         eint_WL = eosData_WL((EOS_EINT - 1)*vecLen_WL + k_WL)
         entr_WL = eosData_WL((EOS_ENTR - 1)*vecLen_WL + k_WL)
         gamc_WL = eosData_WL((EOS_GAMC - 1)*vecLen_WL + k_WL)

         temp_HLM = eosData_HLM((EOS_TEMP - 1)*vecLen_HLM + k_HLM)
         pres_HLM = eosData_HLM((EOS_PRES - 1)*vecLen_HLM + k_HLM)
         eint_HLM = eosData_HLM((EOS_EINT - 1)*vecLen_HLM + k_HLM)
         entr_HLM = eosData_HLM((EOS_ENTR - 1)*vecLen_HLM + k_HLM)
         gamc_HLM = eosData_HLM((EOS_GAMC - 1)*vecLen_HLM + k_HLM)

         ! Interpolate between limits
         fac = (dens_in - eos_hybTransitionDensLo) &
               /(eos_hybTransitionDensHi - eos_hybTransitionDensLo)

         ! r = ((dens_in - eos_hybTransitionDensLo) &
         !      /(eos_hybTransitionDensHi - dens_in))
         ! r = min(r, 1.0 - r)
         ! r = (log(dens_in) - log(eos_hybTransitionDensLo)) &
         !     /(log(eos_hybTransitionDensHi) - log(eos_hybTransitionDensLo))
         r = 1.0/fac**2

         facHi = (dens_in/eos_hybTransitionDensHi)**2
         facLo = (eos_hybTransitionDensLo/dens_in)**2

         ! r = facLo/facHi

         ! fac = 0.5*max(0.0, min(2.0*r, 0.5*(1.0 + r), 2.0))
         ! fac = 0.5*max(0.0, min(2.0*r, 1.0), min(r, 2.0))
         ! fac = 0.5*max(0.0, min(1.0, r))
         ! fac = 0.5*max(0.0, min(2.0*r, min((1.0 + 2.0*r)/3.0, 2.0)))

         ! Because why not?
         ! fac = 1.0/3.0 + 2.0/15.0*fac**2*(3.0 - fac + 3.0*fac**2)

         ! select case (mode)
         ! case (MODE_DENS_TEMP)
         !    eosData_k(EOS_PRES) = fac*pres_WL + (1.0 - fac)*pres_HLM
         !    eosData_k(EOS_EINT) = fac*eint_WL + (1.0 - fac)*eint_HLM
         !    eosData_k(EOS_ENTR) = fac*entr_WL + (1.0 - fac)*entr_HLM
         !    eosData_k(EOS_GAMC) = fac*gamc_WL + (1.0 - fac)*gamc_HLM
         ! case (MODE_DENS_EI)
         !    eosData_k(EOS_TEMP) = fac*temp_WL + (1.0 - fac)*temp_HLM
         !    eosData_k(EOS_PRES) = fac*pres_WL + (1.0 - fac)*pres_HLM
         !    eosData_k(EOS_ENTR) = fac*entr_WL + (1.0 - fac)*entr_HLM
         !    eosData_k(EOS_GAMC) = fac*gamc_WL + (1.0 - fac)*gamc_HLM
         ! case (MODE_DENS_PRES)
         !    eosData_k(EOS_TEMP) = fac*temp_WL + (1.0 - fac)*temp_HLM
         !    eosData_k(EOS_EINT) = fac*eint_WL + (1.0 - fac)*eint_HLM
         !    eosData_k(EOS_ENTR) = fac*entr_WL + (1.0 - fac)*entr_HLM
         !    eosData_k(EOS_GAMC) = fac*gamc_WL + (1.0 - fac)*gamc_HLM
         ! case (MODE_DENS_ENTR)
         !    eosData_k(EOS_TEMP) = fac*temp_WL + (1.0 - fac)*temp_HLM
         !    eosData_k(EOS_PRES) = fac*pres_WL + (1.0 - fac)*pres_HLM
         !    eosData_k(EOS_EINT) = fac*eint_WL + (1.0 - fac)*eint_HLM
         !    eosData_k(EOS_GAMC) = fac*gamc_WL + (1.0 - fac)*gamc_HLM
         ! end select

         ! select case (mode)
         ! case (MODE_DENS_TEMP)
         !    eosData_k(EOS_PRES) = (pres_WL*facHi + pres_HLM*facLo)/(facLo + facHi)
         !    eosData_k(EOS_EINT) = (eint_WL*facHi + eint_HLM*facLo)/(facLo + facHi)
         !    eosData_k(EOS_ENTR) = (entr_WL*facHi + entr_HLM*facLo)/(facLo + facHi)
         !    eosData_k(EOS_GAMC) = (gamc_WL*facHi + gamc_HLM*facLo)/(facLo + facHi)
         ! case (MODE_DENS_EI)
         !    eosData_k(EOS_TEMP) = (temp_WL*facHi + temp_HLM*facLo)/(facLo + facHi)
         !    eosData_k(EOS_PRES) = (pres_WL*facHi + pres_HLM*facLo)/(facLo + facHi)
         !    eosData_k(EOS_ENTR) = (entr_WL*facHi + entr_HLM*facLo)/(facLo + facHi)
         !    eosData_k(EOS_GAMC) = (gamc_WL*facHi + gamc_HLM*facLo)/(facLo + facHi)
         ! case (MODE_DENS_PRES)
         !    eosData_k(EOS_TEMP) = exp(log(temp_WL)*r + log(temp_HLM)*(1.0 - r))
         !    eosData_k(EOS_EINT) = exp(log(eint_WL)*r + log(eint_HLM)*(1.0 - r))
         !    eosData_k(EOS_ENTR) = exp(log(entr_WL)*r + log(entr_HLM)*(1.0 - r))
         !    eosData_k(EOS_GAMC) = exp(log(gamc_WL)*r + log(gamc_HLM)*(1.0 - r))
         ! case (MODE_DENS_ENTR)
         !    eosData_k(EOS_TEMP) = exp(log(temp_WL)*r + log(temp_HLM)*(1.0 - r))
         !    eosData_k(EOS_PRES) = exp(log(pres_WL)*r + log(pres_HLM)*(1.0 - r))
         !    eosData_k(EOS_EINT) = exp(log(eint_WL)*r + log(eint_HLM)*(1.0 - r))
         !    eosData_k(EOS_GAMC) = exp(log(gamc_WL)*r + log(gamc_HLM)*(1.0 - r))
         ! end select

         do i = 1, EOS_NUM
         eosData_k(i) = (facHi*eosData_WL((i - 1)*vecLen_WL + k_WL) + facLo*eosData_HLM((i - 1)*vecLen_HLM + k_HLM))/(facLo + facHi)
            ! eosData_k(i) = sqrt(eosData_WL((i - 1)*vecLen_WL + k_WL)**r*eosData_HLM((i - 1)*vecLen_HLM + k_HLM)**(1.0 - r))
            ! ! For no good reason whatsoever, this actually works slightly better...
            ! eosData_k(i) = (1.5*fac - 0.5)*eosData_WL((i - 1)*vecLen_WL + k_WL) &
            !                + 1.5*(1.0 - fac)*eosData_HLM((i - 1)*vecLen_HLM + k_HLM)
         end do

      else ! eos_hybFlag(k) == EOS_HLM

         k_HLM = kVec_HLM(k)
         do i = 1, EOS_NUM
            eosData_k(i) = eosData_HLM((i - 1)*vecLen_HLM + k_HLM)
         end do

      end if

      do i = 1, EOS_NUM
         eosData((i - 1)*vecLen + k) = eosData_k(i)
      end do

   end do

   deallocate (eosData_WL, eosData_HLM)
   if (pMassFrac) then
      deallocate (massFrac_WL, massFrac_HLM)
   end if

   return
end subroutine Eos
