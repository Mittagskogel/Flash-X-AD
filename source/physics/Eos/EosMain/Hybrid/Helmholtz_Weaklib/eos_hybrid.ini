[eos_hybridInit]
definition =
  call eos_hybridInit()


[eos_setFlag]
definition =
    n = 1
    eos_hybFlag = -1
    @M loop_3d(range)
      ! Set the flag for which EoS to use based on density
      ! Call nuclear eos above transition density
      if (solnData(DENS_VAR,i,j,k)) > eos_hybTransitionDensHi) then
         eos_hybFlag(n) = EOS_WL
         ! Call both eos if between transition densities
      else if (solnData(DENS_VAR,i,j,k) <= eos_hybTransitionDensHi .and. &
               solnData(DENS_VAR,i,j,k) > eos_hybTransitionDensLo) then
         eos_hybFlag(n) = EOS_HYB
         ! Call helmholtz if below transition density
      else ! solnData(DENS_VAR,i,j,k) <= eos_hybTransitionDensLo
         eos_hybFlag(n) = EOS_HLM
      end if
      n=n+1
    @M loop_end_3d

[eos_energyShift]
definition =
   eosData_ptr(1:vecLen, 1:EOS_NUM) => eosData
   energyShift = eos_hybDeltaE_WL*conv
   ! Redundant yes, but Id rather not have the conditional check
   ! in the loop over the vector
   if (present(massFrac) .and. (NSPECIES .gt. 0)) then
      ! Note: massFrac is indexed oppositely of eosData
      massFrac_ptr(1:NSPECIES, 1:vecLen) => massFrac
      n=1
      @M loop_3d(range)
         energyShift(n) = energyShift(n) - delta*solutionData(ye_map,i,j,k) &
                          - sum(massFrac_ptr(:, n)*eos_hybBoverA)*conv
      @M loop_end_3d 
   else
     @M loop_3d(range)
         energyShift(n) = energyShift(n) - delta*solutionData(ye_map,i,j,k)
     @M loop_end_3d
   end if


