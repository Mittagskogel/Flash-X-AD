[eos_mapDec]
definition =
  integer :: pres_map,dens_map,gamc_map,game_map,temp_map,entr_map
  integer :: eint_map,ener_map, velx_map, vely_map, velz_map, sumy_map, ye_map
  integer :: pres,dens,gamc,temp,abar,zbar,eint,ekin,entr
  real :: kineticEnergy, internalEnergy

[eos_map]
args=vecLen,dstruct
definition =
  pres_map = eos_mapLookup(EOSMAP_PRES,EOS_IN,dstruct)
  dens_map = eos_mapLookup(EOSMAP_DENS,EOS_IN,dstruct)
  temp_map = eos_mapLookup(EOSMAP_TEMP,EOS_IN,dstruct)
  gamc_map = eos_mapLookup(EOSMAP_GAMC,EOS_IN,dstruct)
  game_map = eos_mapLookup(EOSMAP_GAME,EOS_IN,dstruct)
  eint_map = eos_mapLookup(EOSMAP_EINT,EOS_IN,dstruct)
  ener_map = eos_mapLookup(EOSMAP_ENER,EOS_IN,dstruct)
  velx_map = eos_mapLookup(EOSMAP_VELX,EOS_IN,dstruct)
  vely_map = eos_mapLookup(EOSMAP_VELY,EOS_IN,dstruct)
  velz_map = eos_mapLookup(EOSMAP_VELZ,EOS_IN,dstruct)
  sumy_map = eos_mapLookup(EOSMAP_SUMY,EOS_IN,dstruct)
  ye_map   = eos_mapLookup(EOSMAP_YE,  EOS_IN,dstruct)
  entr_map = eos_mapLookup(EOSMAP_ENTR,EOS_IN,dstruct)
  pres = (EOS_PRES-1)*vecLen
  dens = (EOS_DENS-1)*vecLen
  temp = (EOS_TEMP-1)*vecLen
  gamc = (EOS_GAMC-1)*vecLen
  eint = (EOS_EINT-1)*vecLen
  ekin = (EOS_EKIN-1)*vecLen
  abar = (EOS_ABAR-1)*vecLen
  zbar = (EOS_ZBAR-1)*vecLen
  entr = (EOS_ENTR-1)*vecLen

[eos_outMap]
args=dstruct
definition =
  pres_map = eos_mapLookup(EOSMAP_PRES,EOS_OUT,dstruct)
  temp_map = eos_mapLookup(EOSMAP_TEMP,EOS_OUT,dstruct)
  gamc_map = eos_mapLookup(EOSMAP_GAMC,EOS_OUT,dstruct)
  game_map = eos_mapLookup(EOSMAP_GAME,EOS_OUT,dstruct)
  eint_map = eos_mapLookup(EOSMAP_EINT,EOS_OUT,dstruct)
  ener_map = eos_mapLookup(EOSMAP_ENER,EOS_OUT,dstruct)
  entr_map = eos_mapLookup(EOSMAP_ENTR,EOS_OUT,dstruct)


[eos_sec2]
args=Uin,i1,j1,k1
definition =


[eos_kin]
args=Uin,i1,j1,k1
definition =
  kineticEnergy=0.0
  if(velx_map > 0 .and. vely_map > 0 .and. velz_map > 0) &
  kineticEnergy  = 0.5*(Uin(velx_map,i1,j1,k1)**2 + Uin(vely_map,i1,j1,k1)**2&
  + Uin(velz_map,i1,j1,k1)**2)
  !! kineticEnergy holds velocity vector information -- 1/2 * Vmag**2
  !! internalEnergy holds eint (directly)  or energyTotal - ekinetic (calculated),
  !!          depending upon eintSwitch
   eosData(ekin+n) = kineticEnergy

[eos_internal]
 args=Uin,i1,j1,k1
definition =
 if(eint_map /= NONEXISTENT) then
         internalEnergy  = Uin(eint_map,i1,j1,k1)
              if(ener_map /= NONEXISTENT) then
                 if ( Uin(ener_map,i1,j1,k1) - kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
                    internalEnergy = Uin(ener_map,i1,j1,k1) - kineticEnergy
                 end if
              end if
           else if(game_map /= NONEXISTENT) then ! This case should be usable for R(elativistic)HD - KW
              internalEnergy  = Uin(pres_map,i1,j1,k1) / Uin(dens_map,i1,j1,k1) / &
                                   (Uin(game_map,i1,j1,k1) - 1.0)
              if(ener_map /= NONEXISTENT) then
                 if ( Uin(ener_map,i1,j1,k1) - kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
                    internalEnergy = Uin(ener_map,i1,j1,k1) - kineticEnergy
                 end if
              end if
           else if(ener_map /= NONEXISTENT) then
              internalEnergy = Uin(ener_map,i1,j1,k1)-kineticEnergy
           endif
           internalEnergy = max(internalEnergy, eos_smalle)


[eos_abarzbar]
args=Uin,i1,j1,k1
definition =
          if((ye_map /= NONEXISTENT).and.(sumy_map /= NONEXISTENT)) then
              !! cal says abar=1/sumy
              !! cal says zbar=ye / sumy and he claims sumy are never zero
              eosData(abar+n) =  1.0 /  Uin(sumy_map,i1,j1,k1)
              eosData(zbar+n) = Uin(ye_map,i1,j1,k1) /  Uin(sumy_map,i1,j1,k1)
           endif


[eos_getData]
args=Uin,i1,j1,k1
definition =
   if(entr_map /= NONEXISTENT) eosData(entr+n) = Uin(entr_map,i1,j1,k1)
   eosData(pres+n) = Uin(pres_map,i1,j1,k1)
   eosData(dens+n) = Uin(dens_map,i1,j1,k1)
   eosData(temp+n) = Uin(temp_map,i1,j1,k1)
   eosData(gamc+n) = Uin(gamc_map,i1,j1,k1)

[eos_putData]
args=Uin,i1,j1,k1
definition = 
    Uin(pres_map,i1,j1,k1) = eosData(pres+n)
    Uin(temp_map,i1,j1,k1) = eosData(temp+n)
    Uin(gamc_map,i1,j1,k1) = eosData(gamc+n)
    if(eint_map /= NONEXISTENT)Uin(eint_map,i1,j1,k1) = eosData(eint+n)
    if(ener_map /= NONEXISTENT)Uin(ener_map,i1,j1,k1) = eosData(eint+n)+eosData(ekin+n) 
    if(entr_map /= NONEXISTENT)Uin(entr_map,i1,j1,k1) = eosData(entr+n)
    Uin(game_map,i1,j1,k1) = eosData(pres+n)/(eosData(eint+n) *eosData(dens+n)) +1



[eos_debug]
definition =
  allocate(iFlag(vecLen))
  iFlag = 0
  where ( (eosData(eint+1:eint+vecLen) .eq. 0.) .or. (eosData(dens+1:dens+vecLen) .eq. 0.))
     iFlag(1:vecLen) = 1
  end where
  
  !maybe there was a wrong flag set
  if (maxval(iFlag) .gt. 0) then
     if (eos_meshMe .EQ. MASTER_PE) then
        write(*,*) "ERROR After calling Eos, eosData(EOS_EINT) or eosData(EOS_DENS) are zero"
        print*,'iflag=',iflag
        print*,'Uin(EINT_VAR,ib:ie,jb,kb)=',Uin(EINT_VAR,ib:ie,jb,kb)
        print*,'eosData (eint+1:eint+vecLen)  =',eosData(eint+1:eint+vecLen)
        print*,'Uin(DENS_VAR,ib:ie,jb,kb)=',Uin(DENS_VAR,ib:ie,jb,kb)
        print*,'eosData(dens+1:dens+vecLen)   =',eosData(dens+1:dens+vecLen)
        flagLoc = maxloc(iflag); firstFlag = flagLoc(1)
        if (firstFlag > ie-ib+1) then
           print*,'first error at element #',firstFlag,' of',vecLen
        end if
        print*,'eosData at first error:',eosData(firstFlag::vecLen)
        write(*,*) "  Perhaps the initialization routine is wrong..... or"
        write(*,*) "  perhaps the runtime parameter eosMode is wrong."
        write(*,*) "     Check constants.h to determine value of MODE_DENS_??"
     endif
     call Logfile_stampMessage('[Eos_putData] ERROR Density or Internal Energy are zero after a call to EOS!')
     call Driver_abortFlash('[Eos_putData] ERROR Density or Internal Energy are zero after a call to EOS!')
  end if
  deallocate(iFlag)


