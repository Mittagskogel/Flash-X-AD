!!****if* source/physics/Eos/EosMain/Eos_wrapped
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!! NAME
!!
!!  Eos_Wrapped
!! 
!! SYNOPSIS
!!
!!  call Eos_Wrapped(  integer(IN) :: mode,
!!                          integer(IN) :: range(HIGH, MDIM),
!!                     real,pointer(IN) :: solnData,
!!                 optional,integer(IN) :: gridDataStruct )
!!
!! DESCRIPTION
!!
!! This function is provided for the user's convenience and acts as a simple
!! wrapper to the Eos interface. The Eos interface uses a single, flexible data
!! structure "eosData" to pass the thermodynamic quantities in and out of the
!! funtion (see Eos). The wrapper hides formation and use of eosData
!! from the users.
!!
!! While Eos does not know anything about blocks, Eos_arrayWrapped takes its
!! input thermodynamic state variables from a given block's storage area.
!! It works by taking a selected section of a block
!! described by array "range" and translating it to eosData
!! before calling the Eos function.
!! Upon return from Eos, Eos_wrapper updates certain state variables in
!! the same section of the block's storage area. Which variables are taken
!! as input, and which are updated, depends on the "mode" argument.
!!
!! If you want to return the derived quantities defined from EOS_VAR+1:EOS_NUM
!! in Eos.h, then you must use the direct interface Eos().  Note that 
!! entropy EOS_ENTR is considered a derived variable.
!!
!!
!!  ARGUMENTS 
!!
!!   
!!   mode : determines which variables are used as Eos input.
!!          The valid values are MODE_DENS_EI (where density and internal
!!          energy are inputs), MODE_DENS_PRES (density and pressure as inputs)
!!          MODE_DENS_TEMP (density and temperature are inputs).
!!          These quantities are defined in constants.h, the argument is 
!!          forwarded unchanged to the Eos function call.
!!          Note that internal energy is grid variable EINT_VAR, not ENER_VAR.
!!
!! 
!!   range: an array that holds the lower and upper indices of the section
!!          of block on which Eos is to be applies. The example shows how
!!          the array describes the block section.
!!
!!   solnData: pointer to array section of solution data for a block
!!
!!   gridDataStruct : the grid data structure on whose data Eos is to be applied
!!
!!
!!  EXAMPLE 
!!      if range(LOW,IAXIS)=1,range(HIGH,IAXIS)=iguard,
!!         range(LOW,JAXIS)=1,range(HIGH,JAXIS)=jguard,
!!         range(LOW,KAXIS)=1,range(HIGH,KAXIS)=kguard,
!!      then Eos is applied to the lower left hand corner of the guard
!!      cells in the block. 
!!
!!      However if the value were
!!         range(LOW,IAXIS)=iguard+1,range(HIGH,IAXIS)=iguard+nxb,
!!         range(LOW,JAXIS)=jguard+1,range(HIGH,JAXIS)=jguard+nyb,
!!         range(LOW,KAXIS)=kguard+1,range(HIGH,KAXIS)=kguard+nzb,
!!      then Eos is applied to all the interior cells in the block.
!!
!!  NOTES
!!      This interface is defined in Fortran Module 
!!      Eos_interface. All functions calling this routine should include
!!      a statement like
!!      use Eos_interface, ONLY : Eos_arrayWrapped
!!
!!
!!  SEE ALSO
!!
!!     Eos
!!     Eos.h
!!
!!***

! solnData depends on the ordering on unk
!!REORDER(4): solnData
!!NOVARIANTS

#include "Eos.h"
#include "Eos_map.h"
#include "constants.h"
#include "Simulation.h"
 


subroutine Eos_wrapped(mode,range,solnData, gridDataStruct)

  use Driver_interface, ONLY : Driver_abort
  use Logfile_interface, ONLY: Logfile_stampMessage 
  use Eos_interface, ONLY : Eos
  use Eos_data, ONLY : eos_threadWithinBlock
  implicit none

#include "FortranLangFeatures.fh"

  integer, intent(in) :: mode
  integer, dimension(2,MDIM), intent(in) :: range
  real, POINTER_INTENT_IN :: solnData(:,:,:,:)
  integer, optional, intent(IN) :: gridDataStruct


  real, allocatable :: eosData(:),massFraction(:)

  logical,target,dimension(EOS_VARS+1:EOS_NUM) :: eosMask

  integer :: ierr, dataStruct
  integer :: i,j,k, vLen1D, vecLen,offset
  integer,dimension(MDIM) :: pos


!! ---------------------------------------------------------------------------------
  ! Test calling arguments
#define DEBUG
#ifdef DEBUG
  ierr = 1
  select case (mode)
  case (MODE_DENS_PRES)
     ierr = 0
  case (MODE_DENS_TEMP)
     ierr = 0
  case (MODE_DENS_EI)
     ierr = 0
  case (MODE_EOS_NOP,MODE_EOS_WRAPPERONLY)
     ierr = 0
  case (MODE_DENS_TEMP_ALL,MODE_DENS_TEMP_EQUI)
     ierr = 0
  case (MODE_DENS_EI_ALL,MODE_DENS_EI_SCATTER,MODE_DENS_EI_GATHER)
     ierr = 0
  case (MODE_DENS_EI_SELE_GATHER)
     ierr = 0
  case (MODE_DENS_ENTR)
     ierr = 0
  end select

  if(ierr /= 0) then
     call Driver_abort("[Eos_arrayWrapped] "//&
          "invalid mode: must be MODE_DENS_PRES, MODE_DENS_TEMP, MODE_DENS_EI, or variants thereof, or MODE_EOS_NOP")
  end if
#endif

  if (mode==MODE_EOS_NOP) return ! * Return immediately for MODE_EOS_NOP! *

  vLen1D = range(HIGH,IAXIS)-range(LOW,IAXIS)+1
  vecLen=vLen1D*(range(HIGH,JAXIS)-range(LOW,JAXIS)+1)*(range(HIGH,KAXIS)-range(LOW,KAXIS)+1)
  if (vecLen==0) return ! * Return immediately for empty IAXIS range! (for efficiency and avoiding index range errors)

  ! solnData points to solution data in UNK (or other data structure).
  ! The length of the data being operated upon is determined from the range input array.

  if(present(gridDataStruct))then
     dataStruct=gridDataStruct
  else
     dataStruct=CENTER
  end if

  allocate(massFraction(NSPECIES*vecLen))
  allocate(eosData(EOS_NUM*vecLen))

  eosMask = .FALSE.

  pos(IAXIS)=range(LOW,IAXIS)

  call Eos_getData(range,vecLen,solnData,dataStruct,eosData,massFraction)
  call Eos(mode,vecLen,eosData,massFraction,mask=eosMask)

  call Eos_putData(range,vecLen,solnData,dataStruct,eosData)
        
  deallocate(eosData)
  deallocate(massFraction)

contains


  subroutine Eos_getData &
       (range,vecLen,solnData,gridDataStruct,eosData,massFrac, eosMask)
    
    use Eos_data, ONLY: eos_eintSwitch, eos_smalle, eos_mapLookup
    use Driver_interface, ONLY : Driver_abort
    implicit none
    
    integer, intent(in) :: vecLen, gridDataStruct
    integer, dimension(LOW:HIGH,MDIM), intent(in) :: range
    real, dimension(EOS_NUM*vecLen),intent(INOUT) :: eosData
    real,dimension(:),optional,intent(OUT) :: massFrac
    logical, optional, INTENT(INOUT),dimension(EOS_VARS+1:) :: eosMask
    real, pointer:: solnData(:,:,:,:)
    
    
    integer :: i,j,k,n,m,pres,dens,gamc,temp,abar,zbar,eint,ekin,entr,elef
    integer :: pres_map,dens_map,gamc_map,game_map,temp_map,entr_map
    integer :: eint_map,ener_map, velx_map, vely_map, velz_map, sumy_map, ye_map
    integer :: ib,ie,jb,je,kb,ke
    real :: kineticEnergy, internalEnergy
    
    !! ---------------------------------------------------------------------------------
    ! Test calling arguments
    
    ! Initializations:   grab the solution data from UNK and determine
    !   the length of the data being operated upon
    
    ib=range(LOW,IAXIS)
    jb=range(LOW,JAXIS)
    kb=range(LOW,KAXIS)
    ie=range(HIGH,IAXIS)
    je=range(HIGH,JAXIS)
    ke=range(HIGH,KAXIS)
    
!!$  select case(axis)
!!$  case(IAXIS)
!!$     ie=ie+vecLen-1
!!$  case(JAXIS)
!!$     je=je+vecLen-1
!!$  case(KAXIS)
!!$     ke=ke+vecLen-1
!!$  end select
    
    ! These integers are indexes into the location in eosData just before the storage area for the appropriate variable.
    pres = (EOS_PRES-1)*vecLen
    dens = (EOS_DENS-1)*vecLen
    temp = (EOS_TEMP-1)*vecLen
    gamc = (EOS_GAMC-1)*vecLen
    eint = (EOS_EINT-1)*vecLen
    ekin = (EOS_EKIN-1)*vecLen
    abar = (EOS_ABAR-1)*vecLen
    zbar = (EOS_ZBAR-1)*vecLen
    entr = (EOS_ENTR-1)*vecLen
    elef = (EOS_YE-1)*vecLen
    
    pres_map = eos_mapLookup(EOSMAP_PRES,EOS_IN,gridDataStruct)
    dens_map = eos_mapLookup(EOSMAP_DENS,EOS_IN,gridDataStruct)
    temp_map = eos_mapLookup(EOSMAP_TEMP,EOS_IN,gridDataStruct)
    gamc_map = eos_mapLookup(EOSMAP_GAMC,EOS_IN,gridDataStruct)
    game_map = eos_mapLookup(EOSMAP_GAME,EOS_IN,gridDataStruct)
    eint_map = eos_mapLookup(EOSMAP_EINT,EOS_IN,gridDataStruct)
    ener_map = eos_mapLookup(EOSMAP_ENER,EOS_IN,gridDataStruct)
    velx_map = eos_mapLookup(EOSMAP_VELX,EOS_IN,gridDataStruct)
    vely_map = eos_mapLookup(EOSMAP_VELY,EOS_IN,gridDataStruct)
    velz_map = eos_mapLookup(EOSMAP_VELZ,EOS_IN,gridDataStruct)
    sumy_map = eos_mapLookup(EOSMAP_SUMY,EOS_IN,gridDataStruct)
    ye_map   = eos_mapLookup(EOSMAP_YE,  EOS_IN,gridDataStruct)
    entr_map = eos_mapLookup(EOSMAP_ENTR,EOS_IN,gridDataStruct)
    
    if(gridDataStruct == SCRATCH) then
       call Driver_abort("Eos_getData : the use of SCRATCH is deprecated")
    end if
    
    if(present(massFrac)) then
       m=1
       do k = kb,ke
          do j = jb,je
             do i = ib,ie
                do n = SPECIES_BEGIN,SPECIES_END
                   massFrac(m) = solnData(n,i,j,k)
                   m=m+1
                end do
             end do
          end do
       end do
    end if
    
    n = 0
    do k = kb,ke
       do j = jb,je
          do i = ib,ie
             if (velx_map > 0 .AND. vely_map > 0 .AND. velz_map > 0) then
                kineticEnergy  = 0.5*(solnData(velx_map,i,j,k)**2 + &
                     solnData(vely_map,i,j,k)**2 + &
                     solnData(velz_map,i,j,k)**2)
             else
                kineticEnergy = 0.0
             end if
             
             n=n+1
             eosData(ekin+n) = kineticEnergy
             !! kineticEnergy holds velocity vector information -- 1/2 * Vmag**2
             !! internalEnergy holds eint (directly)  or energyTotal - ekinetic (calculated),
             !!          depending upon eintSwitch
             if(eint_map /= NONEXISTENT) then
                internalEnergy  = solnData(eint_map,i,j,k)
                if(ener_map /= NONEXISTENT) then
                   if ( solnData(ener_map,i,j,k) - kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
                      internalEnergy = solnData(ener_map,i,j,k) - kineticEnergy
                   end if
                end if
             else if(game_map /= NONEXISTENT) then ! This case should be usable for R(elativistic)HD - KW
                internalEnergy  = solnData(pres_map,i,j,k) / solnData(dens_map,i,j,k) / &
                     (solnData(game_map,i,j,k) - 1.0)
                if(ener_map /= NONEXISTENT) then
                   if ( solnData(ener_map,i,j,k) - kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
                      internalEnergy = solnData(ener_map,i,j,k) - kineticEnergy
                   end if
                end if
             else if(ener_map /= NONEXISTENT) then
                internalEnergy = solnData(ener_map,i,j,k)-kineticEnergy
             else
                internalEnergy = eos_smalle
             endif
             
             internalEnergy = max(internalEnergy, eos_smalle)
             eosData(eint+n) = internalEnergy
             
             eosData(pres+n) = solnData(pres_map,i,j,k)
             eosData(dens+n) = solnData(dens_map,i,j,k)
             eosData(temp+n) = solnData(temp_map,i,j,k)
             eosData(gamc+n) = solnData(gamc_map,i,j,k)
             
             if (ye_map /= NONEXISTENT) then
!!!!             eosData(abar+n) =  1.0d0
!!!!             eosData(zbar+n) = solnData(ye_map,i,j,k)
                eosData(elef+n) = solnData(ye_map,i,j,k)
             endif
             
             if((ye_map /= NONEXISTENT).and.(sumy_map /= NONEXISTENT)) then
                !! cal says abar=1/sumy
                !! cal says zbar=ye / sumy and he claims sumy are never zero
                eosData(abar+n) =  1.0 /  solnData(sumy_map,i,j,k)
                eosData(zbar+n) = solnData(ye_map,i,j,k) /  solnData(sumy_map,i,j,k)
                !PRINT*,'sumy_map'
             endif
             if(entr_map /= NONEXISTENT) eosData(entr+n) = solnData(entr_map,i,j,k)
          end do
       end do
    end do
    
  end subroutine Eos_getData


  subroutine Eos_putData(range,vecLen,solnData,gridDataStruct,eosData)
    
    use Driver_interface, ONLY : Driver_abort
    use Logfile_interface, ONLY: Logfile_stampMessage 
    use Eos_data, ONLY : eos_mapLookup, eos_meshMe
    
    implicit none
    
    integer, intent(in) :: vecLen, gridDataStruct
    integer,dimension(LOW:HIGH,MDIM), intent(in) :: range
    real,intent(IN) :: eosData(:)
    real, pointer:: solnData(:,:,:,:)
    
    
    integer :: i,j,k,n, pres,dens,gamc,temp,abar,zbar,eint,entr,ekin
    integer :: ib,ie,jb,je,kb,ke
    
    integer :: pres_map,entr_map,gamc_map,temp_map
    integer :: eint_map,ener_map,game_map
    
    integer :: flagLoc(1),firstFlag
    integer,allocatable,dimension(:) :: iFlag
    
    
    ! check for zero values before calculating gamma
    ! These integers are indexes into the location in eosData just before the storage area for the appropriate variable.
    ib=range(LOW,IAXIS)
    jb=range(LOW,JAXIS)
    kb=range(LOW,KAXIS)
    ie=range(HIGH,IAXIS)
    je=range(HIGH,JAXIS)
    ke=range(HIGH,KAXIS)
!!$  select case(axis)
!!$  case(IAXIS)
!!$     ie=ie+vecLen-1
!!$  case(JAXIS)
!!$     je=je+vecLen-1
!!$  case(KAXIS)
!!$     ke=ke+vecLen-1
!!$  end select
    
    ! These integers are indexes into the location in eosData just before the storage area for the appropriate variable.
    pres = (EOS_PRES-1)*vecLen
    dens = (EOS_DENS-1)*vecLen
    temp = (EOS_TEMP-1)*vecLen
    gamc = (EOS_GAMC-1)*vecLen
    eint = (EOS_EINT-1)*vecLen
    abar = (EOS_ABAR-1)*vecLen
    zbar = (EOS_ZBAR-1)*vecLen
    entr = (EOS_ENTR-1)*vecLen
    ekin = (EOS_EKIN-1)*vecLen
#ifdef DEBUG_EOS
    allocate(iFlag(vecLen))
    iFlag = 0
    where ( (eosData(eint+1:eint+vecLen) .eq. 0.) .or. (eosData(dens+1:dens+vecLen) .eq. 0.))
       iFlag(1:vecLen) = 1
    end where
    
    !maybe there was a wrong flag set
    if (maxval(iFlag) .gt. 0) then
       if (eos_meshMe .EQ. MASTER_PE) then
          write(*,*) "ERROR After calling Eos, eosData(EOS_EINT) or eosData(EOS_DENS) are zero"
          print*,'iflag=',iflag
          print*,'solnData(EINT_VAR,ib:ie,jb,kb)=',solnData(EINT_VAR,ib:ie,jb,kb)
          print*,'eosData (eint+1:eint+vecLen)  =',eosData(eint+1:eint+vecLen)
          print*,'solnData(DENS_VAR,ib:ie,jb,kb)=',solnData(DENS_VAR,ib:ie,jb,kb)
          print*,'eosData(dens+1:dens+vecLen)   =',eosData(dens+1:dens+vecLen)
          flagLoc = maxloc(iflag); firstFlag = flagLoc(1)
          if (firstFlag > ie-ib+1) then
             print*,'first error at element #',firstFlag,' of',vecLen
          end if
          print*,'eosData at first error:',eosData(firstFlag::vecLen)
          write(*,*) "  Perhaps the initialization routine is wrong..... or"
          write(*,*) "  perhaps the runtime parameter eosMode is wrong."
          write(*,*) "     Check constants.h to determine value of MODE_DENS_??"
       endif
       call Logfile_stampMessage('[Eos_putData] ERROR Density or Internal Energy are zero after a call to EOS!')
       call Driver_abort('[Eos_putData] ERROR Density or Internal Energy are zero after a call to EOS!')
    end if
    deallocate(iFlag)
#endif
    
    
    ! Initializations:   grab the solution data from UNK and determine
    !   the length of the data being operated upon
    pres_map = eos_mapLookup(EOSMAP_PRES,EOS_OUT,gridDataStruct)
    temp_map = eos_mapLookup(EOSMAP_TEMP,EOS_OUT,gridDataStruct)
    gamc_map = eos_mapLookup(EOSMAP_GAMC,EOS_OUT,gridDataStruct)
    game_map = eos_mapLookup(EOSMAP_GAME,EOS_OUT,gridDataStruct)
    eint_map = eos_mapLookup(EOSMAP_EINT,EOS_OUT,gridDataStruct)
    ener_map = eos_mapLookup(EOSMAP_ENER,EOS_OUT,gridDataStruct)
    entr_map = eos_mapLookup(EOSMAP_ENTR,EOS_OUT,gridDataStruct)
    
    if(gridDataStruct == SCRATCH) then
       call Driver_abort("Eos_getData : the use of SCRATCH is deprecated")
    end if
    
    n=0
    do k = kb,ke
       do j = jb,je
          do i = ib,ie
             n=n+1
             solnData(pres_map,i,j,k) = eosData(pres+n)
             solnData(temp_map,i,j,k) = eosData(temp+n)
             solnData(gamc_map,i,j,k) = eosData(gamc+n)
             if(eint_map /= NONEXISTENT)solnData(eint_map,i,j,k) = eosData(eint+n)
             if(ener_map /= NONEXISTENT)solnData(ener_map,i,j,k) = eosData(eint+n)+eosData(ekin+n) 
             if(entr_map /= NONEXISTENT)solnData(entr_map,i,j,k) = eosData(entr+n)
             
             solnData(game_map,i,j,k) = eosData(pres+n)/&
                  (eosData(eint+n) *eosData(dens+n)) +1
             
          end do
       end do
    end do
    
  end subroutine Eos_putData
  

  
end subroutine Eos_wrapped
