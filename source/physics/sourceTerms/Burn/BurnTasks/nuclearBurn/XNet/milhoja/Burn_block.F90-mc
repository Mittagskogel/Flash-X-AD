!!****if* source/physics/sourceTerms/Burn/BurnTasks/nuclearBurn/XNet/Burn_block
!! NOTICE
!!  Copyright 2024 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!! NAME
!!
!!  Burn_block
!!
!!
!! SYNOPSIS
!!
!!   call Burn_block     ( real(IN) ::  dt,
!!                         integer(IN) :: lo(MDIM),
!!                         integer(IN) :: hi(MDIM),
!!                         real(IN)    :: deltas(MDIM),
!!                         integer(IN) :: level,
!!                         integer(INOUT),TARGET,dimension(loU(1):,loU(2):,loU(3):,loU(4):) :: U(:,:,:,:),
!!                         integer(IN) :: loU(MDIM+1) )
!!
!! DESCRIPTION
!!
!!  Apply burner to one block
!!
!! ARGUMENTS
!!
!!   dt  --       passed to the internal bn_burnerPlus subroutine
!!
!! NOTES
!!
!!  The burning unit adds a new mesh variable ENUC_VAR which is the nuclear energy
!!             generation rate
!!
!!***

!!REORDER(4): solnData

#include "Simulation.h"
#include "constants.h"

subroutine Burn_block ( dt, lo, hi, deltas, level, U, loU )

  use Eos_interface, ONLY : Eos_multiDim
  use Grid_interface, ONLY : Grid_getCellCoords
  use Hydro_interface, ONLY : Hydro_shockStrength
  use Timers_interface, ONLY : Timers_start, Timers_stop
  use Burn_data, ONLY : bn_useShockBurn, &
       &   bn_useBurn, bn_threadWithinBlock
  use bn_interfaceTypeDecl, ONLY: bn_azbarEtc_t
  use bn_interface, ONLY : bn_burnerPlus, bn_getAbarZbarEtc
  use bn_xnetData, ONLY : xnet_myid, xnet_nzbatchmx, xnet_inuc2unk

  implicit none

  !args
   real, intent(in) :: dt
   integer, intent(IN)  :: lo(1:MDIM)
   integer, intent(IN)  :: hi(1:MDIM)
   real,    intent(IN)  :: deltas(1:MDIM)
   integer, intent(IN)  :: level
   integer, intent(IN)  :: loU(1:MDIM+1)
   real,    intent(INOUT), TARGET  :: U(loU(1):, loU(2):, loU(3):, loU(4):)

  ! locals
   real, dimension(:,:,:,:),POINTER,CONTIGUOUS :: solnData

   integer :: thisBlock          ! like a blockID
   real, allocatable, dimension(:)   :: xCoord, yCoord, zCoord

   integer :: iSize, jSize, kSize
   integer,dimension(1:MDIM) :: loHalo, hiHalo
   integer, dimension(2,MDIM) :: limits

   real :: ni56massFrac
   logical :: doShockDetect

   real,    allocatable, target :: xIn(:,:,:,:), xOut(:,:,:,:)
   real,    allocatable, target :: sdot(:,:,:), tmp(:,:,:), rho(:,:,:)
   logical, allocatable, target :: burnedZone(:,:,:)
   integer, allocatable, target :: zone(:,:,:,:)

   real,    pointer :: xIn_batch(:,:,:), xOut_batch(:,:,:)
   real,    pointer :: sdot_batch(:,:), tmp_batch(:,:), rho_batch(:,:)
   logical, pointer :: burnedZone_batch(:,:)
   integer, pointer :: zone_batch(:,:,:)

   integer :: nzones, batchCount
   integer, dimension(:), allocatable :: sumBurn_TS_batch
   integer :: batch_lo, batch_hi
   integer :: sumBurn_TS

   integer, parameter :: shock_mode = 1
   real, parameter :: shock_thresh = 0.33
#ifdef INDEXREORDER
   integer,parameter::IX=1,IY=2,IZ=3
#else
   integer,parameter::IX=2,IY=3,IZ=4
#endif
   real :: ei, ek, enuc
   integer :: i, j, k, m, ii, jj, kk

   type(bn_azbarEtc_t) :: azbarEtc

  ! ----------------------- check if burning is requested in runtime parameters -------
   if (.not. bn_useBurn) return

  !---------------------------------------------------------------------------------

  ! start the timer ticking
   call Timers_start("burn block cpu")

   call Timers_start("burn_top block cpu")

   iSize = hi(IAXIS)-lo(IAXIS)+1
   jSize = hi(JAXIS)-lo(JAXIS)+1
   kSize = hi(KAXIS)-lo(KAXIS)+1


   allocate(xIn(NSPECIES,iSize,jSize,kSize))
   allocate(xOut(NSPECIES,iSize,jSize,kSize))
   allocate(sdot(iSize,jSize,kSize))
   allocate(tmp(iSize,jSize,kSize))
   allocate(rho(iSize,jSize,kSize))
   allocate(burnedZone(iSize,jSize,kSize))
   allocate(zone(4,iSize,jSize,kSize))


   batch_lo = 1
   nzones = iSize * jSize * kSize
   batch_hi = (nzones + xnet_nzbatchmx - 1) / xnet_nzbatchmx

   solnData => U
   thisBlock = -1
   doShockDetect = .NOT. bn_useShockBurn

     ! Shock detector
   if (doShockDetect) then
      loHalo(:)= (/lbound(U,IX), lbound(U,IY), lbound(U,IZ)/)
      hiHalo(:)= (/ubound(U,IX), ubound(U,IY), ubound(U,IZ)/)

        ! allocate space for dimensions
      allocate(xCoord(loHalo(IAXIS):hiHalo(IAXIS)))
      allocate(yCoord(loHalo(JAXIS):hiHalo(JAXIS)))
      allocate(zCoord(loHalo(KAXIS):hiHalo(KAXIS)))

      call Grid_getCellCoords(IAXIS,CENTER,level,loHalo,hiHalo,xCoord)
      call Grid_getCellCoords(JAXIS,CENTER,level,loHalo,hiHalo,yCoord)
      call Grid_getCellCoords(KAXIS,CENTER,level,loHalo,hiHalo,zCoord)

        ! Use the pointer to solution data
      call Hydro_shockStrength(solnData,                                       &
                              solnData(SHOK_VAR,loHalo(IAXIS):hiHalo(IAXIS),  &
                                                loHalo(JAXIS):hiHalo(JAXIS),  &
                                                loHalo(KAXIS):hiHalo(KAXIS)), &
                              lo, hi, loHalo, hiHalo,                         &
                              xCoord,yCoord,zCoord,shock_thresh,shock_mode)
      deallocate(xCoord)
      deallocate(yCoord)
      deallocate(zCoord)
   endif

   solnData(NMPI_VAR,:,:,:) = xnet_myid

    !$omp parallel do if(bn_threadWithinBlock) &
    !$omp collapse(3) &
    !$omp default(shared) &
    !$omp private(k,kk,j,jj,i,ii,ni56massFrac)
   do k = lo(KAXIS), hi(KAXIS)
      do j = lo(JAXIS), hi(JAXIS)
         do i = lo(IAXIS), hi(IAXIS)
            kk = k - lo(KAXIS) + 1
            jj = j - lo(JAXIS) + 1
            ii = i - lo(IAXIS) + 1

            tmp(ii,jj,kk)  = solnData(TEMP_VAR,i,j,k)
            rho(ii,jj,kk)  = solnData(DENS_VAR,i,j,k)
            sdot(ii,jj,kk) = 0.0e0

            zone(1,ii,jj,kk) = ii
            zone(2,ii,jj,kk) = jj
            zone(3,ii,jj,kk) = kk
            zone(4,ii,jj,kk) = thisBlock

              ! Map the solution data into the order required by bn_burnerPlus
            xIn(1:NSPECIES,ii,jj,kk) = solnData(xnet_inuc2unk,i,j,k)

            if (NI56_SPEC > NONEXISTENT) then
               ni56massFrac = solnData(NI56_SPEC,i,j,k)
            else    ! nickel is not even a species in this simulation
               ni56massFrac = 0.0
            endif
            if (doShockDetect) then
               burnedZone(ii,jj,kk) = &
                                   determine_whether_to_burn(tmp(ii,jj,kk), &
                                                             rho(ii,jj,kk), &
                                                             solnData(SHOK_VAR,i,j,k), &
                                                             ni56massFrac)
            else
               burnedZone(ii,jj,kk) = &
                                   determine_whether_to_burn(tmp(ii,jj,kk), &
                                                             rho(ii,jj,kk), &
                                                             0.0, &
                                                             ni56massFrac)
            end if

         end do
      end do
   end do
    !$omp end parallel do

   call Timers_stop("burn_top block cpu")

   call Timers_start("burn_middle block cpu")

  ! get number of batches needed for all local zones (round up)
   batchCount = (nzones + xnet_nzbatchmx - 1) / xnet_nzbatchmx

  ! reshape all local zone data arrays into batches
   tmp_batch (1:xnet_nzbatchmx,1:batchCount) => tmp (:,:,:)
   rho_batch (1:xnet_nzbatchmx,1:batchCount) => rho (:,:,:)
   sdot_batch(1:xnet_nzbatchmx,1:batchCount) => sdot(:,:,:)
   xIn_batch (1:NSPECIES,1:xnet_nzbatchmx,1:batchCount) => xIn (:,:,:,:)
   xOut_batch(1:NSPECIES,1:xnet_nzbatchmx,1:batchCount) => xOut(:,:,:,:)
   burnedZone_batch(1:xnet_nzbatchmx,1:batchCount) => burnedZone(:,:,:)
   zone_batch(1:4,1:xnet_nzbatchmx,1:batchCount) => zone(:,:,:,:)

   allocate(sumBurn_TS_batch(batchCount))

    !$omp parallel do if(bn_threadWithinBlock) &
    !$omp schedule(runtime) &
    !$omp default(shared)
   do m = 1, batchCount
     ! Do the actual burn
      call bn_burnerPlus(dt, tmp_batch(:,m), rho_batch(:,m), xIn_batch(:,:,m), &
          xOut_batch(:,:,m), sdot_batch(:,m), burnedZone_batch(:,m), zone_batch(:,:,m), sumBurn_TS_batch(m))
   end do
    !$omp end parallel do

  ! get average sumBurn_TS_batch per block
   sumBurn_TS = sum( sumBurn_TS_batch(batch_lo:batch_hi) ) &
                           / batchCount

   deallocate(sumBurn_TS_batch)

   call Timers_stop("burn_middle block cpu")

   call Timers_start("burn_bottom block cpu")

  ! Use pointer to solution data

  ! Now put updated local data arrays back into unk through solnData pointer
    !$omp parallel if(bn_threadWithinBlock) &
    !$omp default(shared) &
    !$omp private(k,kk,j,jj,i,ii,ei,ek,enuc,azbarEtc)
    !$omp do collapse(3)
   do k = lo(KAXIS), hi(KAXIS)
      do j = lo(JAXIS), hi(JAXIS)
         do i = lo(IAXIS), hi(IAXIS)
            kk = k - lo(KAXIS) + 1
            jj = j - lo(JAXIS) + 1
            ii = i - lo(IAXIS) + 1

            ! Map the solution mass fractions back from the order used by bn_burnerPlus
            solnData(xnet_inuc2unk,i,j,k) = xOut(1:NSPECIES,ii,jj,kk)

              !  NOTE should probably do something here with eintSwitch for consistency
              !  LBR will settle for simply using internal energy!
              ! kinetic energy
            ek = 0.5e0*(solnData(VELX_VAR,i,j,k)**2 +  &
                 solnData(VELY_VAR,i,j,k)**2 +  &
                 solnData(VELZ_VAR,i,j,k)**2)

              ! internal energy, add on nuclear rate*timestep
            enuc = dt*sdot(ii,jj,kk)
            ei = solnData(ENER_VAR,i,j,k) + enuc - ek

            solnData(ENUC_VAR,i,j,k) = sdot(ii,jj,kk)

              ! only update internal energy if the zone actually burned
            if (burnedZone(ii,jj,kk)) then
#ifdef EINT_VAR
               solnData(EINT_VAR,i,j,k) = ei
#endif
               solnData(ENER_VAR,i,j,k) = ei + ek
#ifdef EELE_VAR
               solnData(EELE_VAR,i,j,k) = solnData(EELE_VAR,i,j,k) + enuc
#endif

               call bn_getAbarZbarEtc(azbarEtc,massFrac=xOut(1:NSPECIES,ii,jj,kk))

#ifdef YE_MSCALAR
               solnData(YE_MSCALAR,i,j,k) = azbarEtc % bye
#endif
#ifdef SUMY_MSCALAR
               solnData(SUMY_MSCALAR,i,j,k) = azbarEtc % ytot1
#endif
            end if
         end do
      end do
   end do
    !$omp end do nowait

!!$  call Grid_setWork(tileDesc,real(sumBurn_TS)) <- to be done later by caller!
    !$omp workshare
   solnData(MTSB_VAR,:,:,:) = real(sumBurn_TS)
    !$omp end workshare
    !$omp end parallel

  ! we've altered the EI, let's equilibrate
   if (any(burnedZone(:,:,:))) then
      limits(LOW,:) = lo(:)
      limits(HIGH,:) = hi(:)

#ifdef FLASH_UHD_3T
      call Eos_multiDim(MODE_DENS_EI_GATHER,limits,solnData) ! modified for 3T
#else
      call Eos_multiDim(MODE_DENS_EI,limits,solnData)
#endif

   end if



   call Timers_stop("burn_bottom block cpu")

   deallocate(xIn)
   deallocate(xOut)
   deallocate(sdot)
   deallocate(tmp)
   deallocate(rho)
   deallocate(burnedZone)
   deallocate(zone)

   call Timers_stop("burn block cpu")

   return

contains
   logical function determine_whether_to_burn(zoneTemp,zoneDens,zoneShock,ni56massFrac) result(res)
      use Burn_data, ONLY : bn_nuclearTempMin, bn_nuclearTempMax, bn_nuclearDensMin, &
           &   bn_nuclearDensMax, bn_nuclearNI56Max, bn_useShockBurn

      real,intent(in) :: zoneTemp,zoneDens,zoneShock,ni56massFrac
      logical :: okBurnTemp, okBurnDens, okBurnShock, okBurnNickel

      res = .FALSE.
      okBurnNickel = .FALSE.

      okBurnTemp = (zoneTemp >= bn_nuclearTempMin .AND. zoneTemp <= bn_nuclearTempMax)
      okBurnDens = (zoneDens >= bn_nuclearDensMin .AND. zoneDens <= bn_nuclearDensMax)
      okBurnShock = (zoneShock <= 0.0 .OR. (zoneShock > 0.0 .AND. bn_useShockBurn))

      if (okBurnTemp .AND. okBurnDens .AND. okBurnShock) then

         if (NI56_SPEC /= NONEXISTENT) then
            okBurnNickel = (ni56massFrac < bn_nuclearNI56Max)
         else    ! nickel is not even a species in this simulation, so we'll always burn
            okBurnNickel = .TRUE.
         endif

      end if

      res = okBurnNickel
   end function determine_whether_to_burn

end subroutine Burn_block
! Local Variables:
! mode: F90
! f90-program-indent: 3
! indent-tabs-mode: nil
! End:
