
[hy_check_config]
definition=
  #ifdef SPARK_HYDRO_NONTELESC
     if (hy_fluxCorrect .AND. hy_fluxCorrectPerLevel) then
        call Driver_abort("Cannot enable per-level flux correction for nontelescoping Spark!")
  #if defined(FLASH_GRID_AMREX) || defined(FLASH_GRID_MILHOJA)
     else
        block
          logical,SAVE :: wantWarning = .TRUE.
          if (wantWarning) then
             print*,'WARNING: Nontelescoping Spark with Amrex Grid, number of SCRATCHCENTERVARs may be wrong!'
             print*,'WARNING: NSCRATCH_CENTER_VARS =',NSCRATCH_CENTER_VARS,', NUNK_VARS =',NUNK_VARS
  #ifdef __GFORTRAN__
  #   define STRINGIFY_START(X) "&
  #   define STRINGIFY_END(X) &X"
  #else /* default stringification */
  #   define STRINGIFY_(X) #X
  #   define STRINGIFY_START(X) &
  # define STRINGIFY_END(X) STRINGIFY_(X)
  #endif
             print*,'WARNING: NSCRATCH_CENTER_VARS is ', STRINGIFY_START(NSCRATCH_CENTER_VARS)
             STRINGIFY_END(NSCRATCH_CENTER_VARS)
          end if
          wantWarning = .FALSE.
        end block
  #endif
     end if
  #endif

[hy_addFluxes]
definition=
     @M hy_fill_fareas
     @M loop_3d_plus(blkLimits,1,0,0)
        hy_fluxBufX(1:NFLUXES,i,j,k) = hy_farea(i,j,k)*hy_weights(stage)*hy_flx(1:NFLUXES,i,j,k)
     @M loop_end_3d
     if (NDIM > 1) then
         @M loop_3d_plus(blkLimits,0,1,0)
          hy_fluxBufY(1:NFLUXES,i,j,k) = hy_fareaY(i,j,k)*hy_weights(stage)*hy_fly(1:NFLUXES,i,j,k)
        @M loop_end_3d
     end if	 
     if (NDIM > 2) then
        @M loop_3d_plus(blkLimits,0,0,1)
          hy_fluxBufZ(1:NFLUXES,i,j,k) = hy_fareaZ(i,j,k)*hy_weights(stage)*hy_flz(1:NFLUXES,i,j,k)
	 @M loop_end_3d
     end if
     @ M hy_release_fareas
     call Grid_putFluxData_block(tileDesc,&
          hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ,blkLimits(LOW,:),&
           add=hy_addFluxArray(stage))

[hy_map_tmp_states]
definition=
    hy_starState => Uin
    nullify(hy_tmpState)
    call tileDesc%%getDataPtr(hy_tmpState, SCRATCH_CTR)

[hy_release_tmp_states]
definition=
   nullify(hy_starState)
   nullify(hy_tmpState)



[hy_saveState]
definition =
  ! update temp vars with solution data
  if(stage==1) then
    !$omp target teams distribute parallel do simd collapse(3) &
    !$omp default(none) &
    !$omp private(i, j, k, v) &
    !$omp shared(blkLimits, Uin, hy_tmpState)
    @M loop_3d(blkLimits)
       do v=1,NUNK_VARS
          hy_tmpState(v,i,j,k)=Uin(v,i,j,k)
       end do
    @M loop_end_3d
  end if

[hy_updateState]
definition =
  #ifdef GPOT_VAR
  ! reset GPOT_VAR
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       hy_tmpState(GPOT_VAR,@M bounds_3d(blkLimits))
  #endif

[hy_stages_t]
definition = 

[hy_end_stages_t]
definition = 


[hy_stages_nt]
definition = 
  do stage=1,last_stage 

[hy_end_stages_nt]
definition =
   end do  ! end stages



[hy_setLims]
args=ng
definition=
  limits = blkLimits
