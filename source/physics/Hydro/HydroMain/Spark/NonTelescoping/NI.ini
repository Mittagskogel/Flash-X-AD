
[hy_addFluxes]
definition=
     @M hy_fill_fareas
     @M loop_3d_plus(blkLimits,1,0,0)
        hy_fluxBufX(1:NFLUXES,i,j,k) = hy_farea(i,j,k)*hy_weights(stage)*hy_flx(1:NFLUXES,i,j,k)
     @M loop_end_3d
     if (NDIM > 1) then
         @M loop_3d_plus(blkLimits,0,1,0)
          hy_fluxBufY(1:NFLUXES,i,j,k) = hy_fareaY(i,j,k)*hy_weights(stage)*hy_fly(1:NFLUXES,i,j,k)
        @M loop_end_3d
     end if	 
     if (NDIM > 2) then
        @M loop_3d_plus(blkLimits,0,0,1)
          hy_fluxBufZ(1:NFLUXES,i,j,k) = hy_fareaZ(i,j,k)*hy_weights(stage)*hy_flz(1:NFLUXES,i,j,k)
	 @M loop_end_3d
     end if
     @ M hy_release_fareas
     call Grid_putFluxData_block(tileDesc,&
          hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ,blkLimits(LOW,:),&
           hy_addFluxArray(stage))

[hy_map_tmp_states]
definition=
    hy_starState => Uin
    nullify(hy_tmpState)
    call tileDesc%%getDataPtr(hy_tmpState, SCRATCH_CTR)

[hy_release_tmp_states]
definition=
   nullify(hy_starState)
   nullify(hy_tmpState)



[hy_saveState]
definition =
  ! update temp vars with solution data
  if(stage==1) then
    !$omp target teams distribute parallel do simd collapse(3) &
    !$omp default(none) &
    !$omp private(i, j, k, v) &
    !$omp shared(blkLimitsGC, Uin, hy_tmpState)
    @M loop_3d(blkLimitsGC)
       do v=1,NUNK_VARS
          hy_tmpState(v,i,j,k)=Uin(v,i,j,k)
       end do
    @M loop_end_3d
  end if

[hy_updateState]
definition =
  #ifdef GPOT_VAR
  ! reset GPOT_VAR
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       hy_tmpState(GPOT_VAR,@M bounds_3d(blkLimits))
  #endif

[hy_stages_t]
definition = 

[hy_end_stages_t]
definition = 


[hy_stages_nt]
definition = 
  do stage=1,last_stage 

[hy_end_stages_nt]
definition =
   end do  ! end stages



[hy_setLims]
args=ng
definition=
  limits = blkLimits
