[hy_rk_lastStage]
definition =


[saveGlobalState]
definition =
     nullify(Uin)
     @M iter_all_begin(LEAF,.false.,blkLimits,blkLimitsGC)
	 @M loop_3d(blkLimitsGC)
           Uin(MASS_VAR,i,j,k)=Uin(DENS_VAR,i,j,k)
           Uin(MENE_VAR,i,j,k)=Uin(ENER_VAR,i,j,k)*Uin(DENS_VAR,i,j,k)
           Uin(XMOM_VAR,i,j,k)=Uin(VELX_VAR,i,j,k)*Uin(DENS_VAR,i,j,k)
           Uin(YMOM_VAR,i,j,k)=Uin(VELY_VAR,i,j,k)*Uin(DENS_VAR,i,j,k)
           Uin(ZMOM_VAR,i,j,k)=Uin(VELZ_VAR,i,j,k)*Uin(DENS_VAR,i,j,k)
        @M loop_end_3d
      @M iter_end


[hy_rk_retrieveState]
definition =
           tmpState(HY_MASS)=Uin(MASS_VAR,i,j,k)
           tmpState(HY_ENER)=Uin(MENE_VAR,i,j,k)
           tmpState(HY_XMOM)=Uin(XMOM_VAR,i,j,k)
           tmpState(HY_YMOM)=Uin(YMOM_VAR,i,j,k)
           tmpState(HY_ZMOM)=Uin(ZMOM_VAR,i,j,k)

[hy_rk_firstStage]
definition =
     ! DivB will technically be lagged by 1 step, but we need ghost zones to
     ! compute the gradients. I aint doing more communication for a diagnostic...
        @M hy_tmp_ind
        call allocate_scr(blkLimits,blkLimitsGC)
        hy_del=deltas
	limits = blkLimits
        call calcDivB(Uin,hy_del,blkLimits) 
        call shockDetect(Uin,limits,blkLimitsGC)
