
[hy_addFluxes]
definition=
     @M loop_3d_plus(blkLimits,1,0,0)
        hy_fluxBufX(1:NFLUXES,i,j,k) = hy_weights(stage)*hy_flx(1:NFLUXES,i,j,k) + &
	    wt*hy_fluxBufX(1:NFLUXES,i,j,k)
     @M loop_end_3d
     if (NDIM > 1) then
         @M loop_3d_plus(blkLimits,0,1,0)
          hy_fluxBufY(1:NFLUXES,i,j,k) = hy_weights(stage)*hy_fly(1:NFLUXES,i,j,k) + &
	    wt*hy_fluxBufY(1:NFLUXES,i,j,k)
        @M loop_end_3d
     end if	 
     if (NDIM > 2) then
        @M loop_3d_plus(blkLimits,0,0,1)
          hy_fluxBufZ(1:NFLUXES,i,j,k) = hy_weights(stage)*hy_flz(1:NFLUXES,i,j,k) + &
	    wt*hy_fluxBufZ(1:NFLUXES,i,j,k)
        @M loop_end_3d
     end if

[hy_saveFluxBuf]
args= fluxBuf, farea, flux
definition=
  fluxBuf(v,i,j,k) = weights(stage)*flux(v,i,j,k) + wt*fluxBuf(v,i,j,k)


[hy_calcDivB]
definition=
 #ifdef SPARK_GLM
  @M loop_3d(blkLimits)
           divB = 0.0
 #if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/deltas(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/deltas(JAXIS)
 #if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/deltas(KAXIS)
 #endif
 #endif
           Uin(DIVB_VAR,i,j,k) = divB
   @M loop_end_3d
 #endif

[hy_DIR_recon_private]
definition=
  !$omp private(W5p, W5m, betaWeno, Alpha5, omega, invSumAlpha, abs_betadiff)
[hy_DIR_recon_shared]
definition=
  !$omp shared(coeff1p1, coeff1p2, coeff1p3, coeff1m1, coeff1m2, coeff1m3, linWp, linWm)



[hy_recon]
definition=
  W5p(1) = dot_product(coeff1p1(1:3), p_rope(v,i-2:i+0,j,k))
  W5p(2) = dot_product(coeff1p2(1:3), p_rope(v,i-1:i+1,j,k))
  W5p(3) = dot_product(coeff1p3(1:3), p_rope(v,i-0:i+2,j,k))
  !!
  !! Calculate smoothness indicators at i+1/2
  betaWeno(1) = n13o12*(p_rope(v,i-2,j,k) - 2.*p_rope(v,i-1,j,k) +   p_rope(v,i+0,j,k))**2 &
               + 0.25*(p_rope(v,i-2,j,k) - 4.*p_rope(v,i-1,j,k) + 3.*p_rope(v,i,j,k)  )**2
  betaWeno(2) = n13o12*(p_rope(v,i-1,j,k) - 2.*p_rope(v,i,j,k)   +   p_rope(v,i+1,j,k))**2 &
               + 0.25*(p_rope(v,i-1,j,k)             -             p_rope(v,i+1,j,k))**2
  betaWeno(3) = n13o12*(p_rope(v,i,j,k)   - 2.*p_rope(v,i+1,j,k) +   p_rope(v,i+2,j,k))**2 &
               + 0.25*(3.*p_rope(v,i,j,k) - 4.*p_rope(v,i+1,j,k) +  p_rope(v,i+2,j,k))**2
  !!
  !! Use problem-adaptive epsilong as in Tchekovskoy7, A3
  ! This does not seem to work with the WENO-Z indicators of Borges+08
  ! mags(v) = p_rope(@M ind_m(2))**2 + p_rope(@M ind_m(1))**2 + p_rope(@M ind_p(0))**2 &
  !      + p_rope(@M ind_p(1))**2 + p_rope(@M ind_p(2))**2
  ! betaWeno(1) = betaWeno(1) + epsilon*mags(v) + TINY(1.0)
  ! betaWeno(2) = betaWeno(2) + epsilon*mags(v) + TINY(1.0)
  ! betaWeno(3) = betaWeno(3) + epsilon*mags(v) + TINY(1.0)
  !!
  !! This is WENO-Zv this is very similar to weno5 with wenoExp=1
  abs_betadiff = abs(betaWeno(1) - betaWeno(3))
  Alpha5(1:3) = linWp(1:3)*(1. + abs_betadiff/(betaWeno(1:3) + epsilon))
  !!
  !! Normalize nonlinear weights at i+1/2
  invSumAlpha = 1./sum(Alpha5(1:3))
  omega(1:3) = invSumAlpha*Alpha5(1:3)
  !!
  !! Compute interface value at i+1/2
  p_uPlus(v,i,j,k)  = dot_product(omega(1:3), W5p(1:3))
  !! Apply flattening
  p_uPlus(v ,i,j,k) = p_flat(i,j,k)*p_uPlus(v ,i,j,k) + (1.-p_flat(i,j,k))*p_rope(v,i ,j,k)
  !!
  !! Now move on to i-1/2
  !!  
  !! Calculate interface values at i-1/2
  W5m(1) = dot_product(coeff1m1(1:3), p_rope(v,i-2:i+0,j,k))
  W5m(2) = dot_product(coeff1m2(1:3), p_rope(v,i-1:i+1,j,k))
  W5m(3) = dot_product(coeff1m3(1:3), p_rope(v,i-0:i+2,j,k))
  !! This is WENO-Z
  Alpha5(1:3) = linWm(1:3)*(1. + abs_betadiff/(betaWeno(1:3) + epsilon))
  !!
  !! Normalize nonlinear weights at i-1/2
  invSumAlpha = 1./sum(Alpha5(1:3))
  omega(1:3) = invSumAlpha*Alpha5(1:3)
  !!
  !! Compute interface value at i-1/2
  p_uMinus(v,i,j,k) = dot_product(omega(1:3), W5m(1:3))
  !! Apply flattening
  p_uMinus(v ,i,j,k) = p_flat(i,j,k)*p_uMinus(v ,i,j,k) + (1.-p_flat(i,j,k))*p_rope(v, i ,j,k)
  !! Check for monotonicity
  if ( (p_uPlus(v,i,j,k)-p_rope(v,i,j,k))*(p_rope(v,i,j,k)-p_uMinus(v,i,j,k)) <= 0. ) then
     p_uPlus(v,i,j,k)  = p_rope(v,i,j,k)
     p_uMinus(v,i,j,k) = p_rope(v,i,j,k)
  end if


[hy_DIR_riemann_private]
definition=
  !$omp private(v, &
  !$omp    VL, VR, Fstar, inShock, ierr, &
  !$omp    UL, UR, Uhll, UCstarR, UCstarL, FL, FR, &
  !$omp    velNL, velNR, aL2, aR2, &
  !$omp    magNL, magNR, Bn_glm, Psi_glm, magBL2, magBR2, &
  !$omp    cfL, cfR, SL, SR, speed, totalPresL, totalPresR, &
  !$omp    pStar, qStar, numerL, numerR, denomL, denomR, &
  !$omp    dStarL, dStarR, &
  !$omp    u2, E, B2, UB, Ptot )

[hy_DIR_riemann_shared]
definition=
  !$omp shared(tinyZero, hybridRiemann)


[hy_riemann]
definition=
    ! Set no error to begin with
  ierr = 0
  !!
  ! Normal velocity
  velNL = VL(HY_VELX+dir-1)
  velNR = VR(HY_VELX+dir-1)
  !!
  ! Set sound speed
  aL2   = VL(HY_GAMC)*VL(HY_PRES)/VL(HY_DENS)
  aR2   = VR(HY_GAMC)*VR(HY_PRES)/VR(HY_DENS)
  !!
  ! Set zero magnetic quantities by default for hydro
  magNL = 0.
  magNR = 0.
 #ifdef SPARK_GLM /* compute additional MHD waves */
  ! Reset the left and right states for the GLM evolution equations
  ! This yields the exact solution for the fluxes of the 2x2 lienar GLM system
  ! See Mignone & Tzeferacos 2010, sec. 3.2
  Bn_glm  = 0.5*(VL(HY_MAGX+dir-1)+VR(HY_MAGX+dir-1)) - 0.5/C_hyp*(VR(HY_PSIB) - VL(HY_PSIB))
  Psi_glm = 0.5*(VL(HY_PSIB)+VR(HY_PSIB)) - 0.5*C_hyp*(VR(HY_MAGX+dir-1)-VL(HY_MAGX+dir-1))
  magNL = VL(HY_MAGX+dir-1)
  magNR = VR(HY_MAGX+dir-1)
  magBL2= 0.0
  magBR2= 0.0
  do v=HY_MAGX,HY_MAGZ
     magBL2 = magBL2 + VL(v)*VL(v) / VL(HY_DENS)
     magBL2 = magBL2 + VR(v)*VR(v) / VR(HY_DENS)
  end do
 #endif
  !!
  ! Check unphysical negativity and cycle riemann loop if necessary
  if ((VL(HY_DENS) < tinyZero .and. VL(HY_DENS) > 0.) .or. &
      (VR(HY_DENS) < tinyZero .and. VR(HY_DENS) > 0.) .or. &
      (VL(HY_PRES) < tinyZero .and. VL(HY_PRES) > 0.) .or. &
      (VR(HY_PRES) < tinyZero .and. VR(HY_PRES) > 0.)) then
     ! This could be vacuum limit. We return with zero flux.
     Fstar = 0.
     cycle
  elseif (aL2 < 0. .or. aR2 < 0.) then
     ierr = 1
     cycle
  endif
  !!
  cfL = sqrt(aL2)
  cfR = sqrt(aR2)
 #ifdef SPARK_GLM
  cfL = sqrt(0.5*(aL2 + magBL2 + sqrt((aL2 + magBL2 )**2 - 4.*aL2*magNL*magNL/VL(HY_DENS))))
  cfR = sqrt(0.5*(aR2 + magBR2 + sqrt((aR2 + magBR2 )**2 - 4.*aR2*magNR*magNR/VR(HY_DENS))))
 #endif
  !!
  ! Get left/right going fastest wave speeds SL & SR for the left and right states
  ! by S. F. Davis, SIAM J. Sci. Stat, Comput., 9(1988) 445.
  ! Also see Miyoshi, Kusano, JCP, 208 (2005)
  SL = min(velNL - cfL, velNR - cfR)
  SR = max(velNL + cfL, velNR + cfR)
  !!
  ! Output maximum local wave speed for dt calculation
  speed = max(abs(SL),abs(SR))
  !!
  ! Total pressure
  totalPresL = VL(HY_PRES)
  totalPresR = VR(HY_PRES)
 #ifdef SPARK_GLM /* for MHD */
  do v=HY_MAGX,HY_MAGZ
     totalPresL = totalPresL + 0.5*(VL(v)*VL(v))
     totalPresR = totalPresR + 0.5*(VR(v)*VR(v))
  end do
 #endif
  !!
  ! Convert primitive variables to conservative variables
  !!!*** We need to think about whether this shoud be extracted out and done on the whole block
  !! 
  @M hy_prim2con(VL,UL)
  @M hy_prim2con(VR,UR)
  @M hy_prim2flx(dir,VL,FL)
  @M hy_prim2flx(dir,VR,FR)
  !!
  ! Get HLL states for later use
  if (SL > 0.) then
     Uhll = UL
  elseif ((SL <= 0.) .and. (SR >= 0.)) then
     Uhll = (SR*UR - SL*UL - FR + FL)/(SR - SL)
     !! Pretty sure the following is not need for pressure already in momentum
     !! fluxes (done in hy_prim2flx). I.e., fP = 1.0
     !  Uhll(HY_DENS+dir) = Uhll(HY_DENS+dir) + &
     !       (  totalPresL - totalPresR  )/(SR - SL) * (1.0-fP)
  else
     Uhll = UR
  endif
  !!
 #ifdef SPARK_GLM /* for MHD */
  ! Calculate intermediate states --------------
  Bn_hll = Uhll(HY_FMGX+dir-1) !=(SR*magNR-SL*magNL)/(SR-SL)
  BxStar = Uhll(HY_FMGX)       !BxStarL = BxStarR = BxHLL
  ByStar = Uhll(HY_FMGY)       !ByStarL = ByStarR = ByHLL
  BzStar = Uhll(HY_FMGZ)       !BzStarL = BzStarR = BzHLL
 #endif
  !!
  ! (1) Normal velocity component
  ! qStarL = qStarR = qStar
  qStar=(VR(HY_DENS)*velNR*(SR-velNR) &
       - VL(HY_DENS)*velNL*(SL-velNL)  &
       + totalPresL - totalPresR       &
       - magNL**2   + magNR**2)
  ! print*, (VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))
  qStar = qStar/(VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))
  !!
  ! Convenient parameters
  numerL = SL-velNL
  denomL = SL-qStar ! I believe this could be made an inverse to save FLOPS
  numerR = SR-velNR
  denomR = SR-qStar
  !!
  ! (2) Total pressure in the star region
  ! pStarL = pStarR = pStar
  pStar = VL(HY_DENS)*numerL*(qStar-velNL)+totalPresL
 #ifdef SPARK_GLM /* for MHD */
  pStar = pStar - magNL**2 + Bn_hll**2
 #endif
 !!
  ! (3) Density
  dStarL = UL(HY_MASS)*numerL/denomL
  dStarR = UR(HY_MASS)*numerR/denomR
  !!
  ! (4) Conserved variables in the two-state (left & right) star regions
  UCstarL(HY_MASS)   = dStarL
  UCstarL(HY_ENER)   = UL(HY_ENER)*numerL/denomL + &
       ((pStar*qStar - totalPresL*velNL))/denomL
  !!
  UCstarR(HY_MASS)   = dStarR
  UCstarR(HY_ENER)   = UR(HY_ENER)*numerR/denomR + &
       ((pStar*qStar - totalPresR*velNR))/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
  UCstarL(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarL(HY_ENER) = UCstarL(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNL*dot_product(VL(HY_MAGX:HY_MAGZ),  VL(HY_VELX:HY_VELZ)))/denomL
  !!
  UCstarR(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarR(HY_ENER) = UCstarR(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNR*dot_product(VR(HY_MAGX:HY_MAGZ),  VR(HY_VELX:HY_VELZ)))/denomR
 #endif
  !!
  select case (dir)
  case (IAXIS)
     UCstarL(HY_XMOM) = dStarL*qStar
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL
  !!
     UCstarR(HY_XMOM) = dStarR*qStar
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BxStar*ByStar-VL(HY_MAGX)*VL(HY_MAGY))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (BxStar*BzStar-VL(HY_MAGX)*VL(HY_MAGZ))/denomL
  !!
     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BxStar*ByStar-VR(HY_MAGX)*VR(HY_MAGY))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (BxStar*BzStar-VR(HY_MAGX)*VR(HY_MAGZ))/denomR
 #endif
  !!
  case (JAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = dStarL*qStar
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL
  !!
     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = dStarR*qStar
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (ByStar*BxStar-VL(HY_MAGY)*VL(HY_MAGX))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (ByStar*BzStar-VL(HY_MAGY)*VL(HY_MAGZ))/denomL
  !!
     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (ByStar*BxStar-VR(HY_MAGY)*VR(HY_MAGX))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (ByStar*BzStar-VR(HY_MAGY)*VR(HY_MAGZ))/denomR
 #endif
   !!
  case (KAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = dStarL*qStar
  !!
     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = dStarR*qStar
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (BzStar*BxStar-VL(HY_MAGZ)*VL(HY_MAGX))/denomL
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BzStar*ByStar-VL(HY_MAGZ)*VL(HY_MAGY))/denomL
  !!
     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (BzStar*BxStar-VR(HY_MAGZ)*VR(HY_MAGX))/denomR
     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BzStar*ByStar-VR(HY_MAGZ)*VR(HY_MAGY))/denomR
 #endif
  end select
  !!
  !1
  ! End of calculating HLLC intermediate states ---------------------------
  !!
  ! (5) Finally, calculate HLLC fluxes
  if (SL >= 0.) then
     Fstar = FL
  elseif ((SL < 0.).and. (qStar >= 0.)) then
     Fstar = FL + SL*(UCstarL - UL)
  elseif ((qStar <0.) .and. (SR >= 0.)) then
     Fstar = FR + SR*(UCstarR - UR)
  else
     Fstar = FR
  endif
  !!
  !! The following are the HLLE fluxes.
  if (hybridRiemann .AND. inShock) then
     if (SL > 0.) then
        Fstar = FL
     elseif (SR < 0.) then
        Fstar = FR
     else !if ((SL <= 0.) .and. (SR >= 0.)) then
        Fstar = (SR*FL - SL*FR + SR*SL*(UR - UL))/(SR - SL)
     endif
  end if
  !!
 #ifdef SPARK_GLM
  ! The exact fluxes for the 2x2 GLM sub-system
  Fstar(HY_FMGX+dir-1) = Psi_glm
  Fstar(HY_FPSI) = C_hyp*C_hyp*Bn_glm
 #endif

[hy_prim2con]
args=V1,CU
definition=
  CU = 0.0
  !!
  u2 = 0.0
  do v=HY_VELX,HY_VELZ
     u2 = u2 + V1(v)*V1(v)
  end do
  B2 = 0.
 #ifdef SPARK_GLM
  do v=HY_MAGX,HY_MAGZ
     B2 = B2 + V1(v)*V1(v)
  end do
  CU(HY_FMGX:HY_FMGZ) = V1(HY_MAGX:HY_MAGZ)
  CU(HY_FPSI) = V1(HY_PSIB)
 #endif
  !!
  CU(HY_MASS) = V1(HY_DENS)
  CU(HY_XMOM:HY_ZMOM) = V1(HY_DENS)*V1(HY_VELX:HY_VELZ)
  CU(HY_ENER) = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE) + 0.5*B2

[hy_prim2flx]
args=dir,V1,F1
definition=
   F1 = 0.0
   u2 = 0.0
   do v=HY_VELX,HY_VELZ
      u2 = u2 + V1(v)*V1(v)
   end do
   E   = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE)
   Ptot = V1(HY_PRES)
 #ifdef SPARK_GLM
   B2 = dot_product(V1(HY_MAGX:HY_MAGZ),V1(HY_MAGX:HY_MAGZ))
   UB = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_MAGX:HY_MAGZ))
   ! We will NEED to check units. That could be a pain. #MHDbeNatural
   Ptot= Ptot + 0.5*B2
   E   = E + 0.5*B2
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGX)*V1(HY_MAGX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGX)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGX)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX) - V1(HY_MAGX)*UB
      F1(HY_FMGX) = 0.
      F1(HY_FMGY) = V1(HY_VELX)*V1(HY_MAGY)-V1(HY_VELY)*V1(HY_MAGX)
      F1(HY_FMGZ) = V1(HY_VELX)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGY)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGY)*V1(HY_MAGY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGY)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY) - V1(HY_MAGY)*UB
      F1(HY_FMGX) = V1(HY_VELY)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGY)
      F1(HY_FMGY) = 0.
      F1(HY_FMGZ) = V1(HY_VELY)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGZ)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGZ)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGZ)*V1(HY_MAGZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ) - V1(HY_MAGZ)*UB
      F1(HY_FMGX) = V1(HY_VELZ)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGZ)
      F1(HY_FMGY) = V1(HY_VELZ)*V1(HY_MAGY) - V1(HY_VELY)*V1(HY_MAGZ)
      F1(HY_FMGZ) = 0.
   end select
 #else
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ)
   end select
 #endif
  

[hy_dot_product]
args=ind,ind1,ind2,lo,hi, X1, X2, X3
definition=
   X3=0.0
   do ind = lo,hi
      X3=X3+X1(ind,ind1,j,k)*X2(ind,ind2,j,k)
   end do


[hy_geom_flux_correct_X]
definition=
    facM = 1.0; facP = 1.0
    if (geometry /= CARTESIAN) then
       facM = fareaX(i  ,j,k)*dx/cvol(i,j,k)
       facP = fareaX(i+1,j,k)*dx/cvol(i,j,k)
       if (xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if

[hy_geom_flux_correct_Y]
definition=
       facM = 1.0; facP = 1.0    
    if (geometry == SPHERICAL) then
       facM = fareaY(i,j  ,k)*dx/cvol(i,j,k)
       facP = fareaY(i,j+1,k)*dx/cvol(i,j,k)
       if (xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if

[geom_flux_correct_Z]
definition=
       facM = 1.0; facP = 1.0    
    if (geometry /= CARTESIAN) then
       facM = fareaZ(i,j,k  )*dx/cvol(i,j,k)
       facP = fareaZ(i,j,k+1)*dx/cvol(i,j,k)
       if (xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if


[hy_geom_flux_dxdv]
definition=
    facM = 1.0; facP = 1.0
    if (geometry /= CARTESIAN) then
       facM = dx/cvol(i,j,k)
       facP = facM
       if (xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if


[hy_geom_update]
args = U1,V1
definition=
      select case(geometry) ! First, select whether y or z is phi-direction
      case(CYLINDRICAL)
       MOM_PHI = HY_ZMOM
       MOM_PHI_FLUX = HY_ZMOM
       MOM_ZI       = HY_YMOM
       MOM_ZI_FLUX  = HY_YMOM
 #ifdef SPARK_GLM
       MAG_PHI      = HY_MAGZ
 #endif
       alpha = 1.
    case(POLAR)
       MOM_PHI      = HY_YMOM
       MOM_PHI_FLUX = HY_YMOM
       MOM_ZI       = HY_ZMOM
       MOM_ZI_FLUX  = HY_ZMOM
 #ifdef SPARK_GLM
       MAG_PHI      = HY_MAGY
 #endif
       alpha = 1.
    case(SPHERICAL)
       MOM_PHI      = HY_ZMOM
       MOM_PHI_FLUX = HY_ZMOM
       MOM_THT      = HY_YMOM
       MOM_THT_FLUX = HY_YMOM
       dx_sph = (xRight(i)**3 - xLeft(i)**3) / (3.*xCenter(i)**2)
       alpha  = 2.
    end select
    facMx = fareaX(i,j,k)*dx/cvol(i,j,k)
    facPx = fareaX(i+1,j,k)*dx/cvol(i,j,k)
 #if NDIM > 1
    facMy = 1.0
    facPy = 1.0
    if (geometry == SPHERICAL) then
        facMy = fareaY(i,j,k)*dy/cvol(i,j,k)
        facPy = fareaY(i,j+1,k)*dy/cvol(i,j,k)
    end if
 #endif
 #if NDIM == 3
    facMz = fareaZ(i,j,k)*dz/cvol(i,j,k)
    facPz = fareaZ(i,j,k+1)*dz/cvol(i,j,k)
 #endif
    Sgeo = 0.
    !! Calculate geometrical source terms.  See Skinner & Ostriker (2010) eqn 75
    if ((geometry == SPHERICAL) .and. (NDIM > 1)) then
        !! works for 1D spherical as well, but haven't tested 1D spherical MHD, so only including the expression for Hydro. 
        !! volume averaged approximation to 1/r and cotan(\theta)
        !! Using volume averaged terms removes the need for scaling factors, such as dx/dx_sph is no longer need for 1D spherical run.
        invr = (3.0*(xRight(i) + xLeft(i)))/ &
                (2.0*(xRight(i)**2 + xRight(i)*xLeft(i) + xLeft(i)**2))
 #if NDIM > 1
        cotan = (sin(yRight(j)) - sin(yLeft(j)))/ &
            (cos(yLeft(j)) - cos(yRight(j)))
 #endif
        ! r term: (T_{\phi \phi} + T_{\theta \theta})/R
        Sgeo(HY_XMOM) = ((V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELZ_VAR) + V1(PRES_VAR)) + &
                     (V1(DENS_VAR)*V1(VELY_VAR)*V1(VELY_VAR) + V1(PRES_VAR))) * invr
 #if NDIM > 1
        ! theta term: -(T_{R \theta} - Cot(\theta)*T_{\phi \phi})/R
        Sgeo(MOM_THT) = -((V1(DENS_VAR)*V1(VELX_VAR)*V1(VELY_VAR)) - &
                     (V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELZ_VAR) + V1(PRES_VAR))*cotan) * invr
 #endif
 #if NDIM == 3
        ! phi term: -(T_{R \phi} + Cot(\theta)*T_{\theta \phi})/R
        Sgeo(MOM_PHI) = -((V1(DENS_VAR)*V1(VELX_VAR)*V1(VELZ_VAR)) + &
                (V1(DENS_VAR)*V1(VELY_VAR)*V1(VELZ_VAR))*cotan) * invr
 #endif

    else
        !! Use this for 1D spherical and 2D cylindircal case with/without MHD.
        !! Calculate geometrical source terms.  See S&O 75.
        Sgeo(HY_XMOM) = (V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELZ_VAR) + alpha*V1(PRES_VAR)) / xCenter(i)!T phi,phi
        Sgeo(MOM_PHI) =  V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELX_VAR) / xCenter(i)!T phi,r
 #ifdef SPARK_GLM
              ! P* is the total Pressure
              ! This presently does not work for POLAR coordinates
              Sgeo(HY_XMOM) = Sgeo(HY_XMOM) - (V1(MAGZ_VAR)**2 - alpha*V1(MAGP_VAR))/ xCenter(i)
              Sgeo(MOM_PHI) = Sgeo(MOM_PHI) - V1(MAGZ_VAR)*V1(MAGX_VAR) / xCenter(i)
              Sgeo(MAG_PHI) = - (V1(VELZ_VAR)*V1(MAGX_VAR) - V1(MAGZ_VAR)*V1(VELX_VAR)) / xCenter(i) !O phi,r
 #endif
              Sgeo(MOM_PHI) = - Sgeo(MOM_PHI)
              if (geometry == SPHERICAL) then
                 Sgeo(HY_XMOM) = Sgeo(HY_XMOM) + U1(MOM_THT)**2/V1(DENS_VAR) / xCenter(i)
                 Sgeo = Sgeo*dx/dx_sph
              endif
         endif
         if (xCenter(i) < 0.0) then
             facMx = 0.
             facPx = 0.
             if (geometry == SPHERICAL) then
                facMy = 0.
                facPy = 0.
             end if
             facMz = 0.
             facPz = 0.
             Sgeo = 0.
         end if


[hy_gravSources]
args = U1
definition=
    Shy_grv = 0.
 #ifdef GRAVITY
    Shy_grv(HY_XMOM:HY_ZMOM) = U1(HY_MASS)*grav(:,i,j,k)
    Shy_grv(HY_ENER) = dot_product(U1(HY_XMOM:HY_ZMOM),grav(:,i,j,k))
 #endif

[hy_DIR_avisc_private]
definition=
  !$omp private(avisc, VenerLo, VenerHi)

[hy_DIR_avisc_shared]
definition=
  !$omp shared(cvisc)
