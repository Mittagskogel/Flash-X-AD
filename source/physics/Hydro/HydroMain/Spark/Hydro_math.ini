
[hy_addFluxes]
definition=
  if (addFlux_array(stage)) then
     hy_fluxBufX = hy_fluxBufX+weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = hy_fluxBufY+weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = hy_fluxBufZ+weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  else
     hy_fluxBufX = weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = +weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  endif

[hy_calcDivB]
definition=
 #ifdef SPARK_GLM
  @M loop_3d(blkLimits)
           divB = 0.0
 #if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/hy_del(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/hy_del(JAXIS)
 #if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/hy_del(KAXIS)
 #endif
 #endif
           Uin(DIVB_VAR,i,j,k) = divB
   @M loop_end_3d
 #endif




[hy_recon]
definition=
  W5p(1) = coeff1p1(1)*hy_rope(v,i-2,j,k) + coeff1p1(2)*hy_rope(v,i-1,j,k) + coeff1p1(3)*hy_rope(v,i+0,j,k)
  W5p(2) = coeff1p2(1)*hy_rope(v,i-1,j,k) + coeff1p2(2)*hy_rope(v,i+0,j,k)   + coeff1p2(3)*hy_rope(v,i+1,j,k)
  W5p(3) = coeff1p3(1)*hy_rope(v,i+0,j,k)   + coeff1p3(2)*hy_rope(v,i+1,j,k) + coeff1p3(3)*hy_rope(v,i+2,j,k)
  !!  
  !! Calculate interface values at i-1/2
  W5m(1) = coeff1m1(1)*hy_rope(v,i-2,j,k) + coeff1m1(2)*hy_rope(v,i-1,j,k) + coeff1m1(3)*hy_rope(v,i+0,j,k)
  W5m(2) = coeff1m2(1)*hy_rope(v,i-1,j,k) + coeff1m2(2)*hy_rope(v,i+0,j,k)   + coeff1m2(3)*hy_rope(v,i+1,j,k)
  W5m(3) = coeff1m3(1)*hy_rope(v,i+0,j,k)   + coeff1m3(2)*hy_rope(v,i+1,j,k) + coeff1m3(3)*hy_rope(v,i+2,j,k)
  !!
  !! Calculate smoothness indicators at i+1/2
  betaWeno(1) = n13o12*(hy_rope(v,i-2,j,k) - 2.*hy_rope(v,i-1,j,k) +    hy_rope(v,i+0,j,k)  )**2 &
       +            0.25*(hy_rope(v,i-2,j,k) - 4.*hy_rope(v,i-1,j,k) + 3.*hy_rope(v,i,j,k)  )**2
  betaWeno(2) = n13o12*(hy_rope(v,i-1,j,k) - 2.*hy_rope(v,i,j,k)   +    hy_rope(v,i+1,j,k))**2 &
       +            0.25*(hy_rope(v,i-1,j,k)                      -    hy_rope(v,i+1,j,k))**2
  betaWeno(3) = n13o12*(hy_rope(v,i,j,k)   - 2.*hy_rope(v,i+1,j,k) +    hy_rope(v,i+2,j,k))**2 &
       +            0.25*(3.*hy_rope(v,i,j,k)- 4.*hy_rope(v,i+1,j,k) +    hy_rope(v,i+2,j,k))**2
  !!
  !! Use problem-adaptive epsilong as in Tchekovskoy7, A3
  ! This does not seem to work with the WENO-Z indicators of Borges+08
  ! mags(v) = hy_rope(@M ind_m(2))**2 + hy_rope(@M ind_m(1))**2 + hy_rope(@M ind_p(0))**2 &
  !      + hy_rope(@M ind_p(1))**2 + hy_rope(@M ind_p(2))**2
  ! betaWeno(1) = betaWeno(1) + epsilon*mags(v) + TINY(1.0)
  ! betaWeno(2) = betaWeno(2) + epsilon*mags(v) + TINY(1.0)
  ! betaWeno(3) = betaWeno(3) + epsilon*mags(v) + TINY(1.0)
  !!
  !! This is WENO-Zv this is very similar to weno5 with wenoExp=1
  Alpha5(1) = coeff2p(1)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(1)+epsilon)))
  Alpha5(2) = coeff2p(2)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(2)+epsilon)))
  Alpha5(3) = coeff2p(3)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(3)+epsilon)))
  !!
  !! Normalize weights at i+1/2
  invSumAlpha = 1./(Alpha5(1)+Alpha5(2)+Alpha5(3))
  omega(1)  = Alpha5(1)*invSumAlpha
  omega(2)  = Alpha5(2)*invSumAlpha
  omega(3)  = Alpha5(3)*invSumAlpha
  !!
  !! Compute interface value at i+1/2
  hy_uPlus(v ,i,j,k)  = omega(1)*W5p(1) + omega(2)*W5p(2) + omega(3)*W5p(3)
  !! Apply hy_flattening
  hy_uPlus(v ,i,j,k) = hy_flat(i,j,k)*hy_uPlus(v ,i,j,k) + (1.-hy_flat(i,j,k))*hy_rope(v,i ,j,k)
  !!
  !! Now move on to i-1/2
  !! This is WENO-Z
  Alpha5(1) = coeff2m(1)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(1)+epsilon)))
  Alpha5(2) = coeff2m(2)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(2)+epsilon)))
  Alpha5(3) = coeff2m(3)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(3)+epsilon)))
  !!
  !! Normalize weights at i-1/2
  invSumAlpha = 1./(Alpha5(1)+Alpha5(2)+Alpha5(3))
  omega(1)  = Alpha5(1)*invSumAlpha
  omega(2)  = Alpha5(2)*invSumAlpha
  omega(3)  = Alpha5(3)*invSumAlpha
  !!
  !! Compute interface value at i-1/2
  hy_uMinus(v ,i,j,k) = omega(1)*W5m(1) + omega(2)*W5m(2) + omega(3)*W5m(3)
  !! Apply hy_flattening
  hy_uMinus(v ,i,j,k) = hy_flat(i,j,k)*hy_uMinus(v ,i,j,k) + (1.-hy_flat(i,j,k))*hy_rope(v, i ,j,k)
  !! Check for monotonicity
  if ( (hy_uPlus(v ,i,j,k)-hy_rope(v, i ,j,k))*(hy_rope(v, i ,j,k)-hy_uMinus(v ,i,j,k)) <= 0. ) then
     hy_uPlus(v ,i,j,k)  = hy_rope(v, i ,j,k)
     hy_uMinus(v ,i,j,k) = hy_rope(v, i ,j,k)
  end if



[hy_riemann]
definition=
    ! Set no error to begin with
  ierr = 0
  !!
  ! Normal velocity
  velNL = VL(HY_VELX+dir-1)
  velNR = VR(HY_VELX+dir-1)
  !!
  ! Set sound speed
  aL2   = VL(HY_GAMC)*VL(HY_PRES)/VL(HY_DENS)
  aR2   = VR(HY_GAMC)*VR(HY_PRES)/VR(HY_DENS)
  !!
  ! Set zero magnetic quantities by default for hydro
  magNL = 0.
  magNR = 0.
 #ifdef SPARK_GLM /* compute additional MHD waves */
  ! Reset the left and right states for the GLM evolution equations
  ! This yields the exact solution for the fluxes of the 2x2 lienar GLM system
  ! See Mignone & Tzeferacos 2010, sec. 3.2
  Bn_glm  = 0.5*(VL(HY_MAGX+dir-1)+VR(HY_MAGX+dir-1)) - 0.5/hy_C_hyp*(VR(HY_PSIB) - VL(HY_PSIB))
  Psi_glm = 0.5*(VL(HY_PSIB)+VR(HY_PSIB)) - 0.5*hy_C_hyp*(VR(HY_MAGX+dir-1)-VL(HY_MAGX+dir-1))
  magNL = VL(HY_MAGX+dir-1)
  magNR = VR(HY_MAGX+dir-1)
  magBL2= dot_product(VL(HY_MAGX:HY_MAGZ),VL(HY_MAGX:HY_MAGZ))/VL(HY_DENS)
  magBR2= dot_product(VR(HY_MAGX:HY_MAGZ),VR(HY_MAGX:HY_MAGZ))/VR(HY_DENS)
 #endif
  !!
  ! Check unphysical negativity
  if ((VL(HY_DENS) < hy_tiny .and. VL(HY_DENS) > 0.) .or. &
       (VR(HY_DENS) < hy_tiny .and. VR(HY_DENS) > 0.) .or. &
       (VL(HY_PRES) < hy_tiny .and. VL(HY_PRES) > 0.) .or. &
       (VR(HY_PRES) < hy_tiny .and. VR(HY_PRES) > 0.)) then
     ! This could be vacuum limit. We return with zero flux.
     Fstar = 0.
     return
  elseif (aL2 < 0. .or. aR2 < 0.) then
     ierr = 1
     return
  endif
  !!
  cfL = sqrt(aL2)
  cfR = sqrt(aR2)
 #ifdef SPARK_GLM
  cfL = sqrt(0.5*(aL2 + magBL2 + sqrt((aL2 + magBL2 )**2 - 4.*aL2*magNL*magNL/VL(HY_DENS))))
  cfR = sqrt(0.5*(aR2 + magBR2 + sqrt((aR2 + magBR2 )**2 - 4.*aR2*magNR*magNR/VR(HY_DENS))))
 #endif
  !!
  ! Get left/right going fastest wave speeds SL & SR for the left and right states
  ! by S. F. Davis, SIAM J. Sci. Stat, Comput., 9(1988) 445.
  ! Also see Miyoshi, Kusano, JCP, 208 (2005)
  SL = min(velNL - cfL, velNR - cfR)
  SR = max(velNL + cfL, velNR + cfR)
  !!
  ! Output maximum local wave speed for dt calculation
  speed = max(abs(SL),abs(SR))
  !!
  ! Total pressure
  totalPresL = VL(HY_PRES)
  totalPresR = VR(HY_PRES)
 #ifdef SPARK_GLM /* for MHD */
  totalPresL = totalPresL + 0.5*dot_product(VL(HY_MAGX:HY_MAGZ),VL(HY_MAGX:HY_MAGZ))
  totalPresR = totalPresR + 0.5*dot_product(VR(HY_MAGX:HY_MAGZ),VR(HY_MAGX:HY_MAGZ))
 #endif
  !!
  ! Convert primitive variables to conservative variables
  !!!*** We need to think about whether this shoud be extracted out and done on the whole block
  !! 
  @M hy_prim2con(VL,UL)
  @M hy_prim2con(VR,UR)
  @M hy_prim2flx(dir,VL,FL)
  @M hy_prim2flx(dir,VR,FR)
  !!
  ! Get HLL states for later use
  if (SL > 0.) then
     Uhll = UL
  elseif ((SL <= 0.) .and. (SR >= 0.)) then
     Uhll = (SR*UR - SL*UL - FR + FL)/(SR - SL)
     !! Pretty sure the following is not need for pressure already in momentum
     !! fluxes (done in hy_prim2flx). I.e., fP = 1.0
     !  Uhll(HY_DENS+dir) = Uhll(HY_DENS+dir) + &
     !       (  totalPresL - totalPresR  )/(SR - SL) * (1.0-fP)
  else
     Uhll = UR
  endif
  !!
 #ifdef SPARK_GLM /* for MHD */
  ! Calculate intermediate states --------------
  Bn_hll = Uhll(HY_FMGX+dir-1) !=(SR*magNR-SL*magNL)/(SR-SL)
  BxStar = Uhll(HY_FMGX)       !BxStarL = BxStarR = BxHLL
  ByStar = Uhll(HY_FMGY)       !ByStarL = ByStarR = ByHLL
  BzStar = Uhll(HY_FMGZ)       !BzStarL = BzStarR = BzHLL
 #endif
  !!
  ! (1) Normal velocity component
  ! qStarL = qStarR = qStar
  qStar=(VR(HY_DENS)*velNR*(SR-velNR) &
       - VL(HY_DENS)*velNL*(SL-velNL)  &
       + totalPresL - totalPresR       &
       - magNL**2   + magNR**2)
  ! print*, (VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))
  qStar = qStar/(VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))
  !!
  ! Convenient parameters
  numerL = SL-velNL
  denomL = SL-qStar ! I believe this could be made an inverse to save FLOPS
  numerR = SR-velNR
  denomR = SR-qStar
  !!
  ! (2) Total pressure in the star region
  ! pStarL = pStarR = pStar
  pStar = VL(HY_DENS)*numerL*(qStar-velNL)+totalPresL
 #ifdef SPARK_GLM /* for MHD */
  pStar = pStar - magNL**2 + Bn_hll**2
 #endif
 !!
  ! (3) Density
  dStarL = UL(HY_MASS)*numerL/denomL
  dStarR = UR(HY_MASS)*numerR/denomR
  !!
  ! (4) Conserved variables in the two-state (left & right) star regions
  UCstarL(HY_MASS)   = dStarL
  UCstarL(HY_ENER)   = UL(HY_ENER)*numerL/denomL + &
       ((pStar*qStar - totalPresL*velNL))/denomL
  !!
  UCstarR(HY_MASS)   = dStarR
  UCstarR(HY_ENER)   = UR(HY_ENER)*numerR/denomR + &
       ((pStar*qStar - totalPresR*velNR))/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
  UCstarL(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarL(HY_ENER) = UCstarL(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNL*dot_product(VL(HY_MAGX:HY_MAGZ),  VL(HY_VELX:HY_VELZ)))/denomL
  !!
  UCstarR(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarR(HY_ENER) = UCstarR(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNR*dot_product(VR(HY_MAGX:HY_MAGZ),  VR(HY_VELX:HY_VELZ)))/denomR
 #endif
  !!
  select case (dir)
  case (IAXIS)
     UCstarL(HY_XMOM) = dStarL*qStar
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL
  !!
     UCstarR(HY_XMOM) = dStarR*qStar
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BxStar*ByStar-VL(HY_MAGX)*VL(HY_MAGY))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (BxStar*BzStar-VL(HY_MAGX)*VL(HY_MAGZ))/denomL
  !!
     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BxStar*ByStar-VR(HY_MAGX)*VR(HY_MAGY))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (BxStar*BzStar-VR(HY_MAGX)*VR(HY_MAGZ))/denomR
 #endif
  !!
  case (JAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = dStarL*qStar
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL
  !!
     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = dStarR*qStar
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (ByStar*BxStar-VL(HY_MAGY)*VL(HY_MAGX))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (ByStar*BzStar-VL(HY_MAGY)*VL(HY_MAGZ))/denomL
  !!
     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (ByStar*BxStar-VR(HY_MAGY)*VR(HY_MAGX))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (ByStar*BzStar-VR(HY_MAGY)*VR(HY_MAGZ))/denomR
 #endif
   !!
  case (KAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = dStarL*qStar
  !!
     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = dStarR*qStar
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (BzStar*BxStar-VL(HY_MAGZ)*VL(HY_MAGX))/denomL
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BzStar*ByStar-VL(HY_MAGZ)*VL(HY_MAGY))/denomL
  !!
     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (BzStar*BxStar-VR(HY_MAGZ)*VR(HY_MAGX))/denomR
     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BzStar*ByStar-VR(HY_MAGZ)*VR(HY_MAGY))/denomR
 #endif
  end select
  !!
  !1
  ! End of calculating HLLC intermediate states ---------------------------
  !!
  ! (5) Finally, calculate HLLC fluxes
  if (SL >= 0.) then
     Fstar = FL
  elseif ((SL < 0.).and. (qStar >= 0.)) then
     Fstar = FL + SL*(UCstarL - UL)
  elseif ((qStar <0.) .and. (SR >= 0.)) then
     Fstar = FR + SR*(UCstarR - UR)
  else
     Fstar = FR
  endif
  !!
  !! The following are the HLLE fluxes.
  if (hy_hybridRiemann .AND. inShock) then
     if (SL > 0.) then
        Fstar = FL
     elseif (SR < 0.) then
        Fstar = FR
     else !if ((SL <= 0.) .and. (SR >= 0.)) then
        Fstar = (SR*FL - SL*FR + SR*SL*(UR - UL))/(SR - SL)
     endif
  end if
  !!
 #ifdef SPARK_GLM
  ! The exact fluxes for the 2x2 GLM sub-system
  Fstar(HY_FMGX+dir-1) = Psi_glm
  Fstar(HY_FPSI) = hy_C_hyp*hy_C_hyp*Bn_glm
 #endif

[hy_prim2con]
args=V1,CU
definition=
  CU = 0.0
  !!
  u2 = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_VELX:HY_VELZ))
  B2 = 0.
 #ifdef SPARK_GLM
  B2 = dot_product(V1(HY_MAGX:HY_MAGZ),V1(HY_MAGX:HY_MAGZ))
  CU(HY_FMGX:HY_FMGZ) = V1(HY_MAGX:HY_MAGZ)
  CU(HY_FPSI) = V1(HY_PSIB)
 #endif
  !!
  CU(HY_MASS) = V1(HY_DENS)
  CU(HY_XMOM:HY_ZMOM) = V1(HY_DENS)*V1(HY_VELX:HY_VELZ)
  CU(HY_ENER) = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE) + 0.5*B2

[hy_prim2flx]
args=dir,V1,F1
definition=
   F1 = 0.0
   u2 = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_VELX:HY_VELZ))
   E   = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE)
   Ptot = V1(HY_PRES)
 #ifdef SPARK_GLM
   B2 = dot_product(V1(HY_MAGX:HY_MAGZ),V1(HY_MAGX:HY_MAGZ))
   UB = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_MAGX:HY_MAGZ))
   ! We will NEED to check units. That could be a pain. #MHDbeNatural
   Ptot= Ptot + 0.5*B2
   E   = E + 0.5*B2
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGX)*V1(HY_MAGX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGX)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGX)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX) - V1(HY_MAGX)*UB
      F1(HY_FMGX) = 0.
      F1(HY_FMGY) = V1(HY_VELX)*V1(HY_MAGY)-V1(HY_VELY)*V1(HY_MAGX)
      F1(HY_FMGZ) = V1(HY_VELX)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGY)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGY)*V1(HY_MAGY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGY)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY) - V1(HY_MAGY)*UB
      F1(HY_FMGX) = V1(HY_VELY)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGY)
      F1(HY_FMGY) = 0.
      F1(HY_FMGZ) = V1(HY_VELY)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGZ)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGZ)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGZ)*V1(HY_MAGZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ) - V1(HY_MAGZ)*UB
      F1(HY_FMGX) = V1(HY_VELZ)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGZ)
      F1(HY_FMGY) = V1(HY_VELZ)*V1(HY_MAGY) - V1(HY_VELY)*V1(HY_MAGZ)
      F1(HY_FMGZ) = 0.
   end select
 #else
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ)
   end select
 #endif
  

  
