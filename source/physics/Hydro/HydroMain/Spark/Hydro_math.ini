
[hy_addFluxes]
definition=
     @M loop_3d_plus(blkLimits,1,0,0)
        hy_fluxBufX(1:NFLUXES,i,j,k) = hy_weights(stage)*hy_flx(1:NFLUXES,i,j,k) + &
	    wt*hy_fluxBufX(1:NFLUXES,i,j,k)
     @M loop_end_3d
     if (NDIM > 1) then
         @M loop_3d_plus(blkLimits,0,1,0)
          hy_fluxBufY(1:NFLUXES,i,j,k) = hy_weights(stage)*hy_fly(1:NFLUXES,i,j,k) + &
	    wt*hy_fluxBufY(1:NFLUXES,i,j,k)
        @M loop_end_3d
     end if	 
     if (NDIM > 2) then
        @M loop_3d_plus(blkLimits,0,0,1)
          hy_fluxBufZ(1:NFLUXES,i,j,k) = hy_weights(stage)*hy_flz(1:NFLUXES,i,j,k) + &
	    wt*hy_fluxBufZ(1:NFLUXES,i,j,k)
        @M loop_end_3d
     end if


[hy_calcDivB]
definition=
 #ifdef SPARK_GLM
  @M loop_3d(blkLimits)
           divB = 0.0
 #if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/hy_del(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/hy_del(JAXIS)
 #if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/hy_del(KAXIS)
 #endif
 #endif
           Uin(DIVB_VAR,i,j,k) = divB
   @M loop_end_3d
 #endif

[hy_DIR_recon_private]
definition=
  !$omp private(W5p, W5m, betaWeno, Alpha5, omega, invSumAlpha, abs_betadiff)
[hy_DIR_recon_shared]
definition=
  !$omp shared(coeff1p1, coeff1p2, coeff1p3, coeff1m1, coeff1m2, coeff1m3, linWp, linWm)



[hy_DIR_riemann_private]
definition=
  !$omp private(v, &
  !$omp    VL, VR, Fstar, inShock, ierr, &
  !$omp    UL, UR, Uhll, UCstarR, UCstarL, FL, FR, &
  !$omp    velNL, velNR, aL2, aR2, &
  !$omp    magNL, magNR, Bn_glm, Psi_glm, magBL2, magBR2, &
  !$omp    cfL, cfR, SL, SR, speed, totalPresL, totalPresR, &
  !$omp    pStar, qStar, numerL, numerR, denomL, denomR, &
  !$omp    dStarL, dStarR, &
  !$omp    u2, E, B2, UB, Ptot )

[hy_DIR_riemann_shared]
definition=
  !$omp shared(hy_tiny, hy_hybridRiemann)


[hy_prim2con]
args=V1,CU
definition=
  CU = 0.0
  !!
  u2 = 0.0
  do v=HY_VELX,HY_VELZ
     u2 = u2 + V1(v)*V1(v)
  end do
  B2 = 0.
 #ifdef SPARK_GLM
  do v=HY_MAGX,HY_MAGZ
     B2 = B2 + V1(v)*V1(v)
  end do
  CU(HY_FMGX:HY_FMGZ) = V1(HY_MAGX:HY_MAGZ)
  CU(HY_FPSI) = V1(HY_PSIB)
 #endif
  !!
  CU(HY_MASS) = V1(HY_DENS)
  CU(HY_XMOM:HY_ZMOM) = V1(HY_DENS)*V1(HY_VELX:HY_VELZ)
  CU(HY_ENER) = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE) + 0.5*B2

[hy_prim2flx]
args=dir,V1,F1
definition=
   F1 = 0.0
   u2 = 0.0
   do v=HY_VELX,HY_VELZ
      u2 = u2 + V1(v)*V1(v)
   end do
   E   = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE)
   Ptot = V1(HY_PRES)
 #ifdef SPARK_GLM
   B2 = dot_product(V1(HY_MAGX:HY_MAGZ),V1(HY_MAGX:HY_MAGZ))
   UB = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_MAGX:HY_MAGZ))
   ! We will NEED to check units. That could be a pain. #MHDbeNatural
   Ptot= Ptot + 0.5*B2
   E   = E + 0.5*B2
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGX)*V1(HY_MAGX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGX)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGX)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX) - V1(HY_MAGX)*UB
      F1(HY_FMGX) = 0.
      F1(HY_FMGY) = V1(HY_VELX)*V1(HY_MAGY)-V1(HY_VELY)*V1(HY_MAGX)
      F1(HY_FMGZ) = V1(HY_VELX)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGY)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGY)*V1(HY_MAGY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGY)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY) - V1(HY_MAGY)*UB
      F1(HY_FMGX) = V1(HY_VELY)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGY)
      F1(HY_FMGY) = 0.
      F1(HY_FMGZ) = V1(HY_VELY)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGZ)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGZ)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGZ)*V1(HY_MAGZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ) - V1(HY_MAGZ)*UB
      F1(HY_FMGX) = V1(HY_VELZ)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGZ)
      F1(HY_FMGY) = V1(HY_VELZ)*V1(HY_MAGY) - V1(HY_VELY)*V1(HY_MAGZ)
      F1(HY_FMGZ) = 0.
   end select
 #else
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ)
   end select
 #endif
  

[hy_dot_product]
args=ind,ind1,ind2,lo,hi, X1, X2, X3
definition=
   X3=0.0
   do ind = lo,hi
      X3=X3+X1(ind,ind1,j,k)*X2(ind,ind2,j,k)
   end do


[hy_geom_flux_correct_X]
definition=
       facM = 1.0; facP = 1.0    
    if (hy_geometry /= CARTESIAN) then
       facM = hy_fareaX(i  ,j,k)*dx/hy_cvol(i,j,k)
       facP = hy_fareaX(i+1,j,k)*dx/hy_cvol(i,j,k)
       if (hy_xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if

[hy_geom_flux_correct_Y]
definition=
       facM = 1.0; facP = 1.0    
    if (hy_geometry == SPHERICAL) then
       facM = hy_fareaY(i,j  ,k)*dx/hy_cvol(i,j,k)
       facP = hy_fareaY(i,j+1,k)*dx/hy_cvol(i,j,k)
       if (hy_xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if

[hy_geom_flux_correct_Z]
definition=
       facM = 1.0; facP = 1.0    
    if (hy_geometry /= CARTESIAN) then
       facM = hy_fareaZ(i,j,k  )*dx/hy_cvol(i,j,k)
       facP = hy_fareaZ(i,j,k+1)*dx/hy_cvol(i,j,k)
       if (hy_xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if


[hy_geom_flux_dxdv]
definition=
       facM = 1.0; facP = 1.0
    if (hy_geometry /= CARTESIAN) then
       facM = dx/hy_cvol(i,j,k)
       facP = facM
       if (hy_xCenter(i) < 0.0) then
          facM = 0.
          facP = 0.
       end if
    end if


[hy_geom_update]
args = U1,V1
definition=
      select case(hy_geometry) ! First, select whether y or z is phi-direction
      case(CYLINDRICAL)
       MOM_PHI = HY_ZMOM
       MOM_PHI_FLUX = HY_ZMOM
       MOM_ZI       = HY_YMOM
       MOM_ZI_FLUX  = HY_YMOM
 #ifdef SPARK_GLM
       MAG_PHI      = HY_MAGZ
 #endif
       alpha = 1.
    case(POLAR)
       MOM_PHI      = HY_YMOM
       MOM_PHI_FLUX = HY_YMOM
       MOM_ZI       = HY_ZMOM
       MOM_ZI_FLUX  = HY_ZMOM
 #ifdef SPARK_GLM
       MAG_PHI      = HY_MAGY
 #endif
       alpha = 1.
    case(SPHERICAL)
       MOM_PHI      = HY_ZMOM
       MOM_PHI_FLUX = HY_ZMOM
       MOM_THT      = HY_YMOM
       MOM_THT_FLUX = HY_YMOM
       ! dx_sph = (hy_xRight(i)**3 - hy_xLeft(i)**3) / (3.*hy_xCenter(i)**2)
       alpha  = 2.
    end select
    facMx = hy_fareaX(i,j,k)*dx/hy_cvol(i,j,k)
    facPx = hy_fareaX(i+1,j,k)*dx/hy_cvol(i,j,k)
 #if NDIM > 1
    facMy = 1.0
    facPy = 1.0
    if (hy_geometry == SPHERICAL) then
        facMy = hy_fareaY(i,j,k)*dy/hy_cvol(i,j,k)
        facPy = hy_fareaY(i,j+1,k)*dy/hy_cvol(i,j,k)
    end if
 #endif
 #if NDIM == 3
    facMz = hy_fareaZ(i,j,k)*dz/hy_cvol(i,j,k)
    facPz = hy_fareaZ(i,j,k+1)*dz/hy_cvol(i,j,k)
 #endif
    Sgeo = 0.
         !! Calculate geometrical source terms.  See Skinner & Ostriker (2010) eqn 75
    if ((hy_geometry == SPHERICAL) .and. (NDIM > 1)) then
        !! works for 1D spherical as well, but have not tested 1D spherical MHD, so only including the expression for Hydro. - Sudarshan
        !! volume averaged approximation to 1/r and cotan(\theta)
        !! Using volume averaged terms removes the need for scaling factors, such as dx/dx_sph is no longer needed for 1D spherical run.
        invr = (3.0*(hy_xRight(i) + hy_xLeft(i)))/ &
                (2.0*(hy_xRight(i)**2 + hy_xRight(i)*hy_xLeft(i) + hy_xLeft(i)**2))
 #if NDIM > 1
        cotan = (sin(hy_yRight(j)) - sin(hy_yLeft(j)))/ &
            (cos(hy_yLeft(j)) - cos(hy_yRight(j)))
 #endif
        ! r term: (T_{\phi \phi} + T_{\theta \theta})/R
        Sgeo(HY_XMOM) = ((V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELZ_VAR) + V1(PRES_VAR)) + &
                     (V1(DENS_VAR)*V1(VELY_VAR)*V1(VELY_VAR) + V1(PRES_VAR))) * invr
 #if NDIM > 1
        ! theta term: -(T_{R \theta} - Cot(\theta)*T_{\phi \phi})/R
        Sgeo(MOM_THT) = -((V1(DENS_VAR)*V1(VELX_VAR)*V1(VELY_VAR)) - &
                     (V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELZ_VAR) + V1(PRES_VAR))*cotan) * invr
 #endif
 #if NDIM == 3
        ! phi term: -(T_{R \phi} + Cot(\theta)*T_{\theta \phi})/R
        Sgeo(MOM_PHI) = -((V1(DENS_VAR)*V1(VELX_VAR)*V1(VELZ_VAR)) + &
                (V1(DENS_VAR)*V1(VELY_VAR)*V1(VELZ_VAR))*cotan) * invr
 #endif

    else
        !! Use this for 1D spherical and 2D cylindrical case with/without MHD.
        !! Calculate geometrical source terms.  See S&O 75.
        Sgeo(HY_XMOM) = (V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELZ_VAR) + alpha*V1(PRES_VAR)) / hy_xCenter(i)!T phi,phi
        Sgeo(MOM_PHI) =  V1(DENS_VAR)*V1(VELZ_VAR)*V1(VELX_VAR) / hy_xCenter(i)!T phi,r
 #ifdef SPARK_GLM
              ! P* is the total Pressure
              ! This presently does not work for POLAR coordinates
              Sgeo(HY_XMOM) = Sgeo(HY_XMOM) - (V1(MAGZ_VAR)**2 - alpha*V1(MAGP_VAR))/ hy_xCenter(i)
              Sgeo(MOM_PHI) = Sgeo(MOM_PHI) - V1(MAGZ_VAR)*V1(MAGX_VAR) / hy_xCenter(i)
              Sgeo(MAG_PHI) = - (V1(VELZ_VAR)*V1(MAGX_VAR) - V1(MAGZ_VAR)*V1(VELX_VAR)) / hy_xCenter(i) !O phi,r
 #endif
              Sgeo(MOM_PHI) = - Sgeo(MOM_PHI)
              if (hy_geometry == SPHERICAL) then
                 Sgeo(HY_XMOM) = Sgeo(HY_XMOM) + U1(MOM_THT)**2/V1(DENS_VAR) / hy_xCenter(i)
                 ! Sgeo = Sgeo*dx/dx_sph
                 Sgeo = Sgeo*dx * (3.*hy_xCenter(i)**2) / (hy_xRight(i)**3 - hy_xLeft(i)**3)
              endif
         endif
         if (hy_xCenter(i) < 0.0) then
             facMx = 0.
             facPx = 0.
             if (hy_geometry == SPHERICAL) then
                facMy = 0.
                facPy = 0.
             end if
             facMz = 0.
             facPz = 0.
             Sgeo = 0.
         end if


[hy_gravSources]
definition=
    Shy_grv = 0.
 #ifdef GRAVITY
    Shy_grv(HY_XMOM:HY_ZMOM) = Ustar(HY_MASS)*hy_grav(:,i,j,k)
    Shy_grv(HY_ENER) = dot_product(Ustar(HY_XMOM:HY_ZMOM),hy_grav(:,i,j,k))
 #endif

[hy_DIR_avisc_private]
definition=
  !$omp private(cvisc, VenerLo, VenerHi, im1)

[hy_DIR_avisc_shared]
definition=
  !$omp shared(hy_cvisc)
