!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!> @ingroup HydroSpark
!!
!! @brief Get gravitational acceleration
!!
!! @details
!! Get gravitational acceleration for the part of block/tile defined by @p limits
!! where blkLimitsGC define full block
!!
!! @param hy_starState  Pointer to input solution data
!! @param hy_del        dx, dy, dz
!! @param limits        sets limits of the fluxes.
!! @param blkLimitsGC   Index limits for exterior of the tile
!<
!!Reorder(4):hy_starState
!!NOVARIANTS
subroutine hy_rk_getGraveAccel(hy_starState, hy_del,limits,blkLimitsGC)
  ! *** This has not been tested with OMP offloading *** !
  use Hydro_data, ONLY : hy_threadWithinBlock, hya_grav, hya_xCenter, hya_yCenter, hy_geometry
  use Driver_interface, ONLY : Driver_abort
  implicit none

#include "Simulation.h"
#include "constants.h"

  real,dimension(:,:,:,:),pointer :: hy_starState  
  real,dimension(MDIM),intent(IN)  :: hy_del
  integer,dimension(LOW:HIGH,MDIM), intent(IN) :: limits, blkLimitsGC
  real,dimension(:,:,:,:),pointer :: hy_grav
  real,dimension(:),pointer :: radCenter, thtCenter

  real, dimension(MDIM) :: delinv, delgpot
  real :: delxinv
  integer :: i,j,k,d

  hy_grav(1:MDIM,&
       blkLimitsGC(LOW,IAXIS):blkLimitsGC(HIGH,IAXIS),&
       blkLimitsGC(LOW,JAXIS):blkLimitsGC(HIGH,JAXIS),&
       blkLimitsGC(LOW,KAXIS):blkLimitsGC(HIGH,KAXIS))=>hya_grav
  @M hy_DIR_TARGET_enter_data(alloc, [hy_grav])

  @M hy_DIR_parallel_loop(4) &
  @M hy_DIR_TARGET_map(to, [blkLimitsGC]) &
  @M hy_DIR_shared([blkLimitsGC, hy_grav])
  do k = blkLimitsGC(LOW,KAXIS),blkLimitsGC(HIGH,KAXIS)
    do j = blkLimitsGC(LOW,JAXIS),blkLimitsGC(HIGH,JAXIS)
      do i = blkLimitsGC(LOW,IAXIS),blkLimitsGC(HIGH,IAXIS)
        do d = 1,MDIM
          hy_grav(d,i,j,k) = 0.0
        enddo
      enddo
    enddo
  enddo

#ifdef GRAVITY
  ! For time-dependent gravity, we call the local acceleration routine
  ! since the GPOT will be extrapolated forward in time for the RK
  ! sub-stages.
#ifdef FLASH_GRAVITY_TIMEDEP
#ifdef GPOT_VAR
  if(hy_geometry /= CARTESIAN) then
     radCenter(blkLimitsGC(LOW,IAXIS):blkLimitsGC(HIGH,IAXIS)) => hya_xCenter 
     thtCenter(blkLimitsGC(LOW,JAXIS):blkLimitsGC(HIGH,JAXIS)) => hya_yCenter
     @M hy_DIR_TARGET_enter_data(to, [radCenter, thtCenter])
  end if

  @M hy_DIR_parallel_loop_simd(3) &
  @M hy_DIR_TARGET_map(to, [limits, hy_del]) &
  @M hy_DIR_private([delinv, delgpot]) &
  @M hy_DIR_shared([limits, hy_grav, hy_del, hy_starState, radCenter, thtCenter, hy_geometry])
  do k=limits(LOW,KAXIS),limits(HIGH,KAXIS)
     do j=limits(LOW,JAXIS),limits(HIGH,JAXIS)
        do i=limits(LOW,IAXIS),limits(HIGH,IAXIS)

           delinv(IAXIS:NDIM) = 0.5 / hy_del(IAXIS:NDIM)

           ! d/dx
           delgpot(IAXIS) = hy_starState(GPOT_VAR,i-1,j,k) - hy_starState(GPOT_VAR,i+1,j,k)
           hy_grav(IAXIS,i,j,k) = delinv(IAXIS) * delgpot(IAXIS)
#if NDIM >= 2
           ! d/dy
           if (hy_geometry == SPHERICAL) delinv(JAXIS) = delinv(JAXIS) / radCenter(i)
           delgpot(JAXIS) = hy_starState(GPOT_VAR,i,j-1,k) - hy_starState(GPOT_VAR,i,j+1,k)
           hy_grav(JAXIS,i,j,k) = delinv(JAXIS) * delgpot(JAXIS)
#endif
#if NDIM == 3
           ! d/dz
           if (hy_geometry == SPHERICAL) then
              delinv(KAXIS) = delinv(KAXIS) / ( radCenter(i) * sin(thtCenter(j)) )
           else if (hy_geometry == CYLINDRICAL) then
              delinv(KAXIS) = delinv(KAXIS) / radCenter(i)
           end if
           delgpot(KAXIS) = hy_starState(GPOT_VAR,i,j,k-1) - hy_starState(GPOT_VAR,i,j,k+1)
           hy_grav(KAXIS,i,j,k) = delinv(KAXIS) * delgpot(KAXIS)
#endif
        end do
     end do
  end do

  if(hy_geometry /= CARTESIAN) then
     @M hy_DIR_TARGET_exit_data(release, [radCenter, thtCenter])
     nullify(radCenter)
     nullify(thtCenter)
  end if
#endif /* GPOT_VAR */
#else
  call Driver_abort("[hy_rk_getGraveAccel] Gravity that is not FLASH_GRAVITY_TIMEDEP is not currently implemented ")
#endif /* FLASH_GRAVITY_TIMEDEP */
#endif /* GRAVITY */

  @M hy_DIR_TARGET_exit_data(from, [hy_grav])
  nullify(hy_grav)

end subroutine hy_rk_getGraveAccel
