!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!> @ingroup HydroSpark
!!
!! @brief Get gravitational acceleration
!!
!! @details
!! Get gravitational acceleration for the part of block/tile @p blkLimitsGC +/- 1
!! where blkLimitsGC define full block
!!
!! @param starState     Pointer to input solution data
!! @param grav          Pointer to output gravity acceleration
!! @param radCenter     Pointer to radius centers coords for non-cartesian grid
!! @param thtCenter     Pointer to theta centers coords for non-cartesian grid
!! @param deltas        dx, dy, dz
!! @param geometry      Geometry switch
!! @param blkLimitsGC   Index limits for exterior of the tile
!<
!!Reorder(4):starState
!!NOVARIANTS
subroutine hy_rk_getGraveAccel(starState, grav, radCenter, thtCenter, deltas, geometry, blkLimitsGC)
  ! *** This has not been tested with OMP offloading *** !
!!  use Gravity_interface, ONLY : Gravity_accelOneRow
  use Hydro_data, ONLY : hy_threadWithinBlock
  use Driver_interface, ONLY : Driver_abort
  implicit none

#include "Simulation.h"
#include "constants.h"

  real, dimension(:,:,:,:), pointer :: starState
  real, dimension(:,:,:,:), pointer :: grav
  real, dimension(:), pointer :: radCenter, thtCenter
  real, dimension(MDIM), intent(IN)  :: deltas
  integer, intent(IN) :: geometry
  integer, dimension(LOW:HIGH,MDIM), intent(IN) :: blkLimitsGC

  real :: delxinv
  integer :: dir, i,j,k,d
  integer :: im, ip, jm, jp, km, kp

  logical :: offload = .false.

#ifdef OMP_OL
  offload = .true.
#endif

  @M hy_DIR_parallel_loop(4) &
  @M hy_DIR_TARGET_map(to, [blkLimitsGC]) &
  @M hy_DIR_shared([blkLimitsGC, grav]) &
  @M hy_DIR_end
  do k = blkLimitsGC(LOW,KAXIS),blkLimitsGC(HIGH,KAXIS)
    do j = blkLimitsGC(LOW,JAXIS),blkLimitsGC(HIGH,JAXIS)
      do i = blkLimitsGC(LOW,IAXIS),blkLimitsGC(HIGH,IAXIS)
        do d = 1,MDIM
          grav(d,i,j,k) = 0.0
        enddo
      enddo
    enddo
  enddo

#ifdef GRAVITY
  ! For time-dependent gravity, we call the local acceleration routine
  ! since the GPOT will be extrapolated forward in time for the RK
  ! sub-stages.
#ifdef FLASH_GRAVITY_TIMEDEP
#ifdef GPOT_VAR

  @M hy_DIR_parallel_loop_simd(3) &
  @M hy_DIR_TARGET_map(to, [deltas]) &
  @M hy_DIR_shared([blkLimitsGC, grav, deltas, starState, radCenter, thtCenter, geometry]) &
  @M hy_DIR_private([d, delxinv, im, ip, jm, jp, km, kp])
  do k=blkLimitsGC(LOW,KAXIS)+K3D, blkLimitsGC(HIGH,KAXIS)-K3D
    do j=blkLimitsGC(LOW,JAXIS)+K2D, blkLimitsGC(HIGH,JAXIS)-K2D
      do i=blkLimitsGC(LOW,IAXIS)+K1D, blkLimitsGC(HIGH,IAXIS)-K1D
        do d=1,NDIM
          select case(d)
          case(IAXIS)
            im=1; ip=1; jm=0; jp=0; km=0; kp=0
          case(JAXIS)
            im=0; ip=0; jm=1; jp=1; km=0; kp=0
          case(KAXIS)
            im=0; ip=0; jm=0; jp=0; km=1; kp=1
          end select
          delxinv = getDelXinv(d, deltas, geometry, radCenter(i), thtCenter(j))
          grav(d,i,j,k) = grav(d,i,j,k) &
             + delxinv*( starState(GPOT_VAR,i-im,j-jm,k-km) &
                        - starState(GPOT_VAR,i+ip,j+jp,k+kp) )
        end do
      enddo
    enddo
  enddo
#endif /* GPOT_VAR */
#else
  call Driver_abort("[hy_rk_getGraveAccel] Gravity that is not FLASH_GRAVITY_TIMEDEP is not currently implemented ")
#endif /* FLASH_GRAVITY_TIMEDEP */
#endif /* GRAVITY */


contains

  pure function getDelXinv(sweepDir, del, geom, radx, thty) result(dxinv)

    implicit none

    integer, intent(IN) :: sweepDir, geom
    real, dimension(MDIM), intent(IN) :: del
    real, intent(IN) :: radx, thty

    real :: dxinv

#ifdef OMP_OL
    !$omp declare target
#endif

    if (sweepDir == SWEEP_X) then                     ! x-direction
       dxinv = 1./del(IAXIS)
    elseif (sweepDir == SWEEP_Y) then                 ! y-direction
       dxinv = 1./del(JAXIS)
       if (geom == SPHERICAL) dxinv = dxinv / radx
    else                                              ! z-direction
       dxinv = 1./del(KAXIS)
       if (geom == SPHERICAL) then
          dxinv = dxinv / ( radx * sin(thty) )
       else if (geom == CYLINDRICAL) then
          dxinv = dxinv / radx
       endif
    endif

    dxinv = 0.5e0 * dxinv
    return
  end function getDelXinv


end subroutine hy_rk_getGraveAccel
