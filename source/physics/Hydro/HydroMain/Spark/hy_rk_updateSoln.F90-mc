!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!> @ingroup HydroSpark
!!
!! @brief Update solution then save it in primitive form
!!
!! @details
!! Update solution data based on conservative fluxes
!! calculated previously in @p hy_rk_getFaceFlux().
!! Then convert conservative to primitive variables.
!! Note that this only updates the part of tile/block within @p limits
!!
!! @param starState    Pointer to input/output solution data
!! @param tmpState     Pointer to input solution data at n-step
!! @param rk_coeffs    RK coefficients in Butcher tableau
!! @param grav         Pointer to gravity acceleration
!! @param flx,fly,flz  Pointer to fluxes
!! @param deltas       dx, dy, dz
!! @param farea        Pointer to face areas for non-cartesian grid
!! @param cvol         Pointer to cell volumes for non-cartesian grid
!! @param xCenter      Pointer to cell center coordinates of IAXIS for non-cartesian grid
!! @param xLeft        Pointer to cell's left coordinates of IAXIS for non-cartesian grid
!! @param xRight       Pointer to cell's right coordinates of IAXIS for non-cartesian grid
!! @param geometry     Geometry switch
!! @param smalle       Energy cutoff value
!! @param smalld       Density cutoff value
!! @param alphaGLM     Alpha value for GLM; Only used for GLM
!! @param C_hyp        Global maximum hyperbolic speed; Only used for GLM
!! @param dt           Timestep
!! @param dtOld        Old timestep
!! @param limits       Index limits for updating solution.
!<
!!Reorder(4): starState, tmpState, fl[xyz]
!!NOVARIANTS

subroutine hy_rk_updateSoln (starState, tmpState, rk_coeffs, stage, &
                             grav, flx, fly, flz, &
                             deltas, fareaX, fareaY, fareaZ, cvol, xCenter, &
                             xLeft, xRight, yLeft, yRight, &
                             geometry, &
                             smalle, smalld, alphaGLM, C_hyp, &
                             dt, dtOld, limits)

  use Hydro_data, ONLY : hy_threadWithinBlock
  use Driver_interface, ONLY : Driver_abort

  implicit none

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

  real, dimension(:,:,:,:), pointer :: starState, tmpState, flx, fly, flz
  real, dimension(:,:,:,:), pointer :: grav
  real, dimension(:,:,:), pointer :: fareaX, fareaY, fareaZ, cvol
  real, dimension(:), pointer :: xCenter, xLeft, xRight, yLeft, yRight
  real, dimension(3, 3), intent(IN) :: rk_coeffs
  real, dimension(MDIM), intent(IN)  :: deltas
  integer, intent(IN) :: stage, geometry
  integer, intent(IN), dimension(LOW:HIGH,MDIM) :: limits
  real, intent(IN) :: smalle, smalld, alphaGLM, C_hyp, dt, dtOld

  integer :: i, j, k, n, g

  real, dimension(NUNK_VARS) :: Vstar, V0
  real, dimension(NFLUXES) :: U0, Ustar

  real :: dx, dy, dz
  real :: ekin, emag
  ! Geometry factors
  real :: facMx, facPx, facMy, facPy, facMz, facPz
  real, dimension(NFLUXES) :: Sgeo, Shy_grv, Stot
  real :: dhdt

  !! temporaries to be used in computing geometric factors
  real    :: presStar, densStar, pmomStar, tmomStar, xmomStar
  real    :: pmagStar, xmagStar, zmagStar
  integer :: VEL_PHI, MOM_PHI, MOM_PHI_FLUX, MAG_PHI, MAG_PHI_FLUX
  integer :: VEL_ZI, MOM_ZI, MOM_ZI_FLUX, MAG_ZI, MAG_ZI_FLUX
  integer :: VEL_THT, MOM_THT, MOM_THT_FLUX
  real    :: alpha
  real    :: invr, cotan

  logical :: offload = .false.

#ifdef OMP_OL
  offload = .true.
#endif

  dx = deltas(IAXIS); dy = deltas(JAXIS); dz = deltas(KAXIS)
  dhdt = minval(deltas(1:NDIM))/(rk_coeffs(stage, 3)*dt)

  @M hy_DIR_parallel_loop(3) &
  @M hy_DIR_TARGET_map(to, [limits, rk_coeffs]) &
  @M hy_DIR_shared([limits, starState, tmpState, grav, flx, fly, flz]) &
  @M hy_DIR_shared([stage, rk_coeffs, fareaX, fareaY, fareaZ, cvol, smalld, smalle]) &
  @M hy_DIR_shared([geometry, xLeft, xCenter, xRight, yLeft, yRight, dx, dy, dz, dt, dtOld]) &
  @M hy_DIR_private([V0, Vstar, U0, Ustar, Shy_grv, Stot, Sgeo, ekin, emag]) &
  @M hy_DIR_private([MOM_PHI, MOM_PHI_FLUX, MOM_THT, MOM_THT_FLUX, MOM_ZI, MOM_ZI_FLUX]) &
  @M hy_DIR_private([alpha, facMx, facPx, facMy, facPy, facMz, facPz, invr, cotan])
  do k = limits(LOW,KAXIS), limits(HIGH,KAXIS)
     do j = limits(LOW,JAXIS), limits(HIGH,JAXIS)
        do i = limits(LOW,IAXIS), limits(HIGH,IAXIS)
           V0(1:NUNK_VARS) = tmpState(1:NUNK_VARS, i, j, k)
           Vstar(1:NUNK_VARS) = starState(1:NUNK_VARS, i, j, k)
           U0(HY_MASS)            = V0(DENS_VAR)
           U0(HY_XMOM:HY_ZMOM)    = V0(DENS_VAR)*V0(VELX_VAR:VELZ_VAR)
           U0(HY_ENER)            = V0(DENS_VAR)*V0(ENER_VAR)
           U0(HY_NUM_FLUX+1:NFLUXES) = V0(SPECIES_BEGIN:MASS_SCALARS_END)*V0(DENS_VAR)
           Ustar(HY_MASS)         = Vstar(DENS_VAR)
           Ustar(HY_XMOM:HY_ZMOM) = Vstar(DENS_VAR)*Vstar(VELX_VAR:VELZ_VAR)
           Ustar(HY_ENER)         = Vstar(DENS_VAR)*Vstar(ENER_VAR)
           Ustar(HY_NUM_FLUX+1:NFLUXES) = Vstar(SPECIES_BEGIN:MASS_SCALARS_END)*Vstar(DENS_VAR)
#ifdef SPARK_GLM
           U0(HY_FMGX:HY_FMGZ)    = V0(MAGX_VAR:MAGZ_VAR)
           U0(HY_ENER) = U0(HY_ENER)+0.5*dot_product(V0(MAGX_VAR:MAGZ_VAR),&
                V0(MAGX_VAR:MAGZ_VAR))
           U0(HY_FPSI) = V0(PSIB_VAR)
           Ustar(HY_FMGX:HY_FMGZ) = Vstar(MAGX_VAR:MAGZ_VAR)
           Ustar(HY_ENER) = Ustar(HY_ENER)+0.5*dot_product(Vstar(MAGX_VAR:MAGZ_VAR),&
                Vstar(MAGX_VAR:MAGZ_VAR))
           Ustar(HY_FPSI) = Vstar(PSIB_VAR)
#endif
           facMx = 1.0; facPx = 1.0; Sgeo = 0.0
           facMy = 1.0; facPy = 1.0;
           facMz = 1.0; facPz = 1.0;
           ! Get geometric factors and sources
           ! Get gravitational source terms
           if(geometry /= CARTESIAN) then
              @M hy_geom_update(Ustar, Vstar)
           end if
           @M hy_gravSources(Ustar)

           ! Sum total source terms
           Stot = Sgeo + Shy_grv

           ! Now update conserved vector with flux gradients
           Ustar = rk_coeffs(stage, 1)*U0 + rk_coeffs(stage, 2)*Ustar + rk_coeffs(stage, 3)*( &
                -dt/dx*(facPx*flx(:, i+1, j, k) - facMx*flx(:, i, j, k)) &
#if NDIM > 1
                -dt/dy*(facPy*fly(:, i, j+1, k) - facMy*fly(:, i, j, k)) &
#if NDIM ==3
                -dt/dz*(facPz*flz(:, i, j, k+1) - facMz*flz(:, i, j, k)) &
#endif
#endif
                +dt*Stot)

           ! Update primitive variables
           emag = 0.0
#ifdef SPARK_GLM
           Vstar(MAGX_VAR:MAGZ_VAR) = Ustar(HY_FMGX:HY_FMGZ)
           Vstar(PSIB_VAR) = Ustar(HY_FPSI)*exp(-alphaGLM*C_hyp/dhdt)
           emag = 0.5*dot_product(Vstar(MAGX_VAR:MAGZ_VAR),Vstar(MAGX_VAR:MAGZ_VAR))
           Vstar(MAGP_VAR) = emag
           Ustar(HY_ENER) = Ustar(HY_ENER) - emag
#endif
           Vstar(DENS_VAR)          = max(Ustar(HY_MASS),smalld)
           Vstar(VELX_VAR:VELZ_VAR) = Ustar(HY_XMOM:HY_ZMOM)/Vstar(DENS_VAR)
           Vstar(ENER_VAR)          = max(smalle,Ustar(HY_ENER)/Vstar(DENS_VAR))

           ekin = .5*dot_product(Vstar(VELX_VAR:VELZ_VAR),Vstar(VELX_VAR:VELZ_VAR))
           Vstar(EINT_VAR) = max(smalle,Vstar(ENER_VAR)-ekin)

           ! Divide partial densities by new mass densities to finalize
           ! update of new mass fractions.
           Vstar(SPECIES_BEGIN:MASS_SCALARS_END) = Ustar(HY_NUM_FLUX+1:NFLUXES)/Vstar(DENS_VAR)
#ifdef GPOT_VAR
           ! Now extrapolate gravity to intermediate time state
           ! the star state GPOT_VAR will be reset so that GPOL_VAR isn't screwed up
           Vstar(GPOT_VAR) = rk_coeffs(stage, 1)*V0(GPOT_VAR) + rk_coeffs(stage, 2)*Vstar(GPOT_VAR) &
                + rk_coeffs(stage, 3)*dt*(V0(GPOT_VAR) - V0(GPOL_VAR))/dtOld
#endif
           ! save the solution in primitive form
           starState(1:NUNK_VARS, i, j, k) = Vstar(1:NUNK_VARS)
        enddo !i
     enddo !j
  enddo !k

end subroutine hy_rk_updateSoln
