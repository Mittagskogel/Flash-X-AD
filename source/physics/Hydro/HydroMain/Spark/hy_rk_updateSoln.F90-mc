!!****if* source/physics/Hydro/HydroMain/Spark/hy_rk_updateSoln
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!!  NAME
!!
!!  hy_rk_updateSoln
!!
!!  SYNOPSIS
!!
!!  call hy_rk_updateSoln ( real, pointer :: Uin(:,:,:,:),
!!                            integer (IN)  :: blkLimits(:,:),
!!                            integer (IN)  :: blkLimitsGC(:,:),
!!                            integer (IN)  :: level,
!!                            real (IN)     :: hy_del(:),
!!                            real (IN)     :: dt,
!!                            real (IN)     :: dtOld,)
!!                            real (IN)     :: hy_coeffs(:))
!!     
!!  DESCRIPTION
!!  Update solution based on conservative fluxes previously calculated.  Then convert
!!  conservative to primitive variables.
!!
!!  ARGUMENTS
!!    Uin -- pointer to solution data
!!    blkLimits, blkLimitsGC -- index limits for interior and exterior of the tile
!!    level  -- the refine level of the block
!!    hy_del  --- dx, dy, dz
!!    dt - current time step
!!    dtOld - old time step
!!    coeff - coefficients for updating
!!
!!***
!!Reorder(4): hy_starState, hy_tmpState, hy_fl[xyz]
!!NOVARIANTS

subroutine hy_rk_updateSoln (hy_starState,hy_tmpState,blkLimits,blklimitsGC,hy_del, dt, dtOld, limits, hy_coeffs)

  use Hydro_data, ONLY : hy_threadWithinBlock, &
       hy_smallE, hy_smalldens, hy_geometry,&
       hy_4piGinv, hy_alphaGLM, hy_C_hyp
  use Hydro_data, ONLY: hya_farea,hya_fareaY,hya_fareaZ,hya_cvol,hya_xCenter,hya_xLeft,&
       hya_xRight,hya_yCenter,hya_zCenter
  use Hydro_data, ONLY :  hya_grav, hya_flx, hya_fly, hya_flz
  use Driver_interface, ONLY : Driver_abort

  implicit none

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

  real, pointer,dimension(:,:,:,:) :: hy_starState, hy_tmpState
  integer, intent(IN), dimension(LOW:HIGH,MDIM) :: limits,blkLimits,blkLimitsGC
  real,dimension(MDIM), intent(IN) :: hy_del
  real, intent(IN) :: dt, dtOld
  real, dimension(3), intent(IN) :: hy_coeffs
  real,dimension(:,:,:,:),pointer :: hy_grav, &
       hy_flx,hy_fly,hy_flz
  real,pointer,dimension(:,:,:) ::hy_farea,hy_fareaY,hy_fareaZ,hy_cvol
  real,pointer,dimension(:) :: hy_xCenter,hy_xLeft,hy_xRight,hy_yCenter,hy_zCenter

  integer :: i,j,k,n,g

  real, dimension(NUNK_VARS) :: Vstar, V0

  real, dimension(NFLUXES) :: U0, Ustar

  real :: dx, dy, dz

  real :: flx_weight1, flx_weight2
  real :: eint, ekin, emag
  ! Geometry factors
  real :: facM, facP
  real, dimension(NFLUXES) :: Sgeo, Shy_grv, Stot
  integer ::  ind
  real :: dhdt
  integer, dimension(1:MDIM) :: loGC, hiGC

  !! temporaries to be used in computing geometric factors
  real    :: presStar, densStar, pmomStar, tmomStar, xmomStar
  real    :: pmagStar, xmagStar, zmagStar
  integer :: VEL_PHI, MOM_PHI, MOM_PHI_FLUX, MAG_PHI, MAG_PHI_FLUX
  integer :: VEL_ZI, MOM_ZI, MOM_ZI_FLUX, MAG_ZI, MAG_ZI_FLUX
  integer :: VEL_THT, MOM_THT, MOM_THT_FLUX
  real    :: alpha, dx_sph
  
  
  loGC(:) = blkLimitsGC(LOW,:)
  hiGC(:) = blkLimitsGC(HIGH,:)
  

  dx = hy_del(IAXIS); dy = hy_del(JAXIS); dz = hy_del(KAXIS)
  dhdt = minval(hy_del(1:NDIM))/(hy_coeffs(3)*dt)

  hy_grav(1:MDIM,@M bounds_3d(blkLimitsGC))=>hya_grav
  !$omp target enter data map (to: hy_grav)

  @M hy_map_fl
  if (hy_geometry /= CARTESIAN) then
    @M hy_map_geom
  end if

  !$omp target teams distribute parallel do simd collapse(3) &
  !$omp default(none) &
  !$omp private(i, j, k, V0, Vstar, U0, Ustar, Shy_grv, Stot, Sgeo, ekin, emag, &
  !$omp         MOM_PHI, MOM_PHI_FLUX, MOM_THT, MOM_THT_FLUX, MOM_ZI, MOM_ZI_FLUX, &
  !$omp         alpha, dx_sph, facM, facP) &
  !$omp shared(limits, hy_starState, hy_tmpState, hy_grav, hy_flx, hy_fly, hy_flz, &
  !$omp        hy_coeffs, hy_farea, hy_cvol, hy_smalldens, hy_smallE, &
  !$omp        hy_geometry, hy_xLeft, hy_xCenter, hy_xRight, dx, dy, dz, dt, dtOld) &
  !$omp map(to: limits)
  do k = limits(LOW,KAXIS), limits(HIGH,KAXIS)
     do j = limits(LOW,JAXIS), limits(HIGH,JAXIS)
        do i = limits(LOW,IAXIS), limits(HIGH,IAXIS)
           V0(1:NUNK_VARS) = hy_tmpState(1:NUNK_VARS, i, j, k)
           Vstar(1:NUNK_VARS) = hy_starState(1:NUNK_VARS, i, j, k)
           U0(HY_MASS)            = V0(DENS_VAR)
           U0(HY_XMOM:HY_ZMOM)    = V0(DENS_VAR)*V0(VELX_VAR:VELZ_VAR)
           U0(HY_ENER)            = V0(DENS_VAR)*V0(ENER_VAR)
           U0(HY_NUM_FLUX+1:NFLUXES) = V0(SPECIES_BEGIN:MASS_SCALARS_END)*V0(DENS_VAR)
           Ustar(HY_MASS)         = Vstar(DENS_VAR)
           Ustar(HY_XMOM:HY_ZMOM) = Vstar(DENS_VAR)*Vstar(VELX_VAR:VELZ_VAR)
           Ustar(HY_ENER)         = Vstar(DENS_VAR)*Vstar(ENER_VAR)
           Ustar(HY_NUM_FLUX+1:NFLUXES) = Vstar(SPECIES_BEGIN:MASS_SCALARS_END)*Vstar(DENS_VAR)
           
#ifdef SPARK_GLM
           U0(HY_FMGX:HY_FMGZ)    = V0(MAGX_VAR:MAGZ_VAR)
           U0(HY_ENER) = U0(HY_ENER)+0.5*dot_product(V0(MAGX_VAR:MAGZ_VAR),&
                V0(MAGX_VAR:MAGZ_VAR))
           U0(HY_FPSI) = V0(PSIB_VAR)
           Ustar(HY_FMGX:HY_FMGZ) = Vstar(MAGX_VAR:MAGZ_VAR)
           Ustar(HY_ENER) = Ustar(HY_ENER)+0.5*dot_product(Vstar(MAGX_VAR:MAGZ_VAR),&
                Vstar(MAGX_VAR:MAGZ_VAR))
           Ustar(HY_FPSI) = Vstar(PSIB_VAR)
#endif
           !!          call update_solution(i,j,k,hy_coeffs,dt, dtOld, dx, dy, dz, dhdt)
           
           facM = 1.0; facP = 1.0; Sgeo = 0.0
           
           ! Get geometric factors and sources
           ! Get gravitational source terms
           if(hy_geometry /= CARTESIAN) then
              @M hy_geom_update(Ustar,Vstar)
!!$           call geoFacs(hy_geometry, hy_xLeft(i), hy_xCenter(i), hy_xRight(i), &
!!$                   hy_farea(i,j,k), hy_farea(i+1,j,k), hy_cvol(i,j,k), &
!!$                   facM, facP, Sgeo, Ustar, Vstar, dx)
           end if
           @M hy_gravSources
           
           ! Sum total source terms
           Stot = Sgeo + Shy_grv
           
           ! Now update conserved vector with flux gradients
           Ustar = hy_coeffs(1)*U0 + hy_coeffs(2)*Ustar +hy_coeffs(3)*( &
                -dt/dx*(facP*hy_flx(:,i+1,j,k)-facM*hy_flx(:,i,j,k)) &
#if NDIM > 1
                -dt/dy*(hy_fly(:,i  ,j+1,k  )-hy_fly(:,i  ,j  ,k  )) &
#if NDIM ==3
                -dt/dz*(hy_flz(:,i  ,j  ,k+1)-hy_flz(:,i  ,j  ,k  )) &
#endif
#endif
                +dt*Stot)
           ! print *, "Ustar" , "(",i,j,k,") ",Ustar
           ! Update primitive variables
           emag = 0.0
#ifdef SPARK_GLM
           !print *, hy_coeffs(1)*U0(HY_FPSI), hy_coeffs(2)*Ustar(HY_FPSI), Fp(HY_FPSI)-Fm(HY_FPSI)
           Vstar(MAGX_VAR:MAGZ_VAR) = Ustar(HY_FMGX:HY_FMGZ)
           Vstar(PSIB_VAR) = Ustar(HY_FPSI)*exp(-hy_alphaGLM*hy_C_hyp/dhdt)
           emag = 0.5*dot_product(Vstar(MAGX_VAR:MAGZ_VAR),Vstar(MAGX_VAR:MAGZ_VAR))
           Vstar(MAGP_VAR) = emag
           Ustar(HY_ENER) = Ustar(HY_ENER) - emag
#endif
           
           Vstar(DENS_VAR)          = max(Ustar(HY_MASS),hy_smalldens)
           Vstar(VELX_VAR:VELZ_VAR) = Ustar(HY_XMOM:HY_ZMOM)/Vstar(DENS_VAR)
           Vstar(ENER_VAR)          = max(hy_smallE,Ustar(HY_ENER)/Vstar(DENS_VAR))
           
           ekin = .5*dot_product(Vstar(VELX_VAR:VELZ_VAR),Vstar(VELX_VAR:VELZ_VAR))
           Vstar(EINT_VAR) = max(hy_smallE,Vstar(ENER_VAR)-ekin)
           
           ! Divide partial densities by new mass densities to finalize
           ! update of new mass fractions.
           Vstar(SPECIES_BEGIN:MASS_SCALARS_END) = Ustar(HY_NUM_FLUX+1:NFLUXES)/Vstar(DENS_VAR)
#ifdef GPOT_VAR
           ! Now extrapolate gravity to intermediate time state
           ! the star state GPOT_VAR will be reset so that GPOL_VAR isn't screwed up
           Vstar(GPOT_VAR) = hy_coeffs(1)*V0(GPOT_VAR) + hy_coeffs(2)*Vstar(GPOT_VAR) &
                + hy_coeffs(3)*dt*(V0(GPOT_VAR) - V0(GPOL_VAR))/dtOld
#endif
           
           hy_starState(1:NUNK_VARS, i, j, k) = Vstar(1:NUNK_VARS)
           
        enddo !i
     enddo !j
  enddo !k

  !$omp target exit data map (release: hy_grav)
  @M hy_nullFl
  nullify(hy_grav)
  if (hy_geometry /= CARTESIAN) then
    @M hy_release_geom
  end if
  
  
end subroutine hy_rk_updateSoln
