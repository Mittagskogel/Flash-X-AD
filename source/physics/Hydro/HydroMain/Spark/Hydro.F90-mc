!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!> @ingroup HydroSpark
!!
!! @brief Main implementations of Spark Hydro solver
!!
!! @stubref{Hydro}
!<
!!Reorder(4): hy_fl[xyz],hy_fluxBuf[XYZ],hy_starState,hy_tmpState,Uin
!!NOVARIANTS
subroutine Hydro(timeEndAdv, dt, dtOld, sweepOrder)

  @M hy_scratch_use
  use Hydro_data, ONLY : hy_eosData, hy_mfrac,hy_useHydro,hy_telescoping,hy_maxLev,&
                         hy_addFluxArray,hy_coeffs,hy_weights,hy_limitsArray,hy_coeffArray,&
                         hy_threadWithinBlock

  use Hydro_data, ONLY : hy_fluxCorrect, hy_fluxCorrectPerLevel,hy_gcMask,&
       hy_lChyp, hy_C_hyp, hy_geometry,hy_del, hy_tiny, hy_hybridRiemann, hy_maxCells
  use Hydro_data, ONLY : lim,limgc,gCells,dir,stage

  use hy_rk_interface, ONLY : hy_rk_getFaceFlux, hy_rk_getGraveAccel, hy_rk_updateSoln, hy_rk_correctFluxes, hy_rk_shockDetect
  use Timers_interface, ONLY : Timers_start, Timers_stop
  use Grid_interface, ONLY : Grid_communicateFluxes, &
       Grid_fillGuardCells, Grid_getMaxRefinement, &
       Grid_correctFluxData_xtra, Grid_putFluxData, Grid_putFluxData_block, &
       Grid_getFluxCorrData_block,Grid_renormAbundance
  use Eos_interface, ONLY : Eos_wrapped
  use IO_interface, ONLY : IO_setScalar
  use Grid_interface, ONLY : Grid_getTileIterator, Grid_releaseTileIterator
  use Grid_tile,         ONLY : Grid_tile_t
  use Grid_iterator,     ONLY : Grid_iterator_t
  use Grid_interface, ONLY : Grid_getCellCoords, Grid_getCellFaceAreas, &
       Grid_getCellVolumes

#include "Simulation.h"
#include "constants.h"
#include "Eos.h"
#include "Spark.h"

#include "Flashx_mpi_implicitNone.fh"

#define NRECON HY_NUM_VARS+NSPECIES+NMASS_SCALARS
  type(Grid_iterator_t) :: itor
  real,              pointer    :: Uin(:,:,:,:)
  type(Grid_tile_t)     :: tileDesc
  integer :: level
  integer, dimension(LOW:HIGH,MDIM) :: blkLimits, blkLimitsGC,grownLimits

  real,dimension(MDIM) :: deltas

  real,    intent(in) :: timeEndAdv, dt, dtOld
  integer, intent(IN) :: sweepOrder
  integer :: n, error, maxLev
  integer :: xLo,xHi,yLo,yHi,zLo,zHi
  integer, dimension(LOW:HIGH,MDIM) :: limits
  real :: hdt,wt
  integer, parameter :: last_stage = MAXSTAGE

  integer :: i,j,k,v,maxcells,ng

  @M hy_declare_scr_ptr

  integer :: lev

  logical :: offload = .false.

  if (.NOT. hy_useHydro) return

  ! Check for some incompatible configuration options; perhaps move to Hydro_init
  @M hy_check_config

  call Timers_start("Hydro")

  call check_if_on_GPU()
#ifdef OMP_OL
  offload = .true.
#endif

  hdt = 0.5*dt

  @M hy_DIR_TARGET_enter_data(alloc, [grownLimits, blkLimits, blkLimitsGC, limits])

  ! Find the global maximum hyperbolic speed. hy_lChyp from Hydro_computeDt
#ifdef SPARK_GLM
  call MPI_AllReduce (hy_lChyp, hy_C_hyp, 1, &
       FLASH_REAL, MPI_MAX, hy_globalComm, error)
  call IO_setScalar("C_hyp", hy_lChyp)
#endif

  if(hy_telescoping) &
       call Grid_fillGuardCells(CENTER,ALLDIR,doEos=.false.,maskSize=NUNK_VARS,mask=hy_gcMask)
  !-------------------------------------------------------------------!
  !***NO Flux correction    or   Flux correction but NOT per level****!
  !-------------------------------------------------------------------!
  stage=1
  if ((.NOT.hy_fluxCorrect).OR.((hy_fluxCorrect).AND.(.NOT.hy_fluxCorrectPerLevel))) then
     @M hy_stages_nt !! this is the do loop statement for non-telescoping version
     if(.NOT.hy_telescoping) &
          call Grid_fillGuardCells(CENTER,ALLDIR,doEos=.false.,maskSize=NUNK_VARS,mask=hy_gcMask)
     nullify(Uin)
     @M iter_all_begin(LEAF,.false.,blkLimits,blkLimitsGC,hy_del)

        if (hy_geometry /= CARTESIAN) then
           @M hy_fill_geom
           @M hy_DIR_TARGET_enter_data(to, [hy_farea, hy_fareaY, hy_fareaZ, hy_cvol,      &&
                                       hy_xCenter, hy_xLeft, hy_xRight, hy_yCenter, hy_zCenter])
        endif

        @M hy_map_tmp_states
        @M hy_map_scr_ptrs
        @M hy_DIR_TARGET_enter_data(alloc, [hy_starState, hy_tmpState, &&
                                     hy_flx, hy_fly, hy_flz, &&
                                     hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
        @M hy_DIR_TARGET_enter_data(alloc, [hy_grav])

        ng=NGUARD-1
        @M hy_setLims(ng)

        @M hy_DIR_TARGET_enter_data(to, [Uin])
        @M hy_DIR_TARGET_update_to([hy_del, grownLimits, blkLimits, blkLimitsGC, limits])

        ! DivB will technically be lagged by 1 step, but we need ghost zones to
        ! compute the gradients. I ain't doing more communication for a diagnostic...

        ! AH: TODO : OpenMP directives for hy_calcDivB
        @M hy_calcDivB
        if (hy_telescoping .OR. stage==1) call hy_rk_shockDetect(Uin, limits, blkLimitsGC, hy_tiny)

        call Timers_start("Offloaded Section")
        call Timers_start("scratch")

        @M hy_saveState

        call Timers_stop("scratch")

        !! This macro (hy_stages_t) has a null implementation for the non-telescoping mode.
        !! the next few lines compute all the index limits needed for all stages and directions
        !! in hy_rk_getFaceFlux. These indices are now available to the routines through "use"
        !! clause. I have done this to simplify the kernel launching in the GPU and also to
        !! really inventory all data that needs to move to the device memory for computation
        @M hy_stages_t
           ng=hy_limitsArray(stage)
           @M hy_setLims(ng)
           do dir=1,NDIM
              @M hy_calc_lim
           end do
        @M hy_end_stages_t

        !! Begin loop over stages for the telescoping mode.
        @M hy_stages_t !! this is the do loop statement for telescoping version
           ! calculate gravitational acceleration based on current value of GPOT_VAR
           ! This is stored in module-scope variable hy_grav
           call hy_rk_getGraveAccel(hy_starState, hy_grav, &
               hy_xCenter, hy_yCenter, hy_del, hy_geometry, blkLimitsGC)

           !Set needed number of guard cells to update based on
           !current stage for telescoping upda
           ng=hy_limitsArray(stage)
           @M hy_setLims(ng)
           @M hy_DIR_TARGET_update_to([limits])

           call Timers_start("getFaceFlux")
           call hy_rk_getFaceFlux(hy_starState, blklimits, blkLimitsGC, limits)
           @M hy_DIR_TARGET_update_from([hy_flx, hy_fly, hy_flz])
           call Timers_stop("getFaceFlux")
           !------- Add this in -----

           ! Now update solution based on conservative fluxes
           ! See select_RK_scheme() for explicit outline of C1, C2, & C3
           ! U* = C1 * U0 + C2 * U* + C3 * dt*L(U*)

           !Set proper coefficients for the given stage
           hy_coeffs = hy_coeffArray(stage,:)
           @M hy_DIR_TARGET_update_to([hy_coeffs])

           call Timers_start("updateSoln")
           call hy_rk_updateSoln(hy_starState, hy_tmpState, blkLimits, blklimitsGC, hy_del, dt, dtOld, limits, hy_coeffs)
           @M hy_DIR_TARGET_update_from([hy_starState])
           call Timers_stop("updateSoln")
           if (hy_fluxCorrect) then
              wt=0.0
              if(hy_addFluxArray(stage))wt=1.0
              @M hy_addFluxes
           end if

#if NSPECIES>0
           !Properly normalize species after the update
           call Grid_renormAbundance(tileDesc, blkLimitsGC, hy_starState)
           !!call Driver_abort("Grid_renormAbundance not implemented in SPARK with GPU offloading yet")
#endif

           ! Update EOS based on intermediate solution
           call Timers_start("eos")
           call Eos_wrapped(MODE_DENS_EI, limits, hy_starState)
           @M hy_DIR_TARGET_update_to([hy_starState])
           call Timers_stop("eos")
           !Finally update the state
           if (stage == last_stage) then !! this is only needed for telescoping version
              @M hy_updateState
           endif

        @M hy_end_stages_t
        if (hy_geometry /= CARTESIAN) then
           @M hy_DIR_TARGET_exit_data(release, [hy_farea, hy_fareaY, hy_fareaZ, hy_cvol,      &&
                                            hy_xCenter, hy_xLeft, hy_xRight, hy_yCenter, hy_zCenter])
           @M hy_release_geom
        end if
        !Store flux buffer in semipermanent flux storage (SPFS)
        if ((hy_telescoping).and.(hy_fluxCorrect)) then
           call Grid_putFluxData(tileDesc,&
                                 hy_fluxBufX, &
                                 hy_fluxBufY, &
                                 hy_fluxBufZ, &
                                 blkLimits(LOW,:))
        end if
        call Timers_stop("Offloaded Section")
        @M hy_DIR_TARGET_exit_data(release, [hy_starState, hy_tmpState, &&
                                         hy_flx, hy_fly, hy_flz, &&
                                         hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
        @M hy_release_tmp_states
        @M hy_release_scr_ptrs

        @M hy_DIR_TARGET_exit_data(release, [Uin])
     @M iter_end
     @M hy_end_stages_nt
     if (hy_fluxCorrect) then
        !Communicate the fine fluxes
        call Grid_communicateFluxes(ALLDIR,UNSPEC_LEVEL)

        !        call Timers_start("flux correct")
        !        ! Loop over blocks and correct block-edge solution

        nullify(Uin)
        @M iter_all_begin(LEAF,.false.,blkLimits,blkLimitsGC,hy_del)

           !           !Get 'Flux hy_del' on coarse side of fine coarse boundaries;
           !           !all other values are 0.
           @M hy_mapFluxBuf
           call Grid_getFluxCorrData_block(tileDesc,hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ,&
                blkLimits(LOW,:),isFluxDensity=(/hy_telescoping/))

           if (hy_geometry /= CARTESIAN) then
              @M hy_fill_geom
           endif


           call hy_rk_correctFluxes(Uin,blkLimits,blklimitsGC,level,hy_del, dt, .NOT.hy_telescoping)
           if (hy_geometry /= CARTESIAN) then
              @M hy_release_geom
           end if
           @M hy_nullFluxBuf
           @M iter_end
     end if !Flux correction
    else !flux correct per level
     print *, "Flux correct per level"
     !----------------------------------------!
     !*****Flux correction per level Occurs***!
     !----------------------------------------!
     do lev=hy_maxLev,1,-1

        !Once the finest level is completed, place averaged fine fluxes into
        !current coarse semipermanent flux storage (SPFS)

        if (lev < hy_maxLev) call Grid_communicateFluxes(ALLDIR,lev)
        ! Loop over blocks and compute Hydro update block-by-block
        !~ For now tiling is disabled until we can confirm block registers are the same as tile registers

        nullify(Uin)
        @M iter_level_begin(LEAF,.FALSE.,lev,blkLimits,blkLimitsGC,hy_del)
        @M hy_DIR_TARGET_enter_data(to, [Uin])

           xLo = blkLimits(LOW,IAXIS); xHi = blkLimits(HIGH,IAXIS)
           yLo = blkLimits(LOW,JAXIS); yHi = blkLimits(HIGH,JAXIS)
           zLo = blkLimits(LOW,KAXIS); zHi = blkLimits(HIGH,KAXIS)

           ng=NGUARD-1
           @M hy_setLims(ng)
           @M hy_DIR_TARGET_update_to([hy_del, grownLimits, blkLimits, blkLimitsGC, limits])
           ! DivB will technically be lagged by 1 step, but we need ghost zones to
           ! compute the gradients. I ain't doing more communication for a diagnostic...
           @M hy_map_tmp_states
           @M hy_map_scr_ptrs
           @M hy_DIR_TARGET_enter_data(alloc, [hy_starState, hy_tmpState, &&
                                           hy_flx, hy_fly, hy_flz, &&
                                           hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])

           @M hy_calcDivB
           call hy_rk_shockDetect(Uin, limits, blkLimitsGC, hy_tiny)
           ! Allocate storage of fluxes, flux buffers, & gravity info
           call Timers_start("scratch")
           ! U* = U0
           @M hy_saveState!!call saveState(Uin,blkLimits,blkLimitsGC)
           call Timers_stop("scratch")
           do stage=1,last_stage
              ng=hy_limitsArray(stage)
              @M hy_setLims(ng)
              do dir=1,NDIM
                 @M hy_calc_lim
              end do
           end do

           !! Begin loop over stages for the telescoping mode.
           do stage=1,last_stage !! this is the do loop statement for telescoping version

              ! calculate gravitational acceleration based on current value of GPOT_VAR
              ! This is stored in module-scope variable hy_grav
              call hy_rk_getGraveAccel(hy_starState, hy_grav, &
                  hy_xCenter, hy_yCenter, hy_del, hy_geometry, blkLimitsGC)

              !Set needed number of guard cells to update based on
              !current stage for telescoping update
              ng=hy_limitsArray(stage)
              @M hy_setLims(ng)
              @M hy_DIR_TARGET_update_to([limits])

              ! Perform reconstruction and flux calculation
              ! In Stage 1, compute low-side fluxes and update for NSTENCIL guardcells
              call Timers_start("getFaceFlux")
              call hy_rk_getFaceFlux (hy_starState, blklimits,blkLimitsGC, limits)
              @M hy_DIR_TARGET_update_from([hy_flx, hy_fly, hy_flz])
              call Timers_stop("getFaceFlux")

              !In the last stage, modify fluxes on the coarse side of fine coarse boundaries.
              !This incorporates fluxes calculated in the last stage & the 'flux difference'
              !introduced on fine coarse boundaries.

              if (stage == last_stage) then
                 if (lev < hy_maxLev) then
                    call Grid_correctFluxData_xtra(tileDesc,1/hy_weights(stage),&
                         hy_flx(:,xLo:xHi+1,yLo:yHi    ,zLo:zHi    ),&
                         hy_fly(:,xLo:xHi  ,yLo:yHi+K2D,zLo:zHi    ),&
                         hy_flz(:,xLo:xHi  ,yLo:yHi    ,zLo:zHi+K3D),&
                         blkLimits(LOW,:),-1/hy_weights(stage),&
                         hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ)
                    @M hy_DIR_TARGET_update_to([hy_flx, hy_fly, hy_flz])
                 endif
              endif

              wt=0.0
              if(hy_addFluxArray(stage))wt=1.0
              @M hy_addFluxes

              ! Now update solution based on conservative fluxes
              ! See select_RK_scheme() for explicit outline of C1, C2, & C3
              ! U* = C1 * U0 + C2 * U* + C3 * dt*L(U*)
              hy_coeffs = hy_coeffArray(stage,:)
              @M hy_DIR_TARGET_update_to([hy_coeffs])
              call Timers_start("updateSoln")
              if (hy_geometry /= CARTESIAN) then
                 @M hy_fill_geom
                 @M hy_DIR_TARGET_enter_data(to, [hy_farea, hy_fareaY, hy_fareaZ, hy_cvol, &&
                                              hy_xCenter, hy_xLeft, hy_xRight, hy_yCenter, hy_zCenter])
              endif

              call hy_rk_updateSoln(hy_starState,hy_tmpState,blkLimits,blklimitsGC,hy_del, dt, dtOld, limits, hy_coeffs)
              @M hy_DIR_TARGET_update_from([hy_starState])
              if (hy_geometry /= CARTESIAN) then
                 @M hy_DIR_TARGET_exit_data(release, [hy_farea, hy_fareaY, hy_fareaZ, hy_cvol, &&
                                                  hy_xCenter, hy_xLeft, hy_xRight, hy_yCenter, hy_zCenter])
                 @M hy_release_geom
              end if

              ! -------------------------------------- Deal with below here later ---------------------------------------------------__!

#if NSPECIES>0
              call Grid_renormAbundance(tileDesc,blkLimitsGC,hy_starState)
              !!call Driver_abort("Grid_renormAbundance not implemented in SPARK with GPU offloading yet")
#endif
              call Timers_stop("updateSoln")
              ! Update EOS based on intermediate solution

              call Timers_start("eos")
              call Eos_wrapped(MODE_DENS_EI,limits,hy_starState)
              @M hy_DIR_TARGET_update_to([hy_starState])
              call Timers_stop("eos")

              if (stage == last_stage) then
                 ! Finally, store the output and free up the scratch array
                 call Timers_start("scratch")
                 @M hy_updateState
                 call Timers_stop("scratch")
              endif
           end do!stage loop
           !Put flux buffer information into SPFS
           if (lev > 1) then
              call Grid_putFluxData(tileDesc, &
                                    hy_fluxBufX, &
                                    hy_fluxBufY, &
                                    hy_fluxBufZ, &
                                    blkLimits(LOW,:))
           end if
           @M hy_DIR_TARGET_exit_data(release, [hy_starState, hy_tmpState, &&
                                            hy_flx, hy_fly, hy_flz, &&
                                            hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
           @M hy_DIR_TARGET_exit_data(release, [hy_grav])
           @M hy_release_scr_ptrs
           @M hy_DIR_TARGET_exit_data(release, [Uin])
           @M iter_end
        enddo!loop over levels
     endif !Flux correct per Level

! Reset local maximum hyperbolic speed. This will be updated in Hydro_computeDt.
  hy_lChyp = TINY(1.0)

  @M hy_DIR_TARGET_exit_data(release, [grownLimits, blkLimits, blkLimitsGC, limits])

  call Timers_stop("Hydro")

contains

  subroutine check_if_on_GPU()
!$  use omp_lib, ONLY : omp_is_initial_device
    use Driver_interface, ONLY : Driver_abort
    implicit none
    logical :: onCPU

    onCPU = .TRUE.

#ifdef OMP_OL
    !$omp target map(tofrom:onCPU)
    !$  onCPU = omp_is_initial_device()
    !$omp end target
#endif

    if (onCPU) then
       print *, "---------------- Running on CPU --------------------------------"
       ! call Driver_abort("Unable to run on GPU")
    else
       print *, "---------------- Running on GPU --------------------------------"
    end if

  end subroutine check_if_on_GPU

end subroutine Hydro
