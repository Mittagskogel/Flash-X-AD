!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file

!> @ingroup HydroSpark
!!
!! @brief Main implementations of Spark Hydro solver
!!
!! @stubref{Hydro}
!<

!!Reorder(4): hy_fl[xyz],hy_fluxBuf[XYZ],hy_starState,hy_tmpState,Uin
!!Reorder(4): hy_rope,hy_flux,hy_uPlus,hy_uMinus
!!NOVARIANTS

#define ENABLE_TRUNC_HYDRO
#define TRUNC_FROM 64
#define TRUNC_TO_E 0
#define TRUNC_TO_M 24

module truncate_Hydro
  implicit none
  interface
     function f__enzyme_truncate_mem_value(x, from, to_e, to_m) result(p_x) bind(c)
       use, intrinsic :: iso_c_binding, only: c_double, c_int
       implicit none

       ! double precision, intent(in) :: x
       ! integer, intent(in) :: from, to
       real(c_double), intent(in), value :: x
       integer(c_int), intent(in), value :: from, to_e, to_m
       double precision :: p_x
     end function f__enzyme_truncate_mem_value
  end interface

  interface
     function f__enzyme_expand_mem_value(x, from, to_e, to_m) result(p_x) bind(c)
       use, intrinsic :: iso_c_binding, only: c_double, c_int
       implicit none

       ! double precision, intent(in) :: x
       ! integer, intent(in) :: from, to
       real(c_double), intent(in), value :: x
       integer(c_int), intent(in), value :: from, to_e, to_m
       double precision :: p_x
     end function f__enzyme_expand_mem_value
  end interface

  interface
     function enzyme_fprt_gc_mark_seen(x) bind(c) result(p_x)
       use, intrinsic :: iso_c_binding, only: c_double
       implicit none

       real(c_double), intent(in), value :: x
       double precision :: p_x
     end function enzyme_fprt_gc_mark_seen
  end interface

  interface
     subroutine enzyme_fprt_gc_dump_status() bind(c)
     end subroutine enzyme_fprt_gc_dump_status
  end interface

  interface
     subroutine enzyme_fprt_gc_doit() bind(c)
     end subroutine enzyme_fprt_gc_doit
  end interface

  public :: truncate_0d, truncate_1d, truncate_2d, truncate_3d, truncate_4d
  public :: f__enzyme_truncate_mem_func_hydro_advance
  contains
    subroutine truncate_1d(x)
      real, intent(inout) :: x(:)

      integer :: i, n
      n = size(x)

      do i=1,n
         x(i) = f__enzyme_truncate_mem_value(x(i), TRUNC_FROM, TRUNC_TO_E, TRUNC_TO_M)
      end do
    end subroutine truncate_1d

    subroutine truncate_0d(x)
      real, intent(inout) :: x
      real :: tmp(1)

      tmp(1) = x
      call truncate_1d(tmp)
      x = tmp(1)
    end subroutine truncate_0d

    subroutine truncate_2d(x)
      real, intent(inout) :: x(:, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2)])
    end subroutine truncate_2d

    subroutine truncate_3d(x)
      real, intent(inout) :: x(:, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3)])
    end subroutine truncate_3d

    subroutine truncate_4d(x)
      real, intent(inout) :: x(:, :, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3), size(x, 4)])
    end subroutine truncate_4d

    subroutine expand_1d(x)
      real, intent(inout) :: x(:)

      integer :: i, n
      n = size(x)

      do i=1,n
         x(i) = f__enzyme_expand_mem_value(x(i), TRUNC_FROM, TRUNC_TO_E, TRUNC_TO_M)
      end do
    end subroutine expand_1d

    subroutine expand_0d(x)
      real, intent(inout) :: x
      real :: tmp(1)

      tmp(1) = x
      call expand_1d(tmp)
      x = tmp(1)
    end subroutine expand_0d

    subroutine expand_2d(x)
      real, intent(inout) :: x(:, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2)])
    end subroutine expand_2d

    subroutine expand_3d(x)
      real, intent(inout) :: x(:, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3)])
    end subroutine expand_3d

    subroutine expand_4d(x)
      real, intent(inout) :: x(:, :, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3), size(x, 4)])
    end subroutine expand_4d

    subroutine mark_seen_1d(x)
      real, intent(inout) :: x(:)

      integer :: i, n
      n = size(x)

      do i=1,n
         x(i) = enzyme_fprt_gc_mark_seen(x(i))
      end do
    end subroutine mark_seen_1d

    subroutine mark_seen_0d(x)
      real, intent(inout) :: x
      real :: tmp(1)

      tmp(1) = x
      call mark_seen_1d(tmp)
      x = tmp(1)
    end subroutine mark_seen_0d

    subroutine mark_seen_2d(x)
      real, intent(inout) :: x(:, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call mark_seen_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2)])
    end subroutine mark_seen_2d

    subroutine mark_seen_3d(x)
      real, intent(inout) :: x(:, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call mark_seen_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3)])
    end subroutine mark_seen_3d

    subroutine mark_seen_4d(x)
      real, intent(inout) :: x(:, :, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call mark_seen_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3), size(x, 4)])
    end subroutine mark_seen_4d

    subroutine f__enzyme_truncate_mem_func_hydro_advance(from, to_e, to_m, &
         stage_in, Uin, dt, dtOld, &
         hy_starState, hy_tmpState, &
         hy_flx, hy_fly, hy_flz, &
         hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
         hy_grav, hy_flat3d, &
         hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
         deltas, &
         blkLimits, blkLimitsGC, &
         lo, loGC, &
         hy_xCenter, hy_yCenter, hy_zCenter, &
         hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
         hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol)

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

      implicit none

      integer, intent(in) :: from, to_e, to_m

      integer, intent(IN) :: stage_in, lo(3), loGC(3)
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN OUT) :: Uin
      real, intent(IN) :: dt, dtold
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN OUT) :: hy_starState
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_flx, hy_fly, hy_flz
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN) :: hy_tmpState
      real, dimension(1:, lo(1):, lo(2):, lo(3):), intent(OUT) :: hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_rope, hy_flux, hy_uPlus, hy_uMinus
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_grav
      real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_flat3d

      integer, dimension(LOW:HIGH, MDIM), intent(IN) :: blkLimits, blkLimitsGC

      real, dimension(MDIM), intent(IN)  :: deltas
      real, dimension(loGC(1):), intent(IN) :: hy_xCenter
      real, dimension(loGC(2):), intent(IN) :: hy_yCenter
      real, dimension(loGC(3):), intent(IN) :: hy_zCenter
      real, dimension(loGC(1):), intent(IN) :: hy_xLeft, hy_xRight
      real, dimension(loGC(2):), intent(IN) :: hy_yLeft, hy_yRight
      real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(IN) :: hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol

      call Hydro_advance(stage_in, Uin, dt, dtOld, &
           hy_starState, hy_tmpState, &
           hy_flx, hy_fly, hy_flz, &
           hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
           hy_grav, hy_flat3d, &
           hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
           deltas, &
           blkLimits, blkLimitsGC, &
           lo, loGC, &
           hy_xCenter, hy_yCenter, hy_zCenter, &
           hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
           hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol)
    end subroutine f__enzyme_truncate_mem_func_hydro_advance
end module truncate_Hydro



#ifdef DEBUG_ALL
#define DEBUG_HYDRO
#define DEBUG_HYDRO_OFFLOADING
#endif
#define DEBUG_GRID_GCMASK

subroutine Hydro(timeEndAdv, dt, dtOld, sweepOrder)

  use Grid_interface, ONLY : Grid_getTileIterator, &
                             Grid_releaseTileIterator, &
                             Grid_communicateFluxes, &
                             Grid_fillGuardCells, &
                             Grid_zeroFluxData, &        ! this only required for levelwidefluxes
                             Grid_getFluxCorrData_block, &
                             Grid_getFluxCorrData_xtra, &
                             Grid_putFluxData, &
                             Grid_putFluxData_block, &   ! this only required for nonTelescoping
                             Grid_getCellVolumes, &
                             Grid_getCellFaceAreas, &
                             Grid_getCellCoords
  use Grid_tile, ONLY : Grid_tile_t
  use Grid_iterator, ONLY : Grid_iterator_t
  use Timers_interface, ONLY : Timers_start, Timers_stop
  use Logfile_interface, ONLY : Logfile_stampVarMask
  use IO_interface, ONLY : IO_setScalar
  use Hydro_interface, ONLY : Hydro_prepBlock, Hydro_advance


  use Hydro_data, ONLY : hy_useHydro, &
                         hy_eosModeGc, &
                         hy_fluxCorrect, hy_fluxCorrectPerLevel, &
                         hy_telescoping, &
                         hy_maxLev, &
                         hy_weights, hy_coeffArray, &
                         hy_addFluxArray, &  ! this only required for nonTelescoping
                         hy_threadWithinBlock, hy_flattening, &
                         hy_gcMask,&
                         hy_lChyp, hy_C_hyp, hy_alphaGLM, &
                         hy_geometry, hy_tiny, hy_hybridRiemann, hy_maxCells, &
                         hy_cvisc, hy_smallE, hy_smalldens, hy_smallpres, hy_smallX, &
                         hy_limRad, hy_mp5ZeroTol,hy_globalLBnd
  use Hydro_data,ONLY : @M hy_scratch_arrays_list
  use hy_rk_interface, ONLY : hy_rk_initSolnScratch, &
                              hy_rk_getFaceFlux, &
                              hy_rk_getGraveAccel, &
                              hy_rk_updateSoln, &
                              hy_rk_renormAbundance, &
                              hy_rk_correctFluxes, &
                              hy_rk_shockDetect, &
                              hy_rk_getFlatteningLimiter, &
                              hy_rk_saveFluxBuf

  ! Enzyme truncate Hydro functions
  use truncate_Hydro
  ! Enzyme truncate Eos module
  use Eos_data, ONLY : eos_gasConstant, eos_gamma, &
       eos_singleSpeciesA, eos_singleSpeciesZ, eos_truncate
  use eos_idealGammaData, ONLY: eos_gammam1

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

#include "Flashx_mpi_implicitNone.fh"

#define NRECON HY_NUM_VARS+NSPECIES+NMASS_SCALARS

  real, intent(IN) :: timeEndAdv, dt, dtOld
  integer, intent(IN) :: sweepOrder
  @M iter_declare(blkLimits,blkLimitsGC, grownLimits, Uin)
  integer :: level
  integer, dimension(MDIM) :: lo, loGC, hi, hiGC
  real, dimension(MDIM) :: deltas

  @M hy_scratch_ptr_declare
  
#ifdef DEBUG_GRID_GCMASK
  logical,save :: gcMaskLogged =.FALSE.
#else
  logical,parameter :: gcMaskLogged =.TRUE.
#endif

  real :: wt

  ! telescoping variables
  @M hy_bounds_declare
  
  integer :: i, j, k, v, lev, dir, stage, ng
  integer :: xLo, xHi, yLo, yHi, zLo, zHi

  integer, parameter :: last_stage = MAXSTAGE
  logical :: offload = .false.

  ! Enzyme trunc mem variables
  real :: trunc_dt, trunc_dtOld

  if (.NOT. hy_useHydro) return

  ! Check for some incompatible configuration options; perhaps move to Hydro_init
  @M hy_check_config

  call Timers_start("Hydro")

  call check_if_on_GPU()
#ifdef OMP_OL
  offload = .true.
#endif

  @M hy_DIR_TARGET_enter_data(alloc, [deltas, grownLimits, blkLimits, blkLimitsGC, limits, lo, loGC])

  ! Find the global maximum hyperbolic speed. hy_lChyp from Hydro_computeDt
#ifdef SPARK_GLM
  call MPI_AllReduce (hy_lChyp, hy_C_hyp, 1, &
       FLASH_REAL, MPI_MAX, hy_globalComm, error)
  call IO_setScalar("C_hyp", hy_lChyp)
#endif

  ! zero-ing level-wide flux data in case of level-wide fluxes
  ! are used for flux correction with AMReX grid.
  ! otherwise, it calls a stub so has no effect.
  if (hy_fluxCorrect) call Grid_zeroFluxData()

  if (hy_telescoping) then
     @M hy_globalFillGuardCells
  end if
  !-------------------------------------------------------------------!
  !***NO Flux correction    or   Flux correction but NOT per level****!
  !-------------------------------------------------------------------!
  stage=1
  if ((.NOT.hy_fluxCorrect).OR.((hy_fluxCorrect).AND.(.NOT.hy_fluxCorrectPerLevel))) then
     @M hy_stages_nt !! this is the do loop statement for non-telescoping version
     if(.NOT.hy_telescoping) then
        @M hy_globalFillGuardCells
     end if
     nullify(Uin)
     @M iter_all_begin(LEAF,.false.,blkLimits,blkLimitsGC,deltas,Uin)
        lo(:) = blkLimits(LOW, :)
        loGC(:) = blkLimitsGC(LOW, :)
        hi(:) = blkLimits(HIGH, :)
        hiGC(:) = blkLimitsGC(HIGH, :)
        @M hy_map_scr_ptrs
        if (hy_geometry /= CARTESIAN) then
           @M hy_map_fareas
           @M hy_map_geom
        elseif (.not. hy_telescoping) then
           @M hy_map_fareas
        end if

        if (.not. hy_telescoping) then
           @M hy_DIR_TARGET_enter_data(to, [Uin])
        end if

        if (hy_geometry /= CARTESIAN) then
           @M hy_DIR_TARGET_enter_data(to, [hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol])
           @M hy_DIR_TARGET_enter_data(to, [hy_xCenter, hy_xLeft, hy_xRight])
           @M hy_DIR_TARGET_enter_data(to, [hy_yCenter, hy_yLeft, hy_yRight])
           @M hy_DIR_TARGET_enter_data(to, [hy_zCenter])
        elseif(.not. hy_telescoping) then
           @M hy_DIR_TARGET_enter_data(to, [hy_fareaX, hy_fareaY, hy_fareaZ])
        end if

        @M hy_DIR_TARGET_enter_data(to, [hy_starState, hy_tmpState])
        @M hy_DIR_TARGET_enter_data(alloc, [hy_flx, hy_fly, hy_flz])
        @M hy_DIR_TARGET_enter_data(alloc, [hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
        @M hy_DIR_TARGET_enter_data(alloc, [hy_grav, hy_flat3d, hy_Vc])
        @M hy_DIR_TARGET_enter_data(alloc, [hy_rope, hy_flux, hy_uPlus, hy_uMinus])

        ! set lower and uppper bounds to update the solutions
        @M hy_setLimits

        @M hy_DIR_TARGET_update_to([deltas, grownLimits, blkLimits, blkLimitsGC, limits, lo, loGC])

        call Timers_start("computations")
        call Hydro_prepBlock(Uin, blkLimits, blkLimitsGC, deltas, &
                             hy_Vc, hy_starState, hy_tmpState, &
                             hy_xCenter, hy_yCenter, hy_zCenter, &
                             hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
                             hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol, &
                             stage, lo, loGC)

        if (.not. hy_telescoping .and. stage == 1) then
           @M hy_DIR_TARGET_update_from([hy_tmpState])
        end if

        ! Enzyme: Truncate for mem mode
#ifdef ENABLE_TRUNC_HYDRO
        ! Truncate function arguments
        trunc_dt = dt
        trunc_dtOld = dtOld
        call truncate_0d(trunc_dt)
        call truncate_0d(trunc_dtOld)
        call truncate_4d(Uin)
        call truncate_4d(hy_starState)
        call truncate_4d(hy_flx)
        call truncate_4d(hy_fly)
        call truncate_4d(hy_flz)
        call truncate_4d(hy_tmpState)
        call truncate_4d(hy_fluxBufx)
        call truncate_4d(hy_fluxBufy)
        call truncate_4d(hy_fluxBufz)
        call truncate_4d(hy_rope)
        call truncate_4d(hy_flux)
        call truncate_4d(hy_uPlus)
        call truncate_4d(hy_uMinus)
        call truncate_4d(hy_grav)
        call truncate_3d(hy_flat3d)
        call truncate_1d(deltas)
        call truncate_1d(hy_xCenter)
        call truncate_1d(hy_yCenter)
        call truncate_1d(hy_zCenter)
        call truncate_1d(hy_xLeft)
        call truncate_1d(hy_xRight)
        call truncate_1d(hy_yLeft)
        call truncate_1d(hy_yRight)
        call truncate_3d(hy_fareaX)
        call truncate_3d(hy_fareaY)
        call truncate_3d(hy_fareaZ)
        call truncate_3d(hy_cvol)

        ! Truncate Hydro_data fields
        call truncate_0d(hy_cvisc)
        call truncate_0d(hy_C_hyp)
        call truncate_0d(hy_tiny)
        call truncate_0d(hy_smalldens)
        call truncate_0d(hy_smallpres)
        call truncate_0d(hy_smallX)
        call truncate_0d(hy_limRad)
        call truncate_0d(hy_mp5ZeroTol)
        call truncate_2d(hy_coeffArray)
        call truncate_0d(hy_smallE)
        call truncate_0d(hy_alphaGLM)
        call truncate_1d(hy_weights)

        ! ! Truncate Eos_data fields
        ! call truncate_0d(eos_gasConstant)
        ! call truncate_0d(eos_gamma)
        ! call truncate_0d(eos_singleSpeciesA)
        ! call truncate_0d(eos_singleSpeciesZ)

        ! ! Truncate eos_idealGammaData fields
        ! call truncate_0d(eos_gammam1)

        eos_truncate = .true.
        call f__enzyme_truncate_mem_func_hydro_advance(TRUNC_FROM, TRUNC_TO_E, TRUNC_TO_M, &
             stage, Uin, trunc_dt, trunc_dtOld, &
             hy_starState, hy_tmpState, &
             hy_flx, hy_fly, hy_flz, &
             hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
             hy_grav, hy_flat3d, &
             hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
             deltas, &
             blkLimits, blkLimitsGC, &
             lo, loGC, &
             hy_xCenter, hy_yCenter, hy_zCenter, &
             hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
             hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol)
        eos_truncate = .false.

        ! call enzyme_fprt_gc_dump_status()

        ! call mark_seen_0d(trunc_dt)
        ! call mark_seen_0d(trunc_dtOld)
        ! call mark_seen_4d(Uin)
        ! call mark_seen_4d(hy_starState)
        ! call mark_seen_4d(hy_flx)
        ! call mark_seen_4d(hy_fly)
        ! call mark_seen_4d(hy_flz)
        ! call mark_seen_4d(hy_tmpState)
        ! call mark_seen_4d(hy_fluxBufx)
        ! call mark_seen_4d(hy_fluxBufy)
        ! call mark_seen_4d(hy_fluxBufz)
        ! call mark_seen_4d(hy_rope)
        ! call mark_seen_4d(hy_flux)
        ! call mark_seen_4d(hy_uPlus)
        ! call mark_seen_4d(hy_uMinus)
        ! call mark_seen_4d(hy_grav)
        ! call mark_seen_3d(hy_flat3d)
        ! call mark_seen_1d(deltas)
        ! call mark_seen_1d(hy_xCenter)
        ! call mark_seen_1d(hy_yCenter)
        ! call mark_seen_1d(hy_zCenter)
        ! call mark_seen_1d(hy_xLeft)
        ! call mark_seen_1d(hy_xRight)
        ! call mark_seen_1d(hy_yLeft)
        ! call mark_seen_1d(hy_yRight)
        ! call mark_seen_3d(hy_fareaX)
        ! call mark_seen_3d(hy_fareaY)
        ! call mark_seen_3d(hy_fareaZ)
        ! call mark_seen_3d(hy_cvol)

        ! ! Mark_Seen Hydro_data fields
        ! call mark_seen_0d(hy_cvisc)
        ! call mark_seen_0d(hy_C_hyp)
        ! call mark_seen_0d(hy_tiny)
        ! call mark_seen_0d(hy_smalldens)
        ! call mark_seen_0d(hy_smallpres)
        ! call mark_seen_0d(hy_smallX)
        ! call mark_seen_0d(hy_limRad)
        ! call mark_seen_0d(hy_mp5ZeroTol)
        ! call mark_seen_2d(hy_coeffArray)
        ! call mark_seen_0d(hy_smallE)
        ! call mark_seen_0d(hy_alphaGLM)
        ! call mark_seen_1d(hy_weights)

        ! Expand function arguments
        ! call expand_0d(trunc_dt)
        ! call expand_0d(trunc_dtOld)
        call expand_4d(Uin)
        call expand_4d(hy_starState)
        call expand_4d(hy_flx)
        call expand_4d(hy_fly)
        call expand_4d(hy_flz)
        call expand_4d(hy_tmpState)
        call expand_4d(hy_fluxBufx)
        call expand_4d(hy_fluxBufy)
        call expand_4d(hy_fluxBufz)
        call expand_4d(hy_rope)
        call expand_4d(hy_flux)
        call expand_4d(hy_uPlus)
        call expand_4d(hy_uMinus)
        call expand_4d(hy_grav)
        call expand_3d(hy_flat3d)
        call expand_1d(deltas)
        call expand_1d(hy_xCenter)
        call expand_1d(hy_yCenter)
        call expand_1d(hy_zCenter)
        call expand_1d(hy_xLeft)
        call expand_1d(hy_xRight)
        call expand_1d(hy_yLeft)
        call expand_1d(hy_yRight)
        call expand_3d(hy_fareaX)
        call expand_3d(hy_fareaY)
        call expand_3d(hy_fareaZ)
        call expand_3d(hy_cvol)

        ! Expand Hydro_data fields
        call expand_0d(hy_cvisc)
        call expand_0d(hy_C_hyp)
        call expand_0d(hy_tiny)
        call expand_0d(hy_smalldens)
        call expand_0d(hy_smallpres)
        call expand_0d(hy_smallX)
        call expand_0d(hy_limRad)
        call expand_0d(hy_mp5ZeroTol)
        call expand_2d(hy_coeffArray)
        call expand_0d(hy_smallE)
        call expand_0d(hy_alphaGLM)
        call expand_1d(hy_weights)

        ! ! Expand Eos_data fields
        ! call expand_0d(eos_gasConstant)
        ! call expand_0d(eos_gamma)
        ! call expand_0d(eos_singleSpeciesA)
        ! call expand_0d(eos_singleSpeciesZ)

        ! ! Expand eos_idealGammaData fields
        ! call expand_0d(eos_gammam1)

        call enzyme_fprt_gc_doit()
        ! call enzyme_fprt_gc_dump_status()
#else
        call Hydro_advance(stage, Uin, dt, dtOld, &
             hy_starState, hy_tmpState, &
             hy_flx, hy_fly, hy_flz, &
             hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
             hy_grav, hy_flat3d, &
             hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
             deltas, &
             blkLimits, blkLimitsGC, &
             lo, loGC, &
             hy_xCenter, hy_yCenter, hy_zCenter, &
             hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
             hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol)
#endif

        call Timers_stop("computations")

        @M hy_DIR_TARGET_update_from([hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])

        if ((.not. hy_telescoping) .and. hy_geometry == CARTESIAN) then
           @M hy_DIR_TARGET_exit_data(release, [hy_fareaX, hy_fareaY, hy_fareaZ])
           @M hy_release_fareas
        end if
        if (hy_geometry /= CARTESIAN) then
           @M hy_DIR_TARGET_exit_data(release, [hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol])
           @M hy_DIR_TARGET_exit_data(release, [hy_xCenter, hy_xLeft, hy_xRight])
           @M hy_DIR_TARGET_exit_data(release, [hy_yCenter, hy_yLeft, hy_yRight])
           @M hy_DIR_TARGET_exit_data(release, [hy_zCenter])
           @M hy_release_geom
        end if
        !Store flux buffer in semipermanent flux storage (SPFS)
        if ((hy_telescoping).and.(hy_fluxCorrect)) then
           @M hy_DIR_TARGET_update_from([hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
           call Grid_putFluxData(tileDesc,&
                                 hy_fluxBufX, &
                                 hy_fluxBufY, &
                                 hy_fluxBufZ, &
                                 blkLimits(LOW,:))
        end if
        @M hy_DIR_TARGET_exit_data(release, [hy_starState, hy_tmpState])
        @M hy_DIR_TARGET_exit_data(release, [hy_flx, hy_fly, hy_flz])
        @M hy_DIR_TARGET_exit_data(release, [hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
        @M hy_DIR_TARGET_exit_data(release, [hy_grav, hy_flat3d, hy_Vc])
        @M hy_DIR_TARGET_exit_data(release, [hy_rope, hy_flux, hy_uPlus, hy_uMinus])
        @M hy_release_scr_ptrs

        if (.not. hy_telescoping) then
           @M hy_DIR_TARGET_exit_data(release, [Uin])
        end if
     @M iter_end(Uin)
     @M hy_end_stages_nt
     if (hy_fluxCorrect) then
        !Communicate the fine fluxes
        call Grid_communicateFluxes(ALLDIR,UNSPEC_LEVEL)

        !        call Timers_start("flux correct")
        !        ! Loop over blocks and correct block-edge solution

        nullify(Uin)
        @M iter_all_begin(LEAF,.false.,blkLimits,blkLimitsGC,deltas,Uin)
           lo(:) = blkLimits(LOW, :)
           loGC(:) = blkLimitsGC(LOW, :)
           hi(:) = blkLimits(HIGH, :)
           hiGC(:) = blkLimitsGC(HIGH, :)
           !           !Get 'Flux deltas' on coarse side of fine coarse boundaries;
           !           !all other values are 0.
           @M hy_map_flux_buffs
           call Grid_getFluxCorrData_block(tileDesc,hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ,&
                blkLimits(LOW,:),isFluxDensity=(/hy_telescoping/))

           if (hy_geometry /= CARTESIAN) then
              @M hy_map_fareas
              @M hy_map_geom
              call Grid_getCellVolumes(level, loGC, hiGC, hy_cvol)
              call Grid_getCellFaceAreas(IAXIS, level, loGC, hiGC, hy_fareaX)
              call Grid_getCellFaceAreas(JAXIS, level, loGC, hiGC, hy_fareaY)
              call Grid_getCellFaceAreas(KAXIS, level, loGC, hiGC, hy_fareaZ)
              call Grid_getCellCoords(IAXIS, CENTER, level, loGC, hiGC, hy_xCenter)
              call Grid_getCellCoords(IAXIS, LEFT_EDGE, level, loGC, hiGC, hy_xLeft)
              call Grid_getCellCoords(IAXIS, RIGHT_EDGE, level, loGC, hiGC, hy_xRight)
              call Grid_getCellCoords(JAXIS, LEFT_EDGE, level, loGC, hiGC, hy_yLeft)
              call Grid_getCellCoords(JAXIS, RIGHT_EDGE, level, loGC, hiGC, hy_yRight)
           end if

           call hy_rk_correctFluxes(Uin, blkLimits, &
                                    hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
                                    deltas, hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol, hy_xCenter, &
                                    hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
                                    hy_geometry, &
                                    hy_smallE, hy_smalldens, &
                                    dt, .NOT. hy_telescoping, &
                                    lo, loGC)
           if (hy_geometry /= CARTESIAN) then
              @M hy_release_geom
           end if
        @M iter_end(Uin)
     end if !Flux correction
   else !flux correct per level
#ifdef DEBUG_HYDRO
      print *, "Flux correct per level"
#endif
      !----------------------------------------!
      !*****Flux correction per level Occurs***!
      !----------------------------------------!
      do lev=hy_maxLev,1,-1

         !Once the finest level is completed, place averaged fine fluxes into
         !current coarse semipermanent flux storage (SPFS)
         if (lev < hy_maxLev) call Grid_communicateFluxes(ALLDIR,lev)

         ! Loop over blocks and compute Hydro update block-by-block
         !~ For now tiling is disabled until we can confirm block registers are the same as tile registers
         nullify(Uin)
         @M iter_level_begin(LEAF,.FALSE.,lev,blkLimits,blkLimitsGC,deltas,Uin)
            lo(:) = blkLimits(LOW, :)
            loGC(:) = blkLimitsGC(LOW, :)
            hi(:) = blkLimits(HIGH, :)
            hiGC(:) = blkLimitsGC(HIGH, :)
            @M hy_DIR_TARGET_enter_data(to, [Uin])

            if (hy_geometry /= CARTESIAN) then
               @M hy_map_geom
               @M hy_DIR_TARGET_enter_data(to, [hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol])
               @M hy_DIR_TARGET_enter_data(to, [hy_xCenter, hy_xLeft, hy_xRight])
               @M hy_DIR_TARGET_enter_data(to, [hy_yCenter, hy_yLeft, hy_yRight])
               @M hy_DIR_TARGET_enter_data(to, [hy_zCenter])
            endif
            if ((.not. hy_telescoping) .and. hy_geometry == CARTESIAN) then
               @M hy_map_fareas
               @M hy_DIR_TARGET_enter_data(to, [hy_fareaX, hy_fareaY, hy_fareaZ])
            end if

            xLo = blkLimits(LOW,IAXIS); xHi = blkLimits(HIGH,IAXIS)
            yLo = blkLimits(LOW,JAXIS); yHi = blkLimits(HIGH,JAXIS)
            zLo = blkLimits(LOW,KAXIS); zHi = blkLimits(HIGH,KAXIS)

            ! set lower and uppper bounds to update the solutions
            @M hy_setLimits

            @M hy_DIR_TARGET_update_to([deltas, grownLimits, blkLimits, blkLimitsGC, limits, lo, loGC])
            @M hy_map_scr_ptrs
            @M hy_DIR_TARGET_enter_data(alloc, [hy_starState, hy_tmpState])
            @M hy_DIR_TARGET_enter_data(alloc, [hy_flx, hy_fly, hy_flz])
            @M hy_DIR_TARGET_enter_data(alloc, [hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
            @M hy_DIR_TARGET_enter_data(alloc, [hy_grav, hy_flat3d, hy_Vc])
            @M hy_DIR_TARGET_enter_data(alloc, [hy_rope, hy_flux, hy_uPlus, hy_uMinus])

            call Timers_start("computations")
            call Hydro_prepBlock(Uin, blkLimits, blkLimitsGC, deltas, &
                                 hy_Vc, hy_starState, hy_tmpState, &
                                 hy_xCenter, hy_yCenter, hy_zCenter, &
                                 hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
                                 hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol, &
                                 stage, lo, loGC)

            if (.not. hy_telescoping .and. stage == 1) then
               @M hy_DIR_TARGET_update_from([hy_tmpState])
            end if

            call Hydro_advance(stage, Uin, dt, dtOld, &
                 hy_starState, hy_tmpState, &
                 hy_flx, hy_fly, hy_flz, &
                 hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
                 hy_grav, hy_flat3d, &
                 hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
                 deltas, &
                 blkLimits, blkLimitsGC, &
                 lo, loGC, &
                 hy_xCenter, hy_yCenter, hy_zCenter, &
                 hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
                 hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol)

            call Timers_stop("computations")

            @M hy_DIR_TARGET_update_from([hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])

            !In the last stage, modify fluxes on the coarse side of fine coarse boundaries.
            !This incorporates fluxes calculated in the last stage & the 'flux difference'
            !introduced on fine coarse boundaries.
            if (lev < hy_maxLev) then
               call Grid_getFluxCorrData_xtra(tileDesc, &
                                              hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
                                              blkLimits(LOW,:), &
                                              hy_flx(:,xLo:xHi+1,yLo:yHi    ,zLo:zHi    ),&
                                              hy_fly(:,xLo:xHi  ,yLo:yHi+K2D,zLo:zHi    ),&
                                              hy_flz(:,xLo:xHi  ,yLo:yHi    ,zLo:zHi+K3D))
               call hy_rk_correctFluxes(Uin, blkLimits, &
                                        hy_flx(:,xLo:xHi+1,yLo:yHi    ,zLo:zHi    ), &
                                        hy_fly(:,xLo:xHi  ,yLo:yHi+K2D,zLo:zHi    ), &
                                        hy_flz(:,xLo:xHi  ,yLo:yHi    ,zLo:zHi+K3D), &
                                        deltas, hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol, hy_xCenter, &
                                        hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
                                        hy_geometry, &
                                        hy_smallE, hy_smalldens, &
                                        dt, .NOT. hy_telescoping, &
                                        lo, loGC)
            endif

            ! Put flux buffer information into SPFS
            if (lev > 1) then
               call Grid_putFluxData(tileDesc, &
                                     hy_fluxBufX, &
                                     hy_fluxBufY, &
                                     hy_fluxBufZ, &
                                     blkLimits(LOW,:))
            end if


            if ((.not. hy_telescoping) .and. hy_geometry == CARTESIAN) then
               @M hy_DIR_TARGET_exit_data(release, [hy_fareaX, hy_fareaY, hy_fareaZ])
               @M hy_release_fareas
            end if
            if (hy_geometry /= CARTESIAN) then
               @M hy_DIR_TARGET_exit_data(release, [hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol])
               @M hy_DIR_TARGET_exit_data(release, [hy_xCenter, hy_xLeft, hy_xRight])
               @M hy_DIR_TARGET_exit_data(release, [hy_yCenter, hy_yLeft, hy_yRight])
               @M hy_DIR_TARGET_exit_data(release, [hy_zCenter])
               @M hy_release_geom
            end if

            @M hy_DIR_TARGET_exit_data(release, [hy_starState, hy_tmpState])
            @M hy_DIR_TARGET_exit_data(release, [hy_flx, hy_fly, hy_flz])
            @M hy_DIR_TARGET_exit_data(release, [hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ])
            @M hy_DIR_TARGET_exit_data(release, [hy_flat3d, hy_grav, hy_Vc])
            @M hy_DIR_TARGET_exit_data(release, [hy_rope, hy_flux, hy_uPlus, hy_uMinus])
            @M hy_release_scr_ptrs
            @M hy_DIR_TARGET_exit_data(release, [Uin])
         @M iter_end(Uin)

      enddo !loop over levels


    endif !Flux correct per Level

! Reset local maximum hyperbolic speed. This will be updated in Hydro_computeDt.
  hy_lChyp = TINY(1.0)

  @M hy_DIR_TARGET_exit_data(release, [grownLimits, blkLimits, blkLimitsGC, limits, lo, loGC])

#ifdef DEBUG_GRID_GCMASK
  gcMaskLogged = .TRUE.
#endif
  call Timers_stop("Hydro")

contains

  subroutine check_if_on_GPU()
!$  use omp_lib, ONLY : omp_is_initial_device
    use Driver_interface, ONLY : Driver_abort
    implicit none
    logical :: onCPU

    onCPU = .TRUE.

#ifdef DEBUG_HYDRO_OFFLOADING
#ifdef OMP_OL
    !$omp target map(tofrom:onCPU)
    !$  onCPU = omp_is_initial_device()
    !$omp end target
#endif

    if (onCPU) then
       print *, "---------------- Running on CPU --------------------------------"
       ! call Driver_abort("Unable to run on GPU")
    else
       print *, "---------------- Running on GPU --------------------------------"
    end if
#endif

  end subroutine check_if_on_GPU

end subroutine Hydro
