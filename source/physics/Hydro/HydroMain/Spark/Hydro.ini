[hy_break_loop]
definition=
     @M loop_end_3d         
 !$acc end parallel
 !$acc parallel
     @M loop_3d(klim)


[hy_scratch_use]
definition=
  use Hydro_data,ONLY : hya_starState,hya_tmpState, &
       hya_uPlus, hya_uMinus, hya_Vc, hya_grav, hya_flat3d, hya_flat, hya_grv,&
       hya_rope, hya_flux, hya_shck, &
       hya_flx, hya_fly, hya_flz, hya_fluxBufX, hya_fluxBufY, hya_fluxBufZ,&
       hya_farea,hya_cvol,hya_xCenter,hya_xLeft,hya_xRight,hya_yCenter,hya_zCenter

[hy_declare_scr_ptr]
definition=
  real, pointer,dimension(:,:,:,:) :: hy_tmpState,hy_starState,hy_flx,hy_fly,hy_flz,&
       hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ
  real,pointer,dimension(:,:,:) ::hy_farea,hy_cvol
  real,pointer,dimension(:) :: hy_xCenter,hy_xLeft,hy_xRight,hy_yCenter,hy_zCenter


[hy_mapflxGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,1,0,0)

[hy_mapflyGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,1,0)

[hy_mapflzGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,0,1)

[hy_mapflx]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)

[hy_mapfly]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0)

[hy_mapflz]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1)

[hy_mapFluxBuf]
definition=
   hy_fluxBufX(@M hy_mapflx)=>hya_fluxBufX
   hy_fluxBufY(@M hy_mapfly)=>hya_fluxBufY
   hy_fluxBufZ(@M hy_mapflz)=>hya_fluxBufZ

[hy_map_geom]
definition=
           hy_farea(@M bounds_3d(blkLimitsGC))=>hya_farea
           hy_cvol(@M bounds_3d(blkLimitsGC))=>hya_cvol
           hy_xCenter(@M bounds_i(blkLimitsGC))=>hya_xCenter
           hy_xLeft(@M bounds_i(blkLimitsGC))=>hya_xLeft
           hy_xRight(@M bounds_i(blkLimitsGC))=>hya_xRight
           hy_yCenter(@M bounds_j(blkLimitsGC))=>hya_yCenter
           hy_zCenter(@M bounds_k(blkLimitsGC))=>hya_zCenter


[hy_nullFluxBuf]
definition=
   nullify(hy_fluxBufX)
   nullify(hy_fluxBufY)
   nullify(hy_fluxBufZ)

[hy_map_fl]
definition=
   hy_flx(@M hy_mapflxGC)=>hya_flx
   hy_fly(@M hy_mapflyGC)=>hya_fly
   hy_flz(@M hy_mapflzGC)=>hya_flz

[hy_nullFl]
definition=
   nullify(hy_flx)
   nullify(hy_fly)
   nullify(hy_flz)

[hy_map_tmp_states]
definition=
        hy_starState(1:NUNK_VARS,@M bounds_3d(blkLimitsGC))=>hya_starState
        hy_tmpState(1:NFLUXES,@M bounds_3d(blkLimitsGC))=>hya_tmpState

[hy_map_scr_ptrs]
definition=
        @M hy_map_fl
        @M hy_mapFluxBuf

[hy_release_tmp_states]
definition=
        nullify(hy_starState)
        nullify(hy_tmpState)


[hy_release_scr_ptrs]
definition=
        @M hy_nullFl
        @M hy_nullFluxBuf



[hy_setLims]
args=ng
definition=
  limits = blkLimits
  do i=1,NDIM
     limits(LOW ,i) = blkLimits(LOW ,i) - ng
     limits(HIGH,i) = blkLimits(HIGH,i) + ng
  end do

[hy_updateState]
definition=
 #ifdef GPOT_VAR
  ! First reset GPOT_VAR.
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       Uin(GPOT_VAR,@M bounds_3d(blkLimits))
 #endif
  Uin(:,@M bounds_3d(blkLimits)) = hy_starState(:,@M bounds_3d(blkLimits))

[hy_saveGlobalState]
definition=


[hy_saveState]
definition=
  ! update temp vars with solution data
  hy_starState(:,@M bounds_3d(blkLimitsGC))=Uin(:,@M bounds_3d(blkLimitsGC))
  @M loop_3d(blkLimitsGC)
  hy_tmpState(HY_MASS,i,j,k) = Uin(DENS_VAR,i,j,k)
  hy_tmpState(HY_XMOM:HY_ZMOM,i,j,k)= Uin(DENS_VAR,i,j,k)*Uin(VELX_VAR:VELZ_VAR,i,j,k)
  hy_tmpState(HY_ENER,i,j,k) = Uin(DENS_VAR,i,j,k)*Uin(ENER_VAR,i,j,k)
  hy_tmpState(HY_NUM_FLUX+1:NFLUXES,i,j,k) = Uin(SPECIES_BEGIN:MASS_SCALARS_END,i,j,k)*Uin(DENS_VAR,i,j,k)
  @M loop_end_3d

[hy_retrieveState]
definition =
  V0(:) = hy_tmpState(:,i,j,k)

[hy_stages_t]
definition = 
  do stage=1,last_stage 

[hy_end_stages_t]
definition =
   end do

[hy_stages_nt]
definition = 

[hy_end_stages_nt]
definition = 


[hy_addFluxes]
definition=
  if (addFlux_array(stage)) then
     hy_fluxBufX = hy_fluxBufX+weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = hy_fluxBufY+weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = hy_fluxBufZ+weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  else
     hy_fluxBufX = weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = +weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  endif

[hy_calcDivB]
definition=
 #ifdef SPARK_GLM
  @M loop_3d(blkLimits)
           divB = 0.0
 #if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/hy_del(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/hy_del(JAXIS)
 #if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/hy_del(KAXIS)
 #endif
 #endif
           Uin(DIVB_VAR,i,j,k) = divB
   @M loop_end_3d
 #endif


[hy_fill_geom]
definition=
           @M hy_map_geom
           call Grid_getCellFaceAreas(IAXIS,level,loGC,hiGC,hy_farea)
           call Grid_getCellVolumes(level,loGC,hiGC,hy_cvol)
           call Grid_getCellCoords(IAXIS, CENTER, level, loGC, hiGC, hy_xCenter)
           call Grid_getCellCoords(IAXIS, LEFT_EDGE, level, loGC, hiGC, hy_xLeft)
           call Grid_getCellCoords(IAXIS, RIGHT_EDGE, level, loGC, hiGC, hy_xRight)
           call Grid_getCellCoords(JAXIS, CENTER, level, loGC, hiGC, hy_yCenter)
           call Grid_getCellCoords(KAXIS, CENTER, level, loGC, hiGC, hy_zCenter)


[hy_release_geom]
definition=
              nullify(hy_xCenter)
              nullify(hy_xLeft)
              nullify(hy_xRight)
              nullify(hy_farea)
              nullify(hy_cvol)
	      nullify(hy_yCenter)
              nullify(hy_zCenter)

[hy_setRope]
args=ix,jx,kx
definition=
  hy_rope(HY_DENS,i,j,k) = hy_starState(DENS_VAR,ix,jx,kx)
  hy_rope(HY_VELX,i,j,k) = hy_starState(VELX_VAR,ix,jx,kx)
  hy_rope(HY_VELY,i,j,k) = hy_starState(VELY_VAR,ix,jx,kx)
  hy_rope(HY_VELZ,i,j,k) = hy_starState(VELZ_VAR,ix,jx,kx)
  hy_rope(HY_PRES,i,j,k) = hy_starState(PRES_VAR,ix,jx,kx)
  hy_rope(HY_GAMC,i,j,k) = hy_starState(GAMC_VAR,ix,jx,kx)
  hy_rope(HY_RHOE,i,j,k) = hy_starState(DENS_VAR,ix,jx,kx)*hy_starState(EINT_VAR,ix,jx,kx)
 #ifdef SPARK_GLM
  hy_rope(HY_MAGX,i,j,k) = hy_starState(MAGX_VAR,ix,jx,kx)
  hy_rope(HY_MAGY,i,j,k) = hy_starState(MAGY_VAR,ix,jx,kx)
  hy_rope(HY_MAGZ,i,j,k) = hy_starState(MAGZ_VAR,ix,jx,kx)
  hy_rope(HY_PSIB,i,j,k) = hy_starState(PSIB_VAR,ix,jx,kx)
 #endif
 #if NSPECIES+NMASS_SCALARS>0
     do n=SPECIES_BEGIN, MASS_SCALARS_END
        hy_rope(HY_NUM_VARS+1+n-SPECIES_BEGIN,i,j,k)    = hy_starState(n,ix,jx,kx)
     enddo
 #endif
 #ifdef GRAVITY
 #ifdef GPOT_VAR
   hy_grv(i,j,k) = hy_starState(GPOT_VAR,ix,jx,kx)
 #else
    hy_grv(i,j,k) = hy_grav(IAXIS,ix,jx,kx)
 #endif
 #endif
 #ifdef SHOK_VAR
     hy_shck(i,j,k) = hy_starState(SHOK_VAR,ix,jx,kx)
 #else
      hy_shck(i,j,k) = 0.0
 #endif
      hy_flat(i,j,k) = hy_flat3d(ix,jx,kx)


