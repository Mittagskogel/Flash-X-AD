
[hy_declare_scratch]
definition =


[hy_use_scratch_geom]
definition =
    use Hydro_data, ONLY : hya_xcenter, hya_xright, hya_xleft, &
       hya_ycenter, hya_zcenter, hya_area, hya_vol
    use Hydro_data, ONLY : hy_xcenter, hy_xright, hy_xleft, &
       hy_ycenter, hy_zcenter, hy_area, hy_vol

[hy_use_scratch]
definition =
   use Hydro_data, ONLY :  hya_starState, hya_tmpState,hya_flx,hya_fly,&
       hya_flz,hya_flxbx,hya_flxby,hya_flxbz, hya_grav, hya_flat3d
   use Hydro_data, ONLY : hy_starState, hy_tmpState,hy_flx,hy_fly,&
       hy_flz,hy_flxbx,hy_flxby,hy_flxbz, hy_grav, hy_tmpState, hy_flat3d
   !! use Hydro_data, ONLY : hya_flux,  hya_uplus, hya_uminus,hya_tposeBlk, hya_grv, hya_shk, hya_flat  
   use Hydro_data, ONLY : hy_flux,  hy_uplus, hy_uminus,hy_tposeBlk, hy_grv, hy_shk, hy_flat 


[hy_alloc_scratch_geom]
 args = sizex,sizey,sizez
 definition = 
   if(hy_geometry /= CARTESIAN) then
      allocate(hya_xcenter(sizex))
      allocate(hya_xleft(sizex))
      allocate(hya_xright(sizex))
      allocate(hya_ycenter(sizey))
      allocate(hya_zcenter(sizez))
      allocate(hya_area(sizex*sizey*sizez))
      allocate(hya_vol(sizex*sizey*sizez))      
    end if

[hy_alloc_scratch_gi]
args = sizex,sizey,sizez
definition =
   allocate(hya_starState(NUNK_VARS*sizex*sizey*sizez))
   allocate(hya_tmpState(NUNK_VARS*sizex*sizey*sizez))	
   allocate(hya_grav(MDIM*sizex*sizey*sizez))   
   allocate(hya_flx(NFLUXES*(sizex+1)*sizey*sizez))
   allocate(hya_fly(NFLUXES*sizex*(sizey+1)*sizez))
   allocate(hya_flz(NFLUXES*sizex*sizey*(sizez+1)))   
   allocate(hya_flxbx(NFLUXES*(sizex+1)*sizey*sizez))
   allocate(hya_flxby(NFLUXES*sizex*(sizey+1)*sizez))
   allocate(hya_flxbz(NFLUXES*sizex*sizey*(sizez+1)))   
   allocate(hya_flat3d(sizex*sizey*sizez))

[hy_alloc_scratch_li]
args = sizex,sizey,sizez
definition = 
   allocate(hy_flat(sizex,sizey,sizez))
   allocate(hy_uplus(NRECON,sizex,sizey,sizez))
   allocate(hy_tposeBlk(NRECON,sizex,sizey,sizez))   
   allocate(hy_uminus(NRECON,sizex,sizey,sizez))
   allocate(hy_grv(sizex,sizey,sizez))
   allocate(hy_shk(sizex,sizey,sizez))
   allocate(hy_flux(NFLUXES,sizex,sizey,sizez))

[hy_map_togpu]
definition =
 #ifdef OMP_OL
   !$omp target enter data map(alloc:hya_xcenter, hya_xright, hya_xleft, hya_ycenter, hya_zcenter, hya_area, hya_vol)
   !$omp target enter data map(alloc:hya_starState, hya_tmpState,hya_flx,hya_fly)
   !$omp target enter data map(alloc:hya_flz,hya_flxbx,hya_flxby,hya_flxbz, hya_grav, hya_utmp, hya_flat3d)
   !$omp target enter data map(alloc: hy_flux,  hy_uplus, hy_uminus,hy_transBlk, hy_grv, hy_shk, hy_flat
   !$omp target update to(hy_tiny,hy_hybridRiemann,hy_C_hyp,hy_cvisc,hy_del,hy_smalldens, hy_smallE, hy_smallpres, hy_smallX,hy_geometry,hy_alphaGLM)
 #endif


[hy_map_scratch_gi]
definition =
   nullify(hy_starState)
   hy_starState(1:NUNK_VARS, @M bounds_3d(blkLimitsGC)) => hya_starState
   nullify(hy_tmpState)
   hy_tmpState(1:NUNK_VARS, @M bounds_3d(blkLimitsGC)) => hya_tmpState  
   nullify(hy_grav)
   hy_grav( 1:MDIM,@M bounds_3d(blkLimitsGC)) => hya_grav   
   nullify(hy_flx)
   hy_flx(1:NFLUXES, @M bounds_3d_plus(blkLimitsGC,1,0,0)) => hya_flx
   nullify(hy_fly)
   hy_fly(1:NFLUXES, @M bounds_3d_plus(blkLimitsGC,0,1,0)) => hya_fly
   nullify(hy_flz)
   hy_flz(1:NFLUXES, @M bounds_3d_plus(blkLimitsGC,0,0,1)) => hya_flz
   nullify(hy_flxbx)
   hy_flxbx(1:NFLUXES, @M bounds_3d_plus(blkLimits,1,0,0)) => hya_flxbx
   nullify(hy_flxby)
   hy_flxby(1:NFLUXES, @M bounds_3d_plus(blkLimits,0,1,0)) => hya_flxby
   nullify(hy_flxbz)
   hy_flxbz(1:NFLUXES, @M bounds_3d_plus(blkLimits,0,0,1)) => hya_flxbz

[hy_map_scratch_geom]
  definition =	
  if(hy_geometry /= CARTESIAN) then
      nullify(hy_xcenter)
      hy_xcenter(bounds_i(blkLimitsGC))=>hya_xcenter
      nullify(hy_xleft)
      hy_xleft(bounds_i(blkLimitsGC))=>hya_xleft
      nullify(hy_xright)
      hy_xright(bounds_i(blkLimitsGC))=>hya_xright
      nullify(hy_ycenter)
      hy_ycenter(bounds_j(blkLimitsGC))=>hya_ycenter
      nullify(hy_zcenter)
      hy_zcenter(bounds_k(blkLimitsGC))=>hya_zcenter            
    end if

[hy_map_scratch_li]
definition = 
   hy_tposeBlk(1:NRECON,@M bounds_3d(blkLimitsGC)) => hya_tposeBlk
   hy_uplus(1:NRECON, @M bounds_3d(blkLimitsGC)) => hya_uplus
   hy_uminus(1:NRECON, @M bounds_3d(blkLimitsGC)) => hya_uminus
   hy_grv(@M bounds_3d(blkLimitsGC)) => hya_grv
   hy_shk(@M bounds_3d(blkLimitsGC)) => hya_shk
   hy_flat(@M bounds_3d(blkLimitsGC)) => hya_flat   
   hy_flux(1:NFLUXES, @M bounds_3d(blkLimitsGC)) => hya_flux


[hy_demap_scratch_geom]
definition = 
   if(hy_geometry /= CARTESIAN) then
     nullify(hy_xcenter)
     nullify(hy_xleft)
     nullify(hy_xright)
     nullify(hy_ycenter)
     nullify(hy_zcenter)
    end if


[hy_demap_scratch_gi]
definition = 
   nullify(hy_starState)
   nullify(hy_tmpState)
   nullify(hy_flux)
   nullify(hy_grav)
   nullify(hy_flx)
   nullify(hy_fly)
   nullify(hy_flz)
   nullify(hy_flxbx)
   nullify(hy_flxby)
   nullify(hy_flxbz)

[hy_demap_scratch_li]
definition =
   nullify(hy_tposeBlk)
   nullify(hy_uplus)
   nullify(hy_uminus)
   nullify(hy_grv)
   nullify(hy_shk)
   nullify(hy_flat)


[hy_dealloc_scratch_geom]
definition =
   if(hy_geometry /= CARTESIAN) then
      deallocate(hya_xcenter)
      deallocate(hya_xleft)
      deallocate(hya_xright)
      deallocate(hya_ycenter)
      deallocate(hya_zcenter)
      deallocate(hya_area)
      deallocate(hya_vol)      
      !$omp target exit data map(DELETE:hya_xcenter, hya_xright, hya_xleft, hya_ycenter, hya_zcenter, hya_area, hya_vol)
   end if

[hy_dealloc_scratch_gi]
definition =
   deallocate(hya_starState)
   deallocate(hya_tmpState)
   deallocate(hya_grav)   
   deallocate(hya_flx)
   deallocate(hya_fly)
   deallocate(hya_flz)
   deallocate(hya_flxbx)
   deallocate(hya_flxby)
   deallocate(hya_flxbz)
   deallocate(hya_flat3d)   
   !$omp target exit data map(DELETE:hya_starState, hya_tmpState,hya_flx,hya_fly,hya_flz)
   !$omp target exit data map(DELETE:hya_flxbx,hya_flxby,hya_flxbz, hya_grav,hya_flat3d)
      
[hy_dealloc_scratch_li]
definition = 
   deallocate(hy_uplus)
   deallocate(hy_tposeBlk)
   deallocate(hy_uminus)
   deallocate(hy_grv)
   deallocate(hy_shk)
   deallocate(hy_flux)
   deallocate(hy_flat)
   !$omp target exit data map(DELETE:hy_flux,hy_uplus,hy_uminus,hy_tposeBlk,hy_grv,hy_shk,hy_flat)


[hy_rk_scheme]
definition =
 #ifdef HY_RK3
  !RK3 quantities
  !Stage 1 coefficients
  ! U* = C1 * U0 + C2 * U* + C3 * dt*L(U*)
  ! U1 =  1 * U0           +  1 * dt*L(U0)
  !Stage 2 coefficients
  ! U* =  C1 * U0 +  C2 * U* +  C3 * dt*L(U*)
  ! U2 = 3/4 * U0 + 1/4 * U1 + 1/4 * dt*L(U1)
  !Stage 3 coefficients
  ! U* =  C1 * U0 +  C2 * U* +  C3 * dt*L(U*)
  ! U3 = 1/3 * U0 + 2/3 * U2 + 2/3 * dt*L(U2)
  !(remember FORTRAN is column major)
  coeff_array = reshape((/1.,0.75,onethird,0.,0.25,twothirds,1.,0.25,twothirds/),(/3,3/))
  last_stage = 3 
  !Array containing number of guard cells on each side for
  !the telescoping update.
  limits_array = (/2*NSTENCIL, NSTENCIL, 0/)
  !Weights that scale the fluxes as they're added into the buffers.
  !Here 'weights' is the same as 'coeff' used in Github pseudocode.
  weights = (/onesixth, onesixth, twothirds/)
 #else
  !RK2 quantities
  ! Stage 1 coefficients
  ! U* = C1 * U0 + C2 * U* + C3 * dt*L(U*)
  ! U1 =  1 * U0           +  1 * dt*L(U0)
  ! Stage 2 coefficients
  ! Now update solution based on conservative fluxes
  ! U* =  C1 * U0 +  C2 * U* +  C3 * dt*L(U*)
  ! U2 = 1/2 * U0 + 1/2 * U1 + 1/2 * dt*L(U1)
  coeff_array = reshape((/1.,0.5,0.,0.,0.5,0.,1.,0.5,0./),(/3,3/))
  last_stage = 2
  limits_array = (/NSTENCIL, 0, 0/)
  weights = (/0.5,0.5,0./)
 #endif
