[hy_break_loop]
args=n1,n2
definition=
    @M loop_end_3d
    call Timers_stop("n1")
    call Timers_start("n2")
    @M loop_3d(klim)

[hy_scratch_use]
definition=
  use Hydro_data,ONLY : hya_starState,hya_tmpState, &
       hya_uPlus, hya_uMinus, hya_Vc, hya_grav, hya_flat3d, hya_flat, hya_grv,&
       hya_rope, hya_flux, hya_shck, &
       hya_flx, hya_fly, hya_flz, hya_fluxBufX, hya_fluxBufY, hya_fluxBufZ,&
       hya_farea,hya_cvol,hya_xCenter,hya_xLeft,hya_xRight,hya_yCenter,hya_zCenter

[hy_declare_scr_ptr]
definition=
  real, pointer,dimension(:,:,:,:) :: hy_tmpState,hy_starState,hy_flx,hy_fly,hy_flz,&
       hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ
  real,pointer,dimension(:,:,:) ::hy_farea,hy_cvol
  real,pointer,dimension(:) :: hy_xCenter,hy_xLeft,hy_xRight,hy_yCenter,hy_zCenter


[hy_mapflxGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,1,0,0)

[hy_mapflyGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,1,0)

[hy_mapflzGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,0,1)

[hy_mapflx]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)

[hy_mapfly]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0)

[hy_mapflz]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1)

[hy_mapFluxBuf]
definition=
   hy_fluxBufX(@M hy_mapflx)=>hya_fluxBufX
   hy_fluxBufY(@M hy_mapfly)=>hya_fluxBufY
   hy_fluxBufZ(@M hy_mapflz)=>hya_fluxBufZ

[hy_map_geom]
definition=
           hy_farea(@M bounds_3d(blkLimitsGC))=>hya_farea
           hy_cvol(@M bounds_3d(blkLimitsGC))=>hya_cvol
           hy_xCenter(@M bounds_i(blkLimitsGC))=>hya_xCenter
           hy_xLeft(@M bounds_i(blkLimitsGC))=>hya_xLeft
           hy_xRight(@M bounds_i(blkLimitsGC))=>hya_xRight
           hy_yCenter(@M bounds_j(blkLimitsGC))=>hya_yCenter
           hy_zCenter(@M bounds_k(blkLimitsGC))=>hya_zCenter


[hy_nullFluxBuf]
definition=
   nullify(hy_fluxBufX)
   nullify(hy_fluxBufY)
   nullify(hy_fluxBufZ)

[hy_map_fl]
definition=
   hy_flx(@M hy_mapflxGC)=>hya_flx
   hy_fly(@M hy_mapflyGC)=>hya_fly
   hy_flz(@M hy_mapflzGC)=>hya_flz

[hy_nullFl]
definition=
   nullify(hy_flx)
   nullify(hy_fly)
   nullify(hy_flz)

[hy_map_tmp_states]
definition=
        hy_starState(1:NUNK_VARS,@M bounds_3d(blkLimitsGC))=>hya_starState
        hy_tmpState(1:NFLUXES,@M bounds_3d(blkLimitsGC))=>hya_tmpState

[hy_map_scr_ptrs]
definition=
        @M hy_map_fl
        @M hy_mapFluxBuf

[hy_release_tmp_states]
definition=
        nullify(hy_starState)
        nullify(hy_tmpState)


[hy_release_scr_ptrs]
definition=
        @M hy_nullFl
        @M hy_nullFluxBuf



[hy_setLims]
args=ng
definition=
  limits = blkLimits
  do i=1,NDIM
     limits(LOW ,i) = blkLimits(LOW ,i) - ng
     limits(HIGH,i) = blkLimits(HIGH,i) + ng
  end do

[hy_updateState]
definition=
 #ifdef GPOT_VAR
  ! First reset GPOT_VAR.
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       Uin(GPOT_VAR,@M bounds_3d(blkLimits))
 #endif
  Uin(:,@M bounds_3d(blkLimits)) = hy_starState(:,@M bounds_3d(blkLimits))

[hy_saveGlobalState]
definition=


[hy_saveState]
definition=
  ! update temp vars with solution data
  hy_starState(:,@M bounds_3d(blkLimitsGC))=Uin(:,@M bounds_3d(blkLimitsGC))
  @M loop_3d(blkLimitsGC)
  hy_tmpState(HY_MASS,i,j,k) = Uin(DENS_VAR,i,j,k)
  hy_tmpState(HY_XMOM:HY_ZMOM,i,j,k)= Uin(DENS_VAR,i,j,k)*Uin(VELX_VAR:VELZ_VAR,i,j,k)
  hy_tmpState(HY_ENER,i,j,k) = Uin(DENS_VAR,i,j,k)*Uin(ENER_VAR,i,j,k)
  hy_tmpState(HY_NUM_FLUX+1:NFLUXES,i,j,k) = &
	Uin(SPECIES_BEGIN:MASS_SCALARS_END,i,j,k)*Uin(DENS_VAR,i,j,k)
  @M loop_end_3d

[hy_stages_t]
definition = 
  do stage=1,last_stage 

[hy_end_stages_t]
definition =
   end do

[hy_stages_nt]
definition = 

[hy_end_stages_nt]
definition = 


[hy_addFluxes]
definition=
  if (addFlux_array(stage)) then
     hy_fluxBufX = hy_fluxBufX+weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = hy_fluxBufY+weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = hy_fluxBufZ+weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  else
     hy_fluxBufX = weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = +weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  endif

[hy_calcDivB]
definition=
 #ifdef SPARK_GLM
  @M loop_3d(blkLimits)
           divB = 0.0
 #if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/hy_del(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/hy_del(JAXIS)
 #if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/hy_del(KAXIS)
 #endif
 #endif
           Uin(DIVB_VAR,i,j,k) = divB
   @M loop_end_3d
 #endif


[hy_fill_geom]
definition=
           @M hy_map_geom
           call Grid_getCellFaceAreas(IAXIS,level,loGC,hiGC,hy_farea)
           call Grid_getCellVolumes(level,loGC,hiGC,hy_cvol)
           call Grid_getCellCoords(IAXIS, CENTER, level, loGC, hiGC, hy_xCenter)
           call Grid_getCellCoords(IAXIS, LEFT_EDGE, level, loGC, hiGC, hy_xLeft)
           call Grid_getCellCoords(IAXIS, RIGHT_EDGE, level, loGC, hiGC, hy_xRight)
           call Grid_getCellCoords(JAXIS, CENTER, level, loGC, hiGC, hy_yCenter)
           call Grid_getCellCoords(KAXIS, CENTER, level, loGC, hiGC, hy_zCenter)


[hy_release_geom]
definition=
              nullify(hy_xCenter)
              nullify(hy_xLeft)
              nullify(hy_xRight)
              nullify(hy_farea)
              nullify(hy_cvol)
	      nullify(hy_yCenter)
              nullify(hy_zCenter)

[hy_setRope]
args=ix,jx,kx
definition=
  hy_rope(HY_DENS,i,j,k) = hy_starState(DENS_VAR,ix,jx,kx)
  hy_rope(HY_VELX,i,j,k) = hy_starState(VELX_VAR,ix,jx,kx)
  hy_rope(HY_VELY,i,j,k) = hy_starState(VELY_VAR,ix,jx,kx)
  hy_rope(HY_VELZ,i,j,k) = hy_starState(VELZ_VAR,ix,jx,kx)
  hy_rope(HY_PRES,i,j,k) = hy_starState(PRES_VAR,ix,jx,kx)
  hy_rope(HY_GAMC,i,j,k) = hy_starState(GAMC_VAR,ix,jx,kx)
  hy_rope(HY_RHOE,i,j,k) = hy_starState(DENS_VAR,ix,jx,kx)*hy_starState(EINT_VAR,ix,jx,kx)
 #ifdef SPARK_GLM
  hy_rope(HY_MAGX,i,j,k) = hy_starState(MAGX_VAR,ix,jx,kx)
  hy_rope(HY_MAGY,i,j,k) = hy_starState(MAGY_VAR,ix,jx,kx)
  hy_rope(HY_MAGZ,i,j,k) = hy_starState(MAGZ_VAR,ix,jx,kx)
  hy_rope(HY_PSIB,i,j,k) = hy_starState(PSIB_VAR,ix,jx,kx)
 #endif
 #if NSPECIES+NMASS_SCALARS>0
     do n=SPECIES_BEGIN, MASS_SCALARS_END
        hy_rope(HY_NUM_VARS+1+n-SPECIES_BEGIN,i,j,k)    = hy_starState(n,ix,jx,kx)
     enddo
 #endif
 #ifdef GRAVITY
 #ifdef GPOT_VAR
   hy_grv(i,j,k) = hy_starState(GPOT_VAR,ix,jx,kx)
 #else
    hy_grv(i,j,k) = hy_grav(IAXIS,ix,jx,kx)
 #endif
 #endif
 #ifdef SHOK_VAR
     hy_shck(i,j,k) = hy_starState(SHOK_VAR,ix,jx,kx)
 #else
      hy_shck(i,j,k) = 0.0
 #endif
      hy_flat(i,j,k) = hy_flat3d(ix,jx,kx)


[hy_recon_declare]
definition=
  real :: invSumAlpha
  real, dimension(3) :: W5p, W5m, betaWeno, Alpha5, omega
  real :: mags, betaSum
  !! Set WENO5 coefficients once and for all
  !u_{1,i+1/2}= 2/6*u_{i-2} -7/6*u_{i-1} +11/6*u_{i}
  real, dimension(3), parameter :: coeff1p1(1:3) = (/ 2./6., -7./6., 11./6./)
  !u_{2,i+1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1p2(1:3) = (/-1./6.,  5./6.,  2./6./)
  !u_{3,i+1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3), parameter :: coeff1p3(1:3) = (/ 2./6.,  5./6., -1./6./)
  !(gamma1,gamma2,gamma3)
  real, dimension(3), parameter :: coeff2p(1:3)   = (/0.1, 0.6, 0.3/)
  !u_{1,i-1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1m1(1:3) = (/-1./6.,  5./6.,  2./6./)
  !u_{2,i-1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3), parameter :: coeff1m2(1:3) = (/ 2./6.,  5./6., -1./6./)
  !u_{3,i-1/2}=11/6*u_{i-2} -7/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1m3(1:3) = (/ 11./6.,-7./6.,  2./6./)
  !(gamma1,gamma2,gamma3)
  real, dimension(3), parameter :: coeff2m(1:3)   = (/0.3, 0.6, 0.1/)
  
  real, parameter :: epsilon = 1.e-36
  real, parameter :: n13o12 = 13./12.


[hy_recon]
definition=
  W5p(1) = coeff1p1(1)*hy_rope(v,i-2,j,k) + coeff1p1(2)*hy_rope(v,i-1,j,k) + coeff1p1(3)*hy_rope(v,i+0,j,k)
  W5p(2) = coeff1p2(1)*hy_rope(v,i-1,j,k) + coeff1p2(2)*hy_rope(v,i+0,j,k)   + coeff1p2(3)*hy_rope(v,i+1,j,k)
  W5p(3) = coeff1p3(1)*hy_rope(v,i+0,j,k)   + coeff1p3(2)*hy_rope(v,i+1,j,k) + coeff1p3(3)*hy_rope(v,i+2,j,k)
  !!  
  !! Calculate interface values at i-1/2
  W5m(1) = coeff1m1(1)*hy_rope(v,i-2,j,k) + coeff1m1(2)*hy_rope(v,i-1,j,k) + coeff1m1(3)*hy_rope(v,i+0,j,k)
  W5m(2) = coeff1m2(1)*hy_rope(v,i-1,j,k) + coeff1m2(2)*hy_rope(v,i+0,j,k)   + coeff1m2(3)*hy_rope(v,i+1,j,k)
  W5m(3) = coeff1m3(1)*hy_rope(v,i+0,j,k)   + coeff1m3(2)*hy_rope(v,i+1,j,k) + coeff1m3(3)*hy_rope(v,i+2,j,k)
  !!
  !! Calculate smoothness indicators at i+1/2
  betaWeno(1) = n13o12*(hy_rope(v,i-2,j,k) - 2.*hy_rope(v,i-1,j,k) +    hy_rope(v,i+0,j,k)  )**2 &
       +            0.25*(hy_rope(v,i-2,j,k) - 4.*hy_rope(v,i-1,j,k) + 3.*hy_rope(v,i,j,k)  )**2
  betaWeno(2) = n13o12*(hy_rope(v,i-1,j,k) - 2.*hy_rope(v,i,j,k)   +    hy_rope(v,i+1,j,k))**2 &
       +            0.25*(hy_rope(v,i-1,j,k)                      -    hy_rope(v,i+1,j,k))**2
  betaWeno(3) = n13o12*(hy_rope(v,i,j,k)   - 2.*hy_rope(v,i+1,j,k) +    hy_rope(v,i+2,j,k))**2 &
       +            0.25*(3.*hy_rope(v,i,j,k)- 4.*hy_rope(v,i+1,j,k) +    hy_rope(v,i+2,j,k))**2
  !!
  !! Use problem-adaptive epsilong as in Tchekovskoy7, A3
  ! This does not seem to work with the WENO-Z indicators of Borges+08
  ! mags(v) = hy_rope(@M ind_m(2))**2 + hy_rope(@M ind_m(1))**2 + hy_rope(@M ind_p(0))**2 &
  !      + hy_rope(@M ind_p(1))**2 + hy_rope(@M ind_p(2))**2
  ! betaWeno(1) = betaWeno(1) + epsilon*mags(v) + TINY(1.0)
  ! betaWeno(2) = betaWeno(2) + epsilon*mags(v) + TINY(1.0)
  ! betaWeno(3) = betaWeno(3) + epsilon*mags(v) + TINY(1.0)
  !!
  !! This is WENO-Zv this is very similar to weno5 with wenoExp=1
  Alpha5(1) = coeff2p(1)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(1)+epsilon)))
  Alpha5(2) = coeff2p(2)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(2)+epsilon)))
  Alpha5(3) = coeff2p(3)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(3)+epsilon)))
  !!
  !! Normalize weights at i+1/2
  invSumAlpha = 1./(Alpha5(1)+Alpha5(2)+Alpha5(3))
  omega(1)  = Alpha5(1)*invSumAlpha
  omega(2)  = Alpha5(2)*invSumAlpha
  omega(3)  = Alpha5(3)*invSumAlpha
  !!
  !! Compute interface value at i+1/2
  hy_uPlus(v ,i,j,k)  = omega(1)*W5p(1) + omega(2)*W5p(2) + omega(3)*W5p(3)
  !! Apply hy_flattening
  hy_uPlus(v ,i,j,k) = hy_flat(i,j,k)*hy_uPlus(v ,i,j,k) + (1.-hy_flat(i,j,k))*hy_rope(v,i ,j,k)
  !!
  !! Now move on to i-1/2
  !! This is WENO-Z
  Alpha5(1) = coeff2m(1)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(1)+epsilon)))
  Alpha5(2) = coeff2m(2)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(2)+epsilon)))
  Alpha5(3) = coeff2m(3)*(1.+(abs(betaWeno(1)-betaWeno(3))/(betaWeno(3)+epsilon)))
  !!
  !! Normalize weights at i-1/2
  invSumAlpha = 1./(Alpha5(1)+Alpha5(2)+Alpha5(3))
  omega(1)  = Alpha5(1)*invSumAlpha
  omega(2)  = Alpha5(2)*invSumAlpha
  omega(3)  = Alpha5(3)*invSumAlpha
  !!
  !! Compute interface value at i-1/2
  hy_uMinus(v ,i,j,k) = omega(1)*W5m(1) + omega(2)*W5m(2) + omega(3)*W5m(3)
  !! Apply hy_flattening
  hy_uMinus(v ,i,j,k) = hy_flat(i,j,k)*hy_uMinus(v ,i,j,k) + (1.-hy_flat(i,j,k))*hy_rope(v, i ,j,k)
  !! Check for monotonicity
  if ( (hy_uPlus(v ,i,j,k)-hy_rope(v, i ,j,k))*(hy_rope(v, i ,j,k)-hy_uMinus(v ,i,j,k)) <= 0. ) then
     hy_uPlus(v ,i,j,k)  = hy_rope(v, i ,j,k)
     hy_uMinus(v ,i,j,k) = hy_rope(v, i ,j,k)
  end if


[hy_riemann_declare]
definition=
  real:: speed
  real :: SL,SR,cfL,cfR,aL2,aR2,velNL,velNR
  real :: dStarL,dStarR,totalPresL,totalPresR
  real :: BxStar,ByStar,BzStar,Bn_hll,pStar,qStar
  real :: denomL,denomR,numerL,numerR
  real, dimension(HY_NUM_FLUX) :: UL,UR,Uhll,UCstarR,UCstarL
  real, dimension(HY_NUM_FLUX) :: FL,FR
  real :: magBL2,magBR2,magNL,magNR
  real :: Bn_glm, Psi_glm
  real,pointer,dimension(:) :: VL, VR, Fstar


[hy_riemann]
definition=
    ! Set no error to begin with
  ierr = 0
  !!
  ! Normal velocity
  velNL = VL(HY_VELX+dir-1)
  velNR = VR(HY_VELX+dir-1)
  !!
  ! Set sound speed
  aL2   = VL(HY_GAMC)*VL(HY_PRES)/VL(HY_DENS)
  aR2   = VR(HY_GAMC)*VR(HY_PRES)/VR(HY_DENS)
  !!
  ! Set zero magnetic quantities by default for hydro
  magNL = 0.
  magNR = 0.
 #ifdef SPARK_GLM /* compute additional MHD waves */
  ! Reset the left and right states for the GLM evolution equations
  ! This yields the exact solution for the fluxes of the 2x2 lienar GLM system
  ! See Mignone & Tzeferacos 2010, sec. 3.2
  Bn_glm  = 0.5*(VL(HY_MAGX+dir-1)+VR(HY_MAGX+dir-1)) - 0.5/hy_C_hyp*(VR(HY_PSIB) - VL(HY_PSIB))
  Psi_glm = 0.5*(VL(HY_PSIB)+VR(HY_PSIB)) - 0.5*hy_C_hyp*(VR(HY_MAGX+dir-1)-VL(HY_MAGX+dir-1))
  magNL = VL(HY_MAGX+dir-1)
  magNR = VR(HY_MAGX+dir-1)
  magBL2= dot_product(VL(HY_MAGX:HY_MAGZ),VL(HY_MAGX:HY_MAGZ))/VL(HY_DENS)
  magBR2= dot_product(VR(HY_MAGX:HY_MAGZ),VR(HY_MAGX:HY_MAGZ))/VR(HY_DENS)
 #endif
  !!
  ! Check unphysical negativity
  if ((VL(HY_DENS) < hy_tiny .and. VL(HY_DENS) > 0.) .or. &
       (VR(HY_DENS) < hy_tiny .and. VR(HY_DENS) > 0.) .or. &
       (VL(HY_PRES) < hy_tiny .and. VL(HY_PRES) > 0.) .or. &
       (VR(HY_PRES) < hy_tiny .and. VR(HY_PRES) > 0.)) then
     ! This could be vacuum limit. We return with zero flux.
     Fstar = 0.
     return
  elseif (aL2 < 0. .or. aR2 < 0.) then
     ierr = 1
     return
  endif
  !!
  cfL = sqrt(aL2)
  cfR = sqrt(aR2)
 #ifdef SPARK_GLM
  cfL = sqrt(0.5*(aL2 + magBL2 + sqrt((aL2 + magBL2 )**2 - 4.*aL2*magNL*magNL/VL(HY_DENS))))
  cfR = sqrt(0.5*(aR2 + magBR2 + sqrt((aR2 + magBR2 )**2 - 4.*aR2*magNR*magNR/VR(HY_DENS))))
 #endif
  !!
  ! Get left/right going fastest wave speeds SL & SR for the left and right states
  ! by S. F. Davis, SIAM J. Sci. Stat, Comput., 9(1988) 445.
  ! Also see Miyoshi, Kusano, JCP, 208 (2005)
  SL = min(velNL - cfL, velNR - cfR)
  SR = max(velNL + cfL, velNR + cfR)
  !!
  ! Output maximum local wave speed for dt calculation
  speed = max(abs(SL),abs(SR))
  !!
  ! Total pressure
  totalPresL = VL(HY_PRES)
  totalPresR = VR(HY_PRES)
 #ifdef SPARK_GLM /* for MHD */
  totalPresL = totalPresL + 0.5*dot_product(VL(HY_MAGX:HY_MAGZ),VL(HY_MAGX:HY_MAGZ))
  totalPresR = totalPresR + 0.5*dot_product(VR(HY_MAGX:HY_MAGZ),VR(HY_MAGX:HY_MAGZ))
 #endif
  !!
  ! Convert primitive variables to conservative variables
  !!!*** We need to think about whether this shoud be extracted out and done on the whole block
  !! 
  @M hy_prim2con(VL,UL)
  @M hy_prim2con(VR,UR)
  @M hy_prim2flx(dir,VL,FL)
  @M hy_prim2flx(dir,VR,FR)
  !!
  ! Get HLL states for later use
  if (SL > 0.) then
     Uhll = UL
  elseif ((SL <= 0.) .and. (SR >= 0.)) then
     Uhll = (SR*UR - SL*UL - FR + FL)/(SR - SL)
     !! Pretty sure the following is not need for pressure already in momentum
     !! fluxes (done in hy_prim2flx). I.e., fP = 1.0
     !  Uhll(HY_DENS+dir) = Uhll(HY_DENS+dir) + &
     !       (  totalPresL - totalPresR  )/(SR - SL) * (1.0-fP)
  else
     Uhll = UR
  endif
  !!
 #ifdef SPARK_GLM /* for MHD */
  ! Calculate intermediate states --------------
  Bn_hll = Uhll(HY_FMGX+dir-1) !=(SR*magNR-SL*magNL)/(SR-SL)
  BxStar = Uhll(HY_FMGX)       !BxStarL = BxStarR = BxHLL
  ByStar = Uhll(HY_FMGY)       !ByStarL = ByStarR = ByHLL
  BzStar = Uhll(HY_FMGZ)       !BzStarL = BzStarR = BzHLL
 #endif
  !!
  ! (1) Normal velocity component
  ! qStarL = qStarR = qStar
  qStar=(VR(HY_DENS)*velNR*(SR-velNR) &
       - VL(HY_DENS)*velNL*(SL-velNL)  &
       + totalPresL - totalPresR       &
       - magNL**2   + magNR**2)
  ! print*, (VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))
  qStar = qStar/(VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))
  !!
  ! Convenient parameters
  numerL = SL-velNL
  denomL = SL-qStar ! I believe this could be made an inverse to save FLOPS
  numerR = SR-velNR
  denomR = SR-qStar
  !!
  ! (2) Total pressure in the star region
  ! pStarL = pStarR = pStar
  pStar = VL(HY_DENS)*numerL*(qStar-velNL)+totalPresL
 #ifdef SPARK_GLM /* for MHD */
  pStar = pStar - magNL**2 + Bn_hll**2
 #endif
 !!
  ! (3) Density
  dStarL = UL(HY_MASS)*numerL/denomL
  dStarR = UR(HY_MASS)*numerR/denomR
  !!
  ! (4) Conserved variables in the two-state (left & right) star regions
  UCstarL(HY_MASS)   = dStarL
  UCstarL(HY_ENER)   = UL(HY_ENER)*numerL/denomL + &
       ((pStar*qStar - totalPresL*velNL))/denomL
  !!
  UCstarR(HY_MASS)   = dStarR
  UCstarR(HY_ENER)   = UR(HY_ENER)*numerR/denomR + &
       ((pStar*qStar - totalPresR*velNR))/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
  UCstarL(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarL(HY_ENER) = UCstarL(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNL*dot_product(VL(HY_MAGX:HY_MAGZ),  VL(HY_VELX:HY_VELZ)))/denomL
  !!
  UCstarR(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarR(HY_ENER) = UCstarR(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNR*dot_product(VR(HY_MAGX:HY_MAGZ),  VR(HY_VELX:HY_VELZ)))/denomR
 #endif
  !!
  select case (dir)
  case (IAXIS)
     UCstarL(HY_XMOM) = dStarL*qStar
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL
  !!
     UCstarR(HY_XMOM) = dStarR*qStar
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BxStar*ByStar-VL(HY_MAGX)*VL(HY_MAGY))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (BxStar*BzStar-VL(HY_MAGX)*VL(HY_MAGZ))/denomL
  !!
     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BxStar*ByStar-VR(HY_MAGX)*VR(HY_MAGY))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (BxStar*BzStar-VR(HY_MAGX)*VR(HY_MAGZ))/denomR
 #endif
  !!
  case (JAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = dStarL*qStar
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL
  !!
     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = dStarR*qStar
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (ByStar*BxStar-VL(HY_MAGY)*VL(HY_MAGX))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (ByStar*BzStar-VL(HY_MAGY)*VL(HY_MAGZ))/denomL
  !!
     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (ByStar*BxStar-VR(HY_MAGY)*VR(HY_MAGX))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (ByStar*BzStar-VR(HY_MAGY)*VR(HY_MAGZ))/denomR
 #endif
   !!
  case (KAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = dStarL*qStar
  !!
     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = dStarR*qStar
  !!
 #ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (BzStar*BxStar-VL(HY_MAGZ)*VL(HY_MAGX))/denomL
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BzStar*ByStar-VL(HY_MAGZ)*VL(HY_MAGY))/denomL
  !!
     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (BzStar*BxStar-VR(HY_MAGZ)*VR(HY_MAGX))/denomR
     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BzStar*ByStar-VR(HY_MAGZ)*VR(HY_MAGY))/denomR
 #endif
  end select
  !!
  !1
  ! End of calculating HLLC intermediate states ---------------------------
  !!
  ! (5) Finally, calculate HLLC fluxes
  if (SL >= 0.) then
     Fstar = FL
  elseif ((SL < 0.).and. (qStar >= 0.)) then
     Fstar = FL + SL*(UCstarL - UL)
  elseif ((qStar <0.) .and. (SR >= 0.)) then
     Fstar = FR + SR*(UCstarR - UR)
  else
     Fstar = FR
  endif
  !!
  !! The following are the HLLE fluxes.
  if (hy_hybridRiemann .AND. inShock) then
     if (SL > 0.) then
        Fstar = FL
     elseif (SR < 0.) then
        Fstar = FR
     else !if ((SL <= 0.) .and. (SR >= 0.)) then
        Fstar = (SR*FL - SL*FR + SR*SL*(UR - UL))/(SR - SL)
     endif
  end if
  !!
 #ifdef SPARK_GLM
  ! The exact fluxes for the 2x2 GLM sub-system
  Fstar(HY_FMGX+dir-1) = Psi_glm
  Fstar(HY_FPSI) = hy_C_hyp*hy_C_hyp*Bn_glm
 #endif

[hy_prim2con]
args=V1,CU
definition=
  CU = 0.0
  !!
  u2 = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_VELX:HY_VELZ))
  B2 = 0.
 #ifdef SPARK_GLM
  B2 = dot_product(V1(HY_MAGX:HY_MAGZ),V1(HY_MAGX:HY_MAGZ))
  CU(HY_FMGX:HY_FMGZ) = V1(HY_MAGX:HY_MAGZ)
  CU(HY_FPSI) = V1(HY_PSIB)
 #endif
  !!
  CU(HY_MASS) = V1(HY_DENS)
  CU(HY_XMOM:HY_ZMOM) = V1(HY_DENS)*V1(HY_VELX:HY_VELZ)
  CU(HY_ENER) = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE) + 0.5*B2

[hy_prim2flx]
args=dir,V1,F1
definition=
   F1 = 0.0
   u2 = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_VELX:HY_VELZ))
   E   = 0.5*V1(HY_DENS)*u2 + V1(HY_RHOE)
   Ptot = V1(HY_PRES)
 #ifdef SPARK_GLM
   B2 = dot_product(V1(HY_MAGX:HY_MAGZ),V1(HY_MAGX:HY_MAGZ))
   UB = dot_product(V1(HY_VELX:HY_VELZ),V1(HY_MAGX:HY_MAGZ))
   ! We will NEED to check units. That could be a pain. #MHDbeNatural
   Ptot= Ptot + 0.5*B2
   E   = E + 0.5*B2
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGX)*V1(HY_MAGX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGX)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGX)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX) - V1(HY_MAGX)*UB
      F1(HY_FMGX) = 0.
      F1(HY_FMGY) = V1(HY_VELX)*V1(HY_MAGY)-V1(HY_VELY)*V1(HY_MAGX)
      F1(HY_FMGZ) = V1(HY_VELX)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGY)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGY)*V1(HY_MAGY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGY)*V1(HY_MAGZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY) - V1(HY_MAGY)*UB
      F1(HY_FMGX) = V1(HY_VELY)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGY)
      F1(HY_FMGY) = 0.
      F1(HY_FMGZ) = V1(HY_VELY)*V1(HY_MAGZ)-V1(HY_VELZ)*V1(HY_MAGY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) - V1(HY_MAGZ)*V1(HY_MAGX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) - V1(HY_MAGZ)*V1(HY_MAGY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) - V1(HY_MAGZ)*V1(HY_MAGZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ) - V1(HY_MAGZ)*UB
      F1(HY_FMGX) = V1(HY_VELZ)*V1(HY_MAGX) - V1(HY_VELX)*V1(HY_MAGZ)
      F1(HY_FMGY) = V1(HY_VELZ)*V1(HY_MAGY) - V1(HY_VELY)*V1(HY_MAGZ)
      F1(HY_FMGZ) = 0.
   end select
 #else
   select case(dir)
   case (IAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELX)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX) + Ptot
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELX)
   case (JAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELY)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY) + Ptot
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ)
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELY)
   case (KAXIS)
      F1(HY_MASS) = V1(HY_DENS)*V1(HY_VELZ)
      F1(HY_XMOM) = F1(HY_MASS)*V1(HY_VELX)
      F1(HY_YMOM) = F1(HY_MASS)*V1(HY_VELY)
      F1(HY_ZMOM) = F1(HY_MASS)*V1(HY_VELZ) + Ptot
      F1(HY_ENER) = (E + Ptot)*V1(HY_VELZ)
   end select
 #endif
  

  
