

[hy_declare_scratch]
definition =
    real,save, allocatable, dimension(:), target :: fullblk,tranblk, uplus, uminus, grv, shk, utmp,grav
    real,save, allocatable, dimension(:), target :: flux,flx,fly,flz,flxbx,flxby,flxbz, flat, flat3d
    real, save, allocatable, dimension(:), target :: xcenter, xright, xleft, ycenter, zcenter, area, vol 
    real, save, pointer, dimension(:,:,:,:) :: hy_starState, hy_tmpState, hy_transBlk, hy_uplus, hy_uminus
    real, save, pointer, dimension(:,:,:,:) :: hy_flx,hy_fly,hy_flz,hy_flxbx,hy_flxby,hy_flxbz,hy_flux
    real, save, pointer, dimension(:,:,:) :: hy_flat, hy_flat3d, hy_grv, hy_grav,hy_shk, hy_area, hy_vol
    real, save, pointer, dimension(:) :: hy_xCenter, hy_yCenter, hy_zCenter, hy_xRight, hy_xLeft


[hy_alloc_scratch]
args = sizex,sizey,sizez
definition =
   allocate(fullblk(NUNK_VARS*sizex*sizey*sizez))
   allocate(utmp(NUNK_VARS*sizex*sizey*sizez))	
   allocate(uplus(NRECON*sizex*sizey*sizez))
   allocate(tranblk(NRECON*sizex*sizey*sizez))   
   allocate(uminus(NRECON*sizex*sizey*sizez))
   allocate(grv(sizex*sizey*sizez))
   allocate(grav(sizex*sizey*sizez))   
   allocate(shk(sizex*sizey*sizez))
   allocate(flux(NFLUXES*sizex*sizey*sizez))   
   allocate(flx(NFLUXES*(sizex+1)*sizey*sizez))
   allocate(fly(NFLUXES*sizex*(sizey+1)*sizez))
   allocate(flz(NFLUXES*sizex*sizey*(sizez+1)))   
   allocate(flxbx(NFLUXES,(sizex+1)*sizey*sizez))
   allocate(flxby(NFLUXES,sizex*(sizey+1)*sizez))
   allocate(flxbz(NFLUXES,sizex*sizey*(sizez+1)))   
   allocate(flat3d(sizex*sizey*sizez))
   allocate(flat(sizex*sizey*sizez))
   !$omp target enter data map(alloc:flat,shk,tranblk,uminus,uplus,grv,flux)
   if(hy_geometry /= CARTESIAN) then
      allocate(xcenter(sizex))
      allocate(xleft(sizex))
      allocate(xright(sizex))
      allocate(ycenter(sizey))
      allocate(zcenter(sizez))
      allocate(area(sizex*sizey*sizez))
      allocate(vol(sizex*sizey*sizez))      
    end if


[hy_map_scratch]
definition = 
   hy_starState(NUNK_VARS, @M bounds_3d(blkLimitsGC)) => fullblk
   hy_tmpState(NUNK_VARS, @M bounds_3d(blkLimitsGC)) => utmp   
   hy_grav( @M bounds_3d(blkLimitsGC)) => grav   
   hy_flx(NFLUXES, @M bounds_3d_plus(blkLimitsGC,1,0,0)) => flx
   hy_fly(NFLUXES, @M bounds_3d_plus(blkLimitsGC,0,1,0)) => fly
   hy_flz(NFLUXES, @M bounds_3d_plus(blkLimitsGC,0,0,1)) => flz
   hy_flxbx(NFLUXES, @M bounds_3d_plus(blkLimits,1,0,0)) => flxbx
   hy_flxby(NFLUXES, @M bounds_3d_plus(blkLimits,0,1,0)) => flxby
decl   hy_flxbz(NFLUXES, @M bounds_3d_plus(blkLimits,0,0,1)) => flxbz
   if(hy_geometry /= CARTESIAN) then
       hy_xCenter(bounds_i(blkLimitsGC))=>xcenter
       hy_xLeft(bounds_i(blkLimitsGC))=>xleft
       hy_xRight(bounds_i(blkLimitsGC))=>xright
       hy_yCenter(bounds_j(blkLimitsGC))=>ycenter
       hy_zCenter(bounds_k(blkLimitsGC))=>zcenter            
    end if

[hy_map_dir_scratch]
args = limits
definition = 
   hy_transBlk(NRECON,@M bounds_3d(limits)) => tranblk
   hy_uplus(NRECON, @M bounds_3d(limits)) => uplus
   hy_uminus(NRECON, @M bounds_3d(limits)) => uminus
   hy_grv(@M bounds_3d(limits)) => grv
   hy_shk(@M bounds_3d(limits)) => shk
   hy_flat(@M bounds_3d(limits)) => flat   
   hy_flux(NFLUXES, @M bounds_3d(limits)) => flux

[hy_demap_scratch]
   nullify(hy_starState)
   nullify(hy_tmpState)
   nullify(hy_flux)
   nullify(hy_grav)
   nullify(hy_flx)
   nullify(hy_fly)
   nullify(hy_flz)
   nullify(hy_flxbx)
   nullify(hy_flxby)
   nullify(hy_flxbz)
   if(hy_geometry /= CARTESIAN) then
     nullify(hy_xCenter)
     nullify(hy_xLeft)
     nullify(hy_xRight)
     nullify(hy_yCenter)
     nullify(hy_zCenter)
    end if

[hy_demap_dir_scratch]
definition =
   nullify(hy_transBlk)
   nullify(hy_uplus)
   nullify(hy_uminus)
   nullify(hy_grv)
   nullify(hy_shk)
   nullify(hy_flat)


[hy_dealloc_scratch]
definition =
   deallocate(fullblk)
   deallocate(utmp)
   deallocate(uplus)
   deallocate(tranblk)
   deallocate(uminus)
   deallocate(grv)
   deallocate(grav)   
   deallocate(shk)
   deallocate(flux)
   deallocate(flx)
   deallocate(fly)
   deallocate(flz)
   deallocate(flxbx)
   deallocate(flxby)
   deallocate(flxbz)
   deallocate(flat3d)
   deallocate(flat)
   if(hy_geometry /= CARTESIAN) then
      deallocate(xcenter)
      deallocate(xleft)
      deallocate(xright)
      deallocate(ycenter)
      deallocate(zcenter)
      deallocate(ares)
      deallocate(vol)      
    end if
