
[hy_mapflxGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,1,0,0)

[hy_mapflyGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,1,0)

[hy_mapflzGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,0,1)

[hy_mapflx]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)

[hy_mapfly]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0)

[hy_mapflz]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1)

[hy_mapFluxBuf]
definition=
   hy_fluxBufX(@M hy_mapflx)=>hya_fluxBufX
   hy_fluxBufY(@M hy_mapfly)=>hya_fluxBufY
   hy_fluxBufZ(@M hy_mapflz)=>hya_fluxBufZ

[hy_nullFluxBuf]
definition=
   nullify(hy_fluxBufX)
   nullify(hy_fluxBufY)
   nullify(hy_fluxBufZ)

[hy_map_fl]
definition=
   hy_flx(@M hy_mapflxGC)=>hya_flx
   hy_fly(@M hy_mapflyGC)=>hya_fly
   hy_flz(@M hy_mapflzGC)=>hya_flz

[hy_nullFl]
definition=
   nullify(hy_flx)
   nullify(hy_fly)
   nullify(hy_flz)

[hy_setLims]
args=ng
definition=
  limits = blkLimits
  do i=1,NDIM
     limits(LOW ,i) = blkLimits(LOW ,i) - ng
     limits(HIGH,i) = blkLimits(HIGH,i) + ng
  end do

[hy_updateState]
definition=
 #ifdef GPOT_VAR
  ! First reset GPOT_VAR.
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       Uin(GPOT_VAR,@M bounds_3d(blkLimits))
 #endif
  Uin(:,@M bounds_3d(blkLimits)) = hy_starState(:,@M bounds_3d(blkLimits))

[hy_saveState]
definition=
  ! update temp vars with solution data
  hy_starState(:,@M bounds_3d(blkLimitsGC))=Uin(:,@M bounds_3d(blkLimitsGC))
  hy_tmpState(:,@M bounds_3d(blkLimitsGC))=Uin(:,@M bounds_3d(blkLimitsGC))  


[hy_addFluxes]
definition=
  if (addFlux_array(stage)) then
     hy_fluxBufX = hy_fluxBufX+weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = hy_fluxBufY+weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = hy_fluxBufZ+weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  else
     hy_fluxBufX = weights(stage)*hy_flx(1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = +weights(stage)*hy_fly(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = weights(stage)*hy_flz(1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1))
  endif

[hy_calcDivB]
definition=
 #ifdef SPARK_GLM
  @M loop_3d(blkLimits)
           divB = 0.0
 #if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/hy_del(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/hy_del(JAXIS)
 #if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/hy_del(KAXIS)
 #endif
 #endif
           Uin(DIVB_VAR,i,j,k) = divB
   @M loop_end_3d
 #endif

[hy_allocate_geom]
definition=
           allocate(hy_farea(xLoGC:xHiGC,yLoGC:yHiGC,zLoGC:zHiGC))
           allocate(hy_cvol(xLoGC:xHiGC,yLoGC:yHiGC,zLoGC:zHiGC))
           allocate(hy_xCenter(xLoGC:xHiGC))
           allocate(hy_xLeft(xLoGC:xHiGC))
           allocate(hy_xRight(xLoGC:xHiGC))
           allocate(hy_yCenter(yLoGC:yHiGC))
           allocate(hy_zCenter(zLoGC:zHiGC))


[hy_fill_geom]
definition=
           @M hy_allocate_geom
           call Grid_getCellFaceAreas(IAXIS,level,loGC,hiGC,hy_farea)
           call Grid_getCellVolumes(level,loGC,hiGC,hy_cvol)
           call Grid_getCellCoords(IAXIS, CENTER, level, loGC, hiGC, hy_xCenter)
           call Grid_getCellCoords(IAXIS, LEFT_EDGE, level, loGC, hiGC, hy_xLeft)
           call Grid_getCellCoords(IAXIS, RIGHT_EDGE, level, loGC, hiGC, hy_xRight)
           call Grid_getCellCoords(JAXIS, CENTER, level, loGC, hiGC, hy_yCenter)
           call Grid_getCellCoords(KAXIS, CENTER, level, loGC, hiGC, hy_zCenter)


[hy_release_geom]
definition=
              deallocate(hy_xCenter)
              deallocate(hy_xLeft)
              deallocate(hy_xRight)
              deallocate(hy_farea)
              deallocate(hy_cvol)
	      deallocate(hy_yCenter)
              deallocate(hy_zCenter)
 