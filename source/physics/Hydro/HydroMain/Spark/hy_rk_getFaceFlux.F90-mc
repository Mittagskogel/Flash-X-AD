!!****if* source/physics/Hydro/HydroMain/Spark/hy_rk_getFaceFlux
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!!  NAME
!!
!!  hy_rk_getFaceFlux
!!
!!  SYNOPSIS
!!
!!  call hy_rk_getFaceFlux ( integer(IN) :: blklimits(:,:),
!!                           integer(IN) :: blklimitsGC(:,:),
!!                           real(IN)    :: hy_del(:),
!!                           integer(IN) :: limits(:,:))
!!
!!  DESCRIPTION
!!  Initially stores grid data by 'pencils' (see subroutine setPencil() below),
!!  calls outside hy_reconstruction subroutine, calls outisde Riemann solver, and 
!!  ultimately yields face fluxes for relevant directions.  These fluxes are lastly 
!!  saved to the grid multifabs (AMReX) for later access.
!!
!!  ARGUMENTS
!!     blklimits,blkLimitsGC are the bounds of the block/tile
!!     hy_del are dx,dy,dz
!!     limits   sets limits of the fluxes.
!!
!!     Note this is a modified form typically yielded
!!     by blockDesc%limits b/c stage 1 of RK integration accounts for NSTENCIL 
!!     number of guard cells beyond the block interior.  Stage 2 only updates the 
!!    interior cells.
!!
!!***
!!NOVARIANTS
!!Reorder(4):hy_starState,hy_fl[xyz]

subroutine hy_rk_getFaceFlux (hy_starState,blklimits,blkLimitsGC, limits)
  use Hydro_data, ONLY : hy_threadWithinBlock,hy_smalldens, &
       hy_smallE, hy_smallpres, hy_smallX, hy_cvisc, hy_flattening
      
  use Hydro_data, ONLY : hya_grav, hya_flx, hya_fly, hya_flz, hya_flat3d 
  use Hydro_data, ONLY : hya_starState,hya_rope, hya_uPlus, hya_uMinus, hya_flat, hya_grv, &
       hya_shck, hya_flux
  use Hydro_data, ONLY : hy_del, hy_tiny, hy_hybridRiemann, hy_C_hyp
  use Hydro_data, ONLY : klim,lim,limgc,gCells, dir,stage
  use Timers_interface, ONLY : Timers_start, Timers_stop

  implicit none

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

  real,dimension(:,:,:,:),pointer ::hy_starState
  integer, intent(IN), dimension(LOW:HIGH,MDIM) :: limits, blkLimits, blkLimitsGC
  integer :: i,j,k, n, g, v,  ierr
  integer :: im1
  character(len = 2) :: dir_str
  real :: cvisc, VenerLo, VenerHi, accelM, accelP,dx
  integer :: s
  real :: spcSumInv
  real, dimension(NSPECIES) :: spc
  real  :: u2,E,B2,UB,Ptot

  logical :: inShock
!!  real, dimension(HY_NUM_VARS) :: VL, VR
  real :: rope(5)
  real,dimension(:,:,:,:),pointer::hy_rope, hy_uPlus, hy_uMinus,hy_flux,&
       hy_grav, hy_flx, hy_fly, hy_flz
  real,dimension(:,:,:),pointer :: hy_flat,hy_shck,hy_grv,hy_flat3d
  @M hy_recon_declare
  @M hy_riemann_declare

  logical :: offload = .false.

#ifdef OMP_OL
  offload = .true.
#endif

  @M hy_OMP_TARGET_enter_data(to, [coeff1p1, coeff1p2, coeff1p3, coeff1m1, coeff1m2, coeff1m3, linWp, linWm])
  hy_grav(1:MDIM,@M bounds_3d(blkLimitsGC))=>hya_grav

  hy_flat3d(@M bounds_3d(blkLimitsGC))=>hya_flat3d

  @M hy_map_fl
  
  @M hy_OMP_TARGET_enter_data(alloc, [lim, klim, limgc, stage, dir])
  if (hy_flattening) then
     ! AH: TODO: OpenMP for flattening
     call flattening(limits)
  else
     ! call Timers_start("hy_flat3d")
     !! TODO: Set this once for both rk steps.

     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_flat3d_shared &
     @M hy_DIR_TARGET_map(to, [blkLimitsGC])
     @M loop_3d(blkLimitsGC)
              hy_flat3d(i,j,k) = 1.0
     @M loop_end_3d

     ! call Timers_stop("hy_flat3d")
  end if
  


  !  Begin loop over zones

  do dir = 1, NDIM
     call Timers_start("prepare_scratch")
     @M hy_OMP_TARGET_update_to([lim, limgc, klim, dir, stage])

     hy_flux(1:NFLUXES,@M hy_bounds(limgc))=>hya_flux
     hy_flat(@M hy_bounds(limgc))=>hya_flat
     hy_shck(@M hy_bounds(limgc))=>hya_shck
     hy_grv(@M hy_bounds(limgc))=>hya_grv
     
     hy_rope(1:NRECON,@M hy_bounds(limgc)) => hya_rope
     hy_uPlus(1:NRECON,@M hy_bounds(limgc)) => hya_uPlus
     hy_uMinus(1:NRECON,@M hy_bounds(limgc)) => hya_uMinus

     @M hy_OMP_TARGET_enter_data(alloc, [hy_flux, hy_flat, hy_shck, hy_grv, hy_rope, hy_uPlus, hy_uMinus])
     call Timers_stop("prepare_scratch")

     call Timers_start("setRope")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_setRope_private &
     @M hy_DIR_TARGET_setRope_shared
     @M hy_permute_loop(limgc, lim)
              if (dir == IAXIS) then
                 @M hy_setRope(i,j,k)
              else if (dir == JAXIS) then
                 @M hy_setRope(j,i,k)
              else if (dir == KAXIS) then
                 @M hy_setRope(j,k,i)
              endif
     @M hy_break_loop
     call Timers_stop("setRope")



     call Timers_start("recon")
     @M hy_DIR_TARGET_parallel_loop(4) &
     @M hy_DIR_TARGET_recon_private &
     @M hy_DIR_TARGET_recon_shared
     @M hy_inner_loop(klim)
          do v=1,NRECON
             @M hy_recon
          enddo
     @M hy_break_loop
     call Timers_stop("recon")

     call Timers_start("setrem")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_normalize_species_private &
     @M hy_DIR_TARGET_normalize_species_shared
     @M hy_inner_loop(klim)
              ! Limit and renormalize the species.
              @M hy_normalize_species( hy_uPlus )
              @M hy_normalize_species( hy_uMinus )
     @M hy_break_loop
     call Timers_stop("setrem")

     call Timers_start("riemann")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_riemann_private &
     @M hy_DIR_TARGET_riemann_shared
     @M hy_inner_loop_plus(lim,1,0,0)
              VL = hy_uPlus(1:HY_NUM_VARS,i-1,j,k)
              VR = hy_uMinus(1:HY_NUM_VARS,i,j,k) 
              inShock = any(hy_shck(i-1:i,j,k) /= 0.0)
              @M hy_riemann
              hy_flux(1:HY_NUM_FLUX,i,j,k) = Fstar(1:HY_NUM_FLUX)
     @M hy_break_loop
     call Timers_stop("riemann")

     call Timers_start("cvisc")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_avisc_private &
     @M hy_DIR_TARGET_avisc_shared
     @M hy_inner_loop_plus(lim,1,0,0)
              ! Add artificial viscosity for strong-shock capturing
              cvisc = hy_cvisc*max(-(hy_rope(HY_VELX+dir-1,i,j,k) - hy_rope(HY_VELX+dir-1,i-1,j,k)),0.)
              
              ! Construct minus and plus TOTAL energy densities
              ! Construct minus and plus TOTAL energy densities
              VenerLo = hy_rope(HY_DENS,i-1,j,k)*0.5*(dot_product(hy_rope(HY_VELX:HY_VELZ,i-1,j,k),hy_rope(HY_VELX:HY_VELZ,i-1,j,k)))&
                   + hy_rope(HY_RHOE,i-1,j,k)
              VenerHi = hy_rope(HY_DENS,i,j,k)*0.5*(dot_product(hy_rope(HY_VELX:HY_VELZ,i,j,k),hy_rope(HY_VELX:HY_VELZ,i,j,k)))&
                   + hy_rope(HY_RHOE,i,j,k)
              
              hy_flux(HY_MASS:HY_ENER,i,j,k) = &
                   hy_flux(HY_MASS:HY_ENER,i,j,k) &
                   +cvisc*(/hy_rope(HY_DENS,i-1,j,k)                 - hy_rope(HY_DENS,i,j,k)&
                   ,        hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELX,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELX,i,j,k)&
                   ,        hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELY,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELY,i,j,k)&
                   ,        hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELZ,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELZ,i,j,k)&
                   ,        VenerLo                         - VenerHi/)

              
#ifdef SPARK_GLM
              hy_flux(HY_FMGX:HY_FPSI,i,j,k) = &
                   hy_flux(HY_FMGX:HY_FPSI,i,j,k) &
                   +cvisc*(/hy_rope(HY_MAGX,i-1,j,k)                 - hy_rope(HY_MAGX,i,j,k)&
                   ,        hy_rope(HY_MAGY,i-1,j,k)                 - hy_rope(HY_MAGY,i,j,k)&
                   ,        hy_rope(HY_MAGZ,i-1,j,k)                 - hy_rope(HY_MAGZ,i,j,k)&
                   ,        hy_rope(HY_PSIB,i-1,j,k)                 - hy_rope(HY_PSIB,i,j,k)/)
#endif
              ! Here, we compute the species and mass scalar
              ! fluxes based on the density flux and the hy_reconstructed
              ! mass scalar interface values
              
              
#if NSPECIES+NMASS_SCALARS>0
              ! AH: TODO: Potentially make loop explicit
              if (hy_flux(HY_MASS ,i,j,k) > 0.) then
                 hy_flux(HY_NUM_FLUX+1:NFLUXES ,i,j,k) = hy_uPlus(HY_NUM_VARS+1:NRECON, i-1,j,k)*hy_flux(HY_MASS ,i,j,k)
              else
                 hy_flux(HY_NUM_FLUX+1:NFLUXES ,i,j,k) = hy_uMinus(HY_NUM_VARS+1:NRECON ,i,j,k)*hy_flux(HY_MASS ,i,j,k)
              end if
#endif
     @M hy_break_loop
     call Timers_stop("cvisc")

     call Timers_start("flux")
     ! ***************
     ! Fluxes computed for one face of this zone
     ! Save the fluxes
     ! ***************
     select case(dir)
     case(IAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(hy_flx) &
        @M hy_DIR_TARGET_map(from, [hy_flx])
        @M hy_inner_loop_plus(lim,1,0,0)
              do v = 1, NFLUXES
                 hy_flx(v,i,j,k) = hy_flux(v,i,j,k)
              end do
        @M hy_break_loop
     case (JAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(hy_fly) &
        @M hy_DIR_TARGET_map(from, [hy_fly])
        @M hy_inner_loop_plus(lim,1,0,0)
              do v = 1, NFLUXES
                 hy_fly(v,j,i,k) = hy_flux(v,i,j,k)
              end do
        @M hy_break_loop
     case (KAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(hy_flz) &
        @M hy_DIR_TARGET_map(from, [hy_flz])
        @M hy_inner_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              hy_flz(v,j,k,i) = hy_flux(v,i,j,k)
           end do
        @M hy_break_loop
     end select
     call Timers_stop("flux")
     @M hy_permute_loop_end
     !release pointers
     @M hy_OMP_TARGET_exit_data(release, [hy_flux, hy_rope, hy_uPlus, hy_uMinus, hy_flat, hy_shck, hy_grv])
     nullify(hy_flux)
     nullify(hy_rope)
     nullify(hy_uPlus)
     nullify(hy_uMinus)
     nullify(hy_flat)
     nullify(hy_shck)
     nullify(hy_grv)
     
     
  end do ! dir

  @M hy_OMP_TARGET_exit_data(release, [lim, klim, limgc, stage, dir])
  nullify(hy_grav)
  nullify(hy_flat3d)
  @M hy_nullFl
  
  
  
contains
  
  !!Set loop dimensions based on the direction of the pencil set
  
  !! the 'pencil' holds a 1D array of the solution data to be operated
  !! on.  It is unrolled this way so that all data that are needed for
  !! interpolation and flux calculation are truly contiguous in memory
  !! space.  And so that it all fits in cache at once...
  !! The maximum amount of calculation is done on these data prior to
  !! reseting the pencil data to a new ray through the block.
  !! If I were talented at ASCII art, I would make a diagram...
  
  
  !~ Flattening has not been tested yet in FLASH5, only 1D & 2D runs so far.
  subroutine flattening(limits)
    !! This follows Miller & Colella 2002
    implicit none
    integer, parameter :: kx = 1
    integer, parameter :: ky = K2D
    integer, parameter :: kz = K3D
    integer, intent(IN), dimension(LOW:HIGH,MDIM) :: limits
    !real, intent(OUT) :: hy_flat3d(GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC)
    !real :: hy_flatTilde(NDIM,GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC)
    real :: hy_flatTilde(NDIM,limits(LOW,IAXIS)-kx:limits(HIGH,IAXIS)+kx,&
         limits(LOW,JAXIS)-ky:limits(HIGH,JAXIS)+ky,&
         limits(LOW,KAXIS)-kz:limits(HIGH,KAXIS)+kz)
    real :: beta, Z
    real, parameter :: betaMin = 0.75, betaMax = 0.85
    real, parameter :: Zmin = 0.25, Zmax = 0.75
    integer :: i,j,k

    do k=limits(LOW,KAXIS)-kz, limits(HIGH,KAXIS)+kz
       do j=limits(LOW,JAXIS)-ky, limits(HIGH,JAXIS)+ky
          do i=limits(LOW,IAXIS)-kx, limits(HIGH,IAXIS)+kx
             !1e-99 used to be TINY(1.0) but that produced Seg Faults
             beta = abs(hy_starState(PRES_VAR,i+1,j,k)-hy_starState(PRES_VAR,i-1,j,k)) &
                  / max(1e-99, abs(hy_starState(PRES_VAR,i+2,j,k)-hy_starState(PRES_VAR,i-2,j,k)))
             Z    = abs(hy_starState(PRES_VAR,i+1,j,k)-hy_starState(PRES_VAR,i-1,j,k)) &
                  / (hy_starState(GAMC_VAR,i,j,k)*hy_starState(PRES_VAR,i,j,k))
             hy_flatTilde(IAXIS,i,j,k) = max(0.,min(1.,(betaMax-beta)/(betaMax-betaMin)))
             if (hy_starState(VELX_VAR,i+1,j,k)<hy_starState(VELX_VAR,i,j,k)) then
                hy_flatTilde(IAXIS,i,j,k) = max(hy_flatTilde(IAXIS,i,j,k), &
                     &                   min(1., (Zmax-Z)/(Zmax-Zmin)))
             else
                hy_flatTilde(IAXIS,i,j,k) = 1.0
             end if
#if NDIM>1
             beta = abs(hy_starState(PRES_VAR,i,j+1,k)-hy_starState(PRES_VAR,i,j-1,k)) &
                  / max(1.e-99,abs(hy_starState(PRES_VAR,i,j+2,k)-hy_starState(PRES_VAR,i,j-2,k)))
             Z    = abs(hy_starState(PRES_VAR,i,j+1,k)-hy_starState(PRES_VAR,i,j-1,k)) &
                  / (hy_starState(GAMC_VAR,i,j,k)*hy_starState(PRES_VAR,i,j,k))
             hy_flatTilde(JAXIS,i,j,k) = max(0.,min(1.,(betaMax-beta)/(betaMax-betaMin)))
             if (hy_starState(VELY_VAR,i,j+1,k)<hy_starState(VELY_VAR,i,j,k)) then
                hy_flatTilde(JAXIS,i,j,k) = max(hy_flatTilde(JAXIS,i,j,k), &
                     &                   min(1., (Zmax-Z)/(Zmax-Zmin)))
             else
                hy_flatTilde(JAXIS,i,j,k) = 1.0
             end if
#if NDIM==3
             beta = abs(hy_starState(PRES_VAR,i,j,k+1)-hy_starState(PRES_VAR,i,j,k-1)) &
                  / max(1.e-99,abs(hy_starState(PRES_VAR,i,j,k+2)-hy_starState(PRES_VAR,i,j,k-2)))
             Z    = abs(hy_starState(PRES_VAR,i,j,k+1)-hy_starState(PRES_VAR,i,j,k-1)) &
                  / (hy_starState(GAMC_VAR,i,j,k)*hy_starState(PRES_VAR,i,j,k))
             hy_flatTilde(KAXIS,i,j,k) = max(0.,min(1.,(betaMax-beta)/(betaMax-betaMin)))
             if (hy_starState(VELZ_VAR,i,j,k+1)<hy_starState(VELZ_VAR,i,j,k)) then
                hy_flatTilde(KAXIS,i,j,k) = max(hy_flatTilde(KAXIS,i,j,k), &
                     &                   min(1., (Zmax-Z)/(Zmax-Zmin)))
             else
                hy_flatTilde(KAXIS,i,j,k) = 1.0
             end if
#endif
#endif
          end do
       end do
    end do
    do k=limits(LOW,KAXIS)-kz, limits(HIGH,KAXIS)+kz
       do j=limits(LOW,JAXIS)-ky, limits(HIGH,JAXIS)+ky
          do i=limits(LOW,IAXIS)-kx, limits(HIGH,IAXIS)+kx
             hy_flat3d(i,j,k) = minval(hy_flatTilde(1:NDIM,i,j,k))
#ifdef FLAT_VAR
             hy_starState(FLAT_VAR,i,j,k) = hy_flat3d(i,j,k)
#endif
          end do
       end do
    end do
  end subroutine flattening
  
end subroutine hy_rk_getFaceFlux


