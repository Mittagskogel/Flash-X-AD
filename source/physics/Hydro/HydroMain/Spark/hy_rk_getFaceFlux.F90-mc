!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file

!> @ingroup HydroSpark
!!
!! @brief Computes interfacial fluxes through reconstruction and solving Riemann
!!
!! @details
!! The reconstruction method and Riemann Solver are implemented as macros,
!! so one can implement new reconstruction/Riemann solver by redefining
!! corresponding macros.
!!
!! @note
!! The index limits are determined by the input paramters @p limits and @p stage
!!
!! @param stage           Current RK stage
!! @param starState       Input solution data
!! @param flat3d          Flattening limiter
!! @param fl[x,y,z]       Output fluxes in [X,Y,Z] direction
!! @param limits          Index limits for each RK stages for updating solution
!! @param deltas          dx, dy, dz
!! @param scr_rope        Scratch space for saving input solution data
!! @param scr_flux        Scratch space for saving output flux data
!! @param scr_uPlus       Scratch space for saving Riemann state at plus (+) side
!! @param scr_uMinus      Scratch space for saving Riemann state at minus (-) side
!! @param loGC            Lower indices including guard cells
!<

!!VARIANTS(GPU): hy_rk_getFaceFlux
!!Reorder(4):starState,fl[xyz]
!!Reorder(4):scr_rope,scr_flux,scr_uPlus,scr_uMinus

!#define DISABLE_TRUNC_RECON
!#define DISABLE_TRUNC_RIEMANN
!#define EXCLUDE_RECON
!#define EXCLUDE_RIEMANN
#define TRUNC_FROM 64
#define TRUNC_TO_E 5
#define TRUNC_TO_M 13

module truncate_helpers
  implicit none
  interface
     function f__enzyme_truncate_mem_value(x, from, to_e, to_m) result(p_x) bind(c)
       use, intrinsic :: iso_c_binding, only: c_double, c_int
       implicit none

       ! double precision, intent(in) :: x
       ! integer, intent(in) :: from, to
       real(c_double), intent(in), value :: x
       integer(c_int), intent(in), value :: from, to_e, to_m
       double precision :: p_x
     end function f__enzyme_truncate_mem_value
  end interface

  interface
     function f__enzyme_expand_mem_value(x, from, to_e, to_m) result(p_x) bind(c)
       use, intrinsic :: iso_c_binding, only: c_double, c_int
       implicit none

       ! double precision, intent(in) :: x
       ! integer, intent(in) :: from, to
       real(c_double), intent(in), value :: x
       integer(c_int), intent(in), value :: from, to_e, to_m
       double precision :: p_x
     end function f__enzyme_expand_mem_value
  end interface

  interface
     function f_enzyme_reset_shadow_trace() result(count) bind(c)
       use, intrinsic :: iso_c_binding, only: c_long_long
       implicit none

       integer(c_long_long) :: count
     end function f_enzyme_reset_shadow_trace
  end interface

  interface
     subroutine enzyme_fprt_excl_trunc_start() bind(c)
       implicit none
     end subroutine enzyme_fprt_excl_trunc_start
  end interface

  interface
     subroutine enzyme_fprt_excl_trunc_end() bind(c)
       implicit none
     end subroutine enzyme_fprt_excl_trunc_end
  end interface

  public :: truncate_0d, truncate_1d, truncate_2d, truncate_3d, truncate_4d
  public :: f__enzyme_truncate_mem_func_hy_recon
  public :: f__enzyme_truncate_mem_func_hy_riemann
  contains
    subroutine truncate_1d(x)
      real, intent(inout) :: x(:)

      integer :: i, n
      n = size(x)

      do i=1,n
         x(i) = f__enzyme_truncate_mem_value(x(i), TRUNC_FROM, TRUNC_TO_E, TRUNC_TO_M)
      end do
    end subroutine truncate_1d

    subroutine truncate_0d(x)
      real, intent(inout) :: x
      real :: tmp(1)

      tmp(1) = x
      call truncate_1d(tmp)
      x = tmp(1)
    end subroutine truncate_0d

    subroutine truncate_2d(x)
      real, intent(inout) :: x(:, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2)])
    end subroutine truncate_2d

    subroutine truncate_3d(x)
      real, intent(inout) :: x(:, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3)])
    end subroutine truncate_3d

    subroutine truncate_4d(x)
      real, intent(inout) :: x(:, :, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3), size(x, 4)])
    end subroutine truncate_4d

    subroutine expand_1d(x)
      real, intent(inout) :: x(:)

      integer :: i, n
      n = size(x)

      do i=1,n
         x(i) = f__enzyme_expand_mem_value(x(i), TRUNC_FROM, TRUNC_TO_E, TRUNC_TO_M)
      end do
    end subroutine expand_1d

    subroutine expand_0d(x)
      real, intent(inout) :: x
      real :: tmp(1)

      tmp(1) = x
      call expand_1d(tmp)
      x = tmp(1)
    end subroutine expand_0d

    subroutine expand_2d(x)
      real, intent(inout) :: x(:, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2)])
    end subroutine expand_2d

    subroutine expand_3d(x)
      real, intent(inout) :: x(:, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3)])
    end subroutine expand_3d

    subroutine expand_4d(x)
      real, intent(inout) :: x(:, :, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3), size(x, 4)])
    end subroutine expand_4d

    subroutine f__enzyme_truncate_mem_func_hy_recon(from, to_e, to_m, &
         scr_rope, scr_uPlus, scr_uMinus, flat3d, loGC, is, js, ks, i,j,k,v)
      implicit none

      integer, intent(in) :: from, to_e, to_m

      integer, intent(IN) :: i,j,k,v, is, js, ks
      integer, intent(IN) :: loGC(3)
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(INOUT) :: &
           scr_rope,scr_uPlus, scr_uMinus
      real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(IN) :: flat3d

      call hy_recon(scr_rope, scr_uPlus, scr_uMinus, flat3d, loGC, is, js, ks, i,j,k,v)
    end subroutine f__enzyme_truncate_mem_func_hy_recon

    subroutine f__enzyme_truncate_mem_func_hy_riemann(from, to_e, to_m, &
         dir,VL,VR,inShock,Fstar,speed)
#include "Simulation.h"
#include "constants.h"
#include "Spark.h"
      implicit none

      integer, intent(in) :: from, to_e, to_m

      integer, intent(IN) :: dir
      real, dimension(HY_NUM_VARS), intent(INOUT)  :: VL, VR
      logical, intent(IN) :: inShock
      real, dimension(HY_NUM_FLUX),    intent(OUT) :: Fstar
      real,    intent(OUT) :: speed

      call hy_riemann(dir,VL,VR,inShock,Fstar,speed)
    end subroutine f__enzyme_truncate_mem_func_hy_riemann

end module truncate_helpers

subroutine hy_rk_getFaceFlux (stage, starState, flat3d, flx, fly, flz, &
                              limits, deltas, &
                              scr_rope, scr_flux, scr_uPlus, scr_uMinus, &
                              loGC)

  use Hydro_data, ONLY : hy_threadWithinBlock, &
                         hybridRiemann => hy_hybridRiemann, &
                         cvisc => hy_cvisc, &
                         C_hyp => hy_C_hyp, &
                         tinyZero => hy_tiny, &
                         smalld => hy_smalldens, &
                         smallp => hy_smallpres, &
                         smallx => hy_smallX, &
                         limRad => hy_limRad, &
                         mp5ZeroTol => hy_mp5ZeroTol
  use hy_rk_interface, ONLY : hy_recon, hy_riemann

  ! Enzyme
  use truncate_helpers

  implicit none

  @M hy_DIR_TARGET_routine(vector)

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

  integer, intent(IN) :: stage, loGC(3)
  real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN) :: starState
  real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: flx, fly, flz
  real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: scr_rope, scr_flux, scr_uPlus, scr_uMinus
  real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(IN) :: flat3d
  integer, dimension(LOW:HIGH, MDIM, MAXSTAGE), intent(IN) :: limits
  real, dimension(MDIM), intent(IN)  :: deltas

  integer :: i, j, k, s, n, v, dir, ierr
  integer :: ii, jj, kk, is, js, ks
  real :: avisc, VenerLo, VenerHi
  real :: spcSumInv
  real, dimension(NSPECIES) :: spc
  real  :: u2, E, B2, UB, Ptot

  logical :: inShock
  @M hy_recon_declare
  @M hy_riemann_declare

  logical :: offload = .false.

#ifdef OMP_OL
  offload = .true.
#endif

  @M hy_DIR_parallel_loop(3) &
  @M hy_DIR_shared([limits, scr_rope, starState])
  do k = limits(LOW,KAXIS,stage)-NSTENCIL*K3D, limits(HIGH,KAXIS,stage)+NSTENCIL*K3D
  do j = limits(LOW,JAXIS,stage)-NSTENCIL*K2D, limits(HIGH,JAXIS,stage)+NSTENCIL*K2D
  do i = limits(LOW,IAXIS,stage)-NSTENCIL, limits(HIGH,IAXIS,stage)+NSTENCIL
     scr_rope(HY_DENS,i,j,k) = starState(DENS_VAR,i,j,k)
     scr_rope(HY_VELX,i,j,k) = starState(VELX_VAR,i,j,k)
     scr_rope(HY_VELY,i,j,k) = starState(VELY_VAR,i,j,k)
     scr_rope(HY_VELZ,i,j,k) = starState(VELZ_VAR,i,j,k)
     scr_rope(HY_PRES,i,j,k) = starState(PRES_VAR,i,j,k)
     scr_rope(HY_GAMC,i,j,k) = starState(GAMC_VAR,i,j,k)
     scr_rope(HY_RHOE,i,j,k) = starState(DENS_VAR,i,j,k)*starState(EINT_VAR,i,j,k)
#ifdef SPARK_GLM
     scr_rope(HY_MAGX,i,j,k) = starState(MAGX_VAR,i,j,k)
     scr_rope(HY_MAGY,i,j,k) = starState(MAGY_VAR,i,j,k)
     scr_rope(HY_MAGZ,i,j,k) = starState(MAGZ_VAR,i,j,k)
     scr_rope(HY_PSIB,i,j,k) = starState(PSIB_VAR,i,j,k)
#endif
#if NSPECIES+NMASS_SCALARS>0
     do n=SPECIES_BEGIN, MASS_SCALARS_END
        scr_rope(HY_NUM_VARS+1+n-SPECIES_BEGIN,i,j,k) = starState(n,i,j,k)
     enddo
#endif
  enddo
  enddo
  enddo

  !  Begin loop over zones
  do dir = 1, NDIM
     select case(dir)
     case(IAXIS)
        is=1; js=0; ks=0
     case(JAXIS)
        is=0; js=1; ks=0
     case(KAXIS)
        is=0; js=0; ks=1
     end select

     ! call Timers_start("recon")
     @M hy_DIR_parallel_loop(3) &
     @M hy_DIR_recon_shared &
     @M hy_DIR_shared([limits, scr_rope, scr_uMinus, scr_uPlus, flat3d]) &
     @M hy_DIR_recon_private &
     @M hy_DIR_private([stencil]) &
     @M hy_DIR_firstprivate([is, js, ks])
#ifdef DISABLE_TRUNC_RECON
     ! Expand for recon
     call expand_4d(scr_rope)
     call expand_4d(scr_uPlus)
     call expand_4d(scr_uMinus)
     do k = limits(LOW,KAXIS,stage)-1*ks, limits(HIGH,KAXIS,stage)+1*ks
        do j = limits(LOW,JAXIS,stage)-1*js, limits(HIGH,JAXIS,stage)+1*js
           do i = limits(LOW,IAXIS,stage)-1*is, limits(HIGH,IAXIS,stage)+1*is
              do v=1,NRECON
                 call hy_recon(scr_rope, scr_uPlus, scr_uMinus, expand_flat3d, loGC, is, js, ks, i,j,k,v)
              enddo
           enddo
        enddo
     enddo
     ! Truncate back from recon
     call truncate_4d(scr_rope)
     call truncate_4d(scr_uPlus)
     call truncate_4d(scr_uMinus)
#else
#ifdef EXCLUDE_RECON
     call enzyme_fprt_excl_trunc_start()
#endif
     do k = limits(LOW,KAXIS,stage)-1*ks, limits(HIGH,KAXIS,stage)+1*ks
        do j = limits(LOW,JAXIS,stage)-1*js, limits(HIGH,JAXIS,stage)+1*js
           do i = limits(LOW,IAXIS,stage)-1*is, limits(HIGH,IAXIS,stage)+1*is
              do v=1,NRECON
                 call hy_recon(scr_rope, scr_uPlus, scr_uMinus, flat3d, loGC, is, js, ks, i,j,k,v)
              enddo
           enddo
        enddo
     enddo
#ifdef EXCLUDE_RECON
     call enzyme_fprt_excl_trunc_end()
#endif
#endif
     ! call Timers_stop("recon")

     ! call Timers_start("setrem")
     @M hy_DIR_parallel_loop(3) &
     @M hy_DIR_shared([limits, scr_uPlus, scr_uMinus]) &
     @M hy_DIR_private([s, spc, spcSumInv]) &
     @M hy_DIR_firstprivate([smalld, smallp, smallx]) &
     @M hy_DIR_firstprivate([is, js, ks])
     do k = limits(LOW,KAXIS,stage)-1*ks, limits(HIGH,KAXIS,stage)+1*ks
     do j = limits(LOW,JAXIS,stage)-1*js, limits(HIGH,JAXIS,stage)+1*js
     do i = limits(LOW,IAXIS,stage)-1*is, limits(HIGH,IAXIS,stage)+1*is
        ! Limit and renormalize the species.
        @M hy_normalize_species( scr_uPlus )
        @M hy_normalize_species( scr_uMinus )
     enddo
     enddo
     enddo
     ! call Timers_stop("setrem")

     ! call Timers_start("riemann")
     @M hy_DIR_parallel_loop(3) &
     @M hy_DIR_riemann_shared &
     @M hy_DIR_shared([limits, starState, scr_rope, scr_flux, scr_uMinus, scr_uPlus]) &
     @M hy_DIR_riemann_private &
     @M hy_DIR_firstprivate([dir, tinyZero, hybridRiemann]) &
     @M hy_DIR_firstprivate([is, js, ks])
     do k = limits(LOW,KAXIS,stage), limits(HIGH,KAXIS,stage)+1*ks
     do j = limits(LOW,JAXIS,stage), limits(HIGH,JAXIS,stage)+1*js
     do i = limits(LOW,IAXIS,stage), limits(HIGH,IAXIS,stage)+1*is
        ! err_tmp = f_enzyme_reset_shadow_trace()
        VL = scr_uPlus(1:HY_NUM_VARS,i-is,j-js,k-ks)
        VR = scr_uMinus(1:HY_NUM_VARS,i,j,k)
        inShock = .false.
#ifdef SHOK_VAR
        inShock = any(starState(SHOK_VAR,i-1*is:i,j-1*js:j,k-1*ks:k) /= 0.0)
#endif
#ifdef DISABLE_TRUNC_RIEMANN
        call expand_1d(VL)
        call expand_1d(VR)
        ! call expand_1d(Fstar)
        ! call expand_0d(speed)
        call expand_0d(C_hyp)

        call hy_riemann(dir,VL,VR,inShock,Fstar,speed)

        call truncate_1d(VL)
        call truncate_1d(VR)
        call truncate_1d(Fstar)
        call truncate_0d(speed)
        call truncate_0d(C_hyp)
#else
#ifdef EXCLUDE_RIEMANN
        call enzyme_fprt_excl_trunc_start()
#endif
        call hy_riemann(dir,VL,VR,inShock,Fstar,speed)
#ifdef EXCLUDE_RIEMANN
        call enzyme_fprt_excl_trunc_end()
#endif
#endif
        scr_flux(1:HY_NUM_FLUX,i,j,k) = Fstar(1:HY_NUM_FLUX)
        ! print *, err_tmp, "errors after reset,", &
        !      "inShock =", inShock, "and", &
        !      f_enzyme_reset_shadow_trace(), "errors in hy_rk_getFaceFlux.F90"
     enddo
     enddo
     enddo
     ! call Timers_stop("riemann")

     ! call Timers_start("avisc")
     @M hy_DIR_parallel_loop(3) &
     @M hy_DIR_shared([limits, scr_rope, scr_flux, scr_uPlus, scr_uMinus]) &
     @M hy_DIR_private([avisc, VenerLo, VenerHi]) &
     @M hy_DIR_firstprivate([dir, cvisc]) &
     @M hy_DIR_firstprivate([is, js, ks])
     do k = limits(LOW,KAXIS,stage), limits(HIGH,KAXIS,stage)+1*ks
     do j = limits(LOW,JAXIS,stage), limits(HIGH,JAXIS,stage)+1*js
     do i = limits(LOW,IAXIS,stage), limits(HIGH,IAXIS,stage)+1*is
        ! Add artificial viscosity for strong-shock capturing
        avisc = cvisc*max(-(scr_rope(HY_VELX+dir-1,i,j,k) &
                            - scr_rope(HY_VELX+dir-1,i-1*is,j-1*js,k-1*ks)),0.)
        ! Construct minus and plus TOTAL energy densities
        VenerLo = scr_rope(HY_DENS,i-1*is,j-1*js,k-1*ks) &
                  *0.5*(dot_product(scr_rope(HY_VELX:HY_VELZ,i-1*is,j-1*js,k-1*ks), &
                                    scr_rope(HY_VELX:HY_VELZ,i-1*is,j-1*js,k-1*ks)))&
                  + scr_rope(HY_RHOE,i-1*is,j-1*js,k-1*ks)
        VenerHi = scr_rope(HY_DENS,i,j,k) &
                  *0.5*(dot_product(scr_rope(HY_VELX:HY_VELZ,i,j,k), &
                                    scr_rope(HY_VELX:HY_VELZ,i,j,k)))&
                  + scr_rope(HY_RHOE,i,j,k)

        scr_flux(HY_MASS:HY_ENER,i,j,k) = &
           scr_flux(HY_MASS:HY_ENER,i,j,k) &
              + avisc*(/ scr_rope(HY_DENS,i-1*is,j-1*js,k-1*ks) - scr_rope(HY_DENS,i,j,k), &
                         scr_rope(HY_DENS,i-1*is,j-1*js,k-1*ks)*scr_rope(HY_VELX,i-1*is,j-1*js,k-1*ks) &
                              - scr_rope(HY_DENS,i,j,k)*scr_rope(HY_VELX,i,j,k), &
                         scr_rope(HY_DENS,i-1*is,j-1*js,k-1*ks)*scr_rope(HY_VELY,i-1*is,j-1*js,k-1*ks) &
                              - scr_rope(HY_DENS,i,j,k)*scr_rope(HY_VELY,i,j,k), &
                         scr_rope(HY_DENS,i-1*is,j-1*js,k-1*ks)*scr_rope(HY_VELZ,i-1*is,j-1*js,k-1*ks) &
                              - scr_rope(HY_DENS,i,j,k)*scr_rope(HY_VELZ,i,j,k), &
                          VenerLo - VenerHi &
                       /)

#ifdef SPARK_GLM
        scr_flux(HY_FMGX:HY_FPSI,i,j,k) = &
              scr_flux(HY_FMGX:HY_FPSI,i,j,k) &
                 + avisc*(/ scr_rope(HY_MAGX,i-1*is,j-1*js,k-1*ks) - scr_rope(HY_MAGX,i,j,k), &
                            scr_rope(HY_MAGY,i-1*is,j-1*js,k-1*ks) - scr_rope(HY_MAGY,i,j,k), &
                            scr_rope(HY_MAGZ,i-1*is,j-1*js,k-1*ks) - scr_rope(HY_MAGZ,i,j,k), &
                            scr_rope(HY_PSIB,i-1*is,j-1*js,k-1*ks) - scr_rope(HY_PSIB,i,j,k) &
                         /)
#endif
              ! Here, we compute the species and mass scalar
              ! fluxes based on the density flux and the hy_reconstructed
              ! mass scalar interface values
#if NSPECIES+NMASS_SCALARS>0
              ! AH: TODO: Potentially make loop explicit
         if (scr_flux(HY_MASS ,i,j,k) > 0.) then
            scr_flux(HY_NUM_FLUX+1:NFLUXES,i,j,k) = &
               scr_uPlus(HY_NUM_VARS+1:NRECON,i-1*is,j-1*js,k-1*ks)*scr_flux(HY_MASS,i,j,k)
         else
            scr_flux(HY_NUM_FLUX+1:NFLUXES,i,j,k) = &
               scr_uMinus(HY_NUM_VARS+1:NRECON,i,j,k)*scr_flux(HY_MASS,i,j,k)
         end if
#endif
     enddo
     enddo
     enddo
     ! call Timers_stop("avisc")

     ! call Timers_start("flux")
     ! ***************
     ! Fluxes computed for one face of this zone
     ! Save the fluxes
     ! ***************
     select case(dir)
     case(IAXIS)
        @M hy_DIR_parallel_loop_simd(3) &
        @M hy_DIR_shared([scr_flux, flx])
        do k = limits(LOW,KAXIS,stage), limits(HIGH,KAXIS,stage)
        do j = limits(LOW,JAXIS,stage), limits(HIGH,JAXIS,stage)
        do i = limits(LOW,IAXIS,stage), limits(HIGH,IAXIS,stage)+1
           do v = 1, NFLUXES
              flx(v,i,j,k) = scr_flux(v,i,j,k)
           end do
        enddo
        enddo
        enddo
     case (JAXIS)
        @M hy_DIR_parallel_loop_simd(3) &
        @M hy_DIR_shared([scr_flux, fly])
        do k = limits(LOW,KAXIS,stage), limits(HIGH,KAXIS,stage)
        do j = limits(LOW,JAXIS,stage), limits(HIGH,JAXIS,stage)+1
        do i = limits(LOW,IAXIS,stage), limits(HIGH,IAXIS,stage)
           do v = 1, NFLUXES
              fly(v,i,j,k) = scr_flux(v,i,j,k)
           end do
        enddo
        enddo
        enddo
     case (KAXIS)
        @M hy_DIR_parallel_loop_simd(3) &
        @M hy_DIR_shared([scr_flux, flz])
        do k = limits(LOW,KAXIS,stage), limits(HIGH,KAXIS,stage)+1
        do j = limits(LOW,JAXIS,stage), limits(HIGH,JAXIS,stage)
        do i = limits(LOW,IAXIS,stage), limits(HIGH,IAXIS,stage)
           do v = 1, NFLUXES
              flz(v,i,j,k) = scr_flux(v,i,j,k)
           end do
        enddo
        enddo
        enddo
     end select
     ! call Timers_stop("flux")
  end do ! dir

contains

   real function minmod(a,b)
     implicit none
     real :: a,b
     minmod=.5 * (sign(1.,a) + sign(1.,b))*min(abs(a),abs(b))
   end function minmod

   real function median(a,b,c)
     implicit none
     real :: a,b,c
     median = a + minmod(b-a,c-a)
   end function median
   
end subroutine hy_rk_getFaceFlux
