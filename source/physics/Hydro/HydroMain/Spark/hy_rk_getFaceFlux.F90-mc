!!****if* source/physics/Hydro/HydroMain/Spark/hy_rk_getFaceFlux
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!!  NAME
!!
!!  hy_rk_getFaceFlux
!!
!!  SYNOPSIS
!!
!!  call hy_rk_getFaceFlux ( integer(IN) :: blklimits(:,:),
!!                           integer(IN) :: blklimitsGC(:,:),
!!                           real(IN)    :: hy_del(:),
!!                           integer(IN) :: limits(:,:))
!!
!!  DESCRIPTION
!!  Initially stores grid data by 'pencils' (see subroutine setPencil() below),
!!  calls outside hy_reconstruction subroutine, calls outisde Riemann solver, and 
!!  ultimately yields face fluxes for relevant directions.  These fluxes are lastly 
!!  saved to the grid multifabs (AMReX) for later access.
!!
!!  ARGUMENTS
!!     blklimits,blkLimitsGC are the bounds of the block/tile
!!     hy_del are dx,dy,dz
!!     limits   sets limits of the fluxes.
!!
!!     Note this is a modified form typically yielded
!!     by blockDesc%limits b/c stage 1 of RK integration accounts for NSTENCIL 
!!     number of guard cells beyond the block interior.  Stage 2 only updates the 
!!    interior cells.
!!
!!***
!!NOVARIANTS
!!Reorder(4):hy_starState,hy_fl[xyz]

subroutine hy_rk_getFaceFlux (hy_starState,blklimits,blkLimitsGC, limits)
  use Hydro_data, ONLY : hy_threadWithinBlock,hy_smalldens, &
       hy_smallE, hy_smallpres, hy_smallX, hy_cvisc, hy_flattening
      
  use Hydro_data, ONLY : hya_grav, hya_flx, hya_fly, hya_flz, hya_flat3d 
  use Hydro_data, ONLY : hya_starState,hya_rope, hya_uPlus, hya_uMinus, hya_flat, hya_grv, &
       hya_shck, hya_flux
  use Hydro_data, ONLY : hy_del, hy_tiny, hy_hybridRiemann, hy_C_hyp
  use Hydro_data, ONLY : klim,lim,limgc,lim1,gCells, dir,stage
  use Timers_interface, ONLY : Timers_start, Timers_stop

  implicit none

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

  real,dimension(:,:,:,:),pointer ::hy_starState
  integer, intent(IN), dimension(LOW:HIGH,MDIM) :: limits, blkLimits, blkLimitsGC
  integer :: i,j,k, n, g, v,  ierr
  integer :: im1
  character(len = 2) :: dir_str
  real :: cvisc, VenerLo, VenerHi, accelM, accelP,dx
  integer :: s
  real :: spcSumInv, spcSum
  real, pointer :: spc(:)
  real  :: u2,E,B2,UB,Ptot

  logical :: inShock
!!  real, dimension(HY_NUM_VARS) :: VL, VR
  real :: rope(5)
  real,dimension(:,:,:,:),pointer::hy_rope, hy_uPlus, hy_uMinus,hy_flux,&
       hy_grav, hy_flx, hy_fly, hy_flz
  real,dimension(:,:,:),pointer :: hy_flat,hy_shck,hy_grv,hy_flat3d
  @M hy_recon_declare
  @M hy_riemann_declare

  !$omp target enter data map (to: coeff1p1, coeff1p2, coeff1p3, coeff1m1, coeff1m2, coeff1m3, linWp, linWm, epsilon, n13o12)
  hy_grav(1:MDIM,@M bounds_3d(blkLimitsGC))=>hya_grav

  hy_flat3d(@M bounds_3d(blkLimitsGC))=>hya_flat3d

  @M hy_map_fl
  
  !$omp target enter data map(alloc: lim, klim, limgc, stage, dir)
  if (hy_flattening) then
     ! AH: TODO: OpenMP for flattening
     call flattening(limits)
  else
     ! call Timers_start("hy_flat3d")
     !! TODO: Set this once for both rk steps.

     !$omp target teams distribute parallel do simd collapse(3) &
     !$omp default(none) &
     !$omp private(i, j, k) &
     !$omp shared(blkLimitsGC, hy_flat3d) &
     !$omp map(to: blkLimitsGC)
     @M loop_3d(blkLimitsGC)
              hy_flat3d(i,j,k) = 1.0
     @M loop_end_3d

     ! call Timers_stop("hy_flat3d")
  end if
  


  !  Begin loop over zones

  do dir = 1, NDIM
     !$omp target update to(lim, limgc, klim, dir, stage)
     
     hy_flux(1:NFLUXES,@M hy_bounds(limgc))=>hya_flux
     hy_flat(@M hy_bounds(limgc))=>hya_flat
     hy_shck(@M hy_bounds(limgc))=>hya_shck
     hy_grv(@M hy_bounds(limgc))=>hya_grv
     
     hy_rope(1:NRECON,@M hy_bounds(limgc)) => hya_rope
     hy_uPlus(1:NRECON,@M hy_bounds(limgc)) => hya_uPlus
     hy_uMinus(1:NRECON,@M hy_bounds(limgc)) => hya_uMinus

     !$omp target enter data map(alloc: hy_flux, hy_flat, hy_shck, hy_grv, hy_rope, hy_uPlus, hy_uMinus)

     !$omp target teams distribute parallel do simd collapse(3) &
     !$omp default(none) &
     !$omp private(i, j, k, n) &
     !$omp shared(limgc, dir, stage, hy_rope, hy_starState, hy_grv, hy_grav, hy_shck, hy_flat, hy_flat3d)
     @M hy_loop(limgc)
              if (dir == IAXIS) then
                 @M hy_setRope(i,j,k)
              else if (dir == JAXIS) then
                 @M hy_setRope(j,i,k)
              else if (dir == KAXIS) then
                 @M hy_setRope(j,k,i)
              endif
     @M loop_end_3d



     call Timers_start("recon")
     !$omp target teams distribute parallel do simd collapse(4) &
     !$omp default(none) &
     !$omp private(i, j, k, v, W5p, W5m, betaWeno, Alpha5, omega, invSumAlpha, abs_betadiff) &
     !$omp shared(klim, dir, stage, hy_rope, hy_uMinus, hy_uPlus, hy_flat, &
     !$omp        coeff1p1, coeff1p2, coeff1p3, coeff1m1, coeff1m2, coeff1m3, linWp, linWm)
     @M hy_loop(klim)
          do v=1,NRECON
             @M hy_recon
          enddo
     @M loop_end_3d
     call Timers_stop("recon")

     call Timers_start("setrem")
     !$omp target teams distribute collapse(3) &
     !$omp default(none) &
     !$omp private(i, j, k, s, spc, spcSumInv, spcSum) &
     !$omp shared(klim, dir, stage, hy_uPlus, hy_uMinus, hy_smalldens, hy_smallpres)
     @M hy_loop(klim)
              ! Limit and renormalize the species.
              @M hy_normalize_species( hy_uPlus )
              @M hy_normalize_species( hy_uMinus )
     @M loop_end_3d
     call Timers_stop("setrem")

     call Timers_start("riemann")
     !$omp target teams distribute parallel do simd collapse(3) &
     !$omp default(none) &
     !$omp private(i, j, k, v, &
     !$omp    VL, VR, Fstar, inShock, ierr, &
     !$omp    UL, UR, Uhll, UCstarR, UCstarL, FL, FR, &
     !$omp    velNL, velNR, aL2, aR2, &
     !$omp    magNL, magNR, Bn_glm, Psi_glm, magBL2, magBR2, &
     !$omp    cfL, cfR, SL, SR, speed, totalPresL, totalPresR, &
     !$omp    pStar, qStar, numerL, numerR, denomL, denomR, &
     !$omp    dStarL, dStarR, &
     !$omp    u2, E, B2, UB, Ptot ) &
     !$omp shared(lim, dir, stage, hy_uMinus, hy_uPlus, hy_flux, hy_shck, hy_tiny, hy_hybridRiemann)
     @M hy_loop_plus(lim,1,0,0)
              VL = hy_uPlus(1:HY_NUM_VARS,i-1,j,k)
              VR = hy_uMinus(1:HY_NUM_VARS,i,j,k) 
              inShock = any(hy_shck(i-1:i,j,k) /= 0.0)
              @M hy_riemann
              hy_flux(1:HY_NUM_FLUX,i,j,k) = Fstar(1:HY_NUM_FLUX)
     @M loop_end_3d
     call Timers_stop("riemann")

     call Timers_start("cvisc")
     !$omp target teams distribute parallel do simd collapse(3) &
     !$omp default(none) &
     !$omp private(i, j, k, v, cvisc, VenerLo, VenerHi, im1) &
     !$omp shared(lim, dir, stage, hy_cvisc, hy_rope, hy_flux, hy_uMinus, hy_uPlus)
     @M hy_loop_plus(lim,1,0,0)

              ! Add artificial viscosity for strong-shock capturing
              cvisc = hy_cvisc*max(-(hy_rope(HY_VELX+dir-1,i,j,k) - hy_rope(HY_VELX+dir-1,i-1,j,k)),0.)
              
              ! Construct minus and plus TOTAL energy densities
              im1 = i-1
              @M hy_dot_product(v,im1,im1,HY_VELX,HY_VELZ,hy_rope,hy_rope,VenerLo)
              VenerLo = hy_rope(HY_DENS,i-1,j,k)*0.5*VenerLo + hy_rope(HY_RHOE,i-1,j,k)

              @M hy_dot_product(v,i,i,HY_VELX,HY_VELZ,hy_rope,hy_rope,VenerHi)
              VenerHi = hy_rope(HY_DENS,i,j,k)*0.5*VenerHi + hy_rope(HY_RHOE,i,j,k)


              hy_flux(HY_XMOM,i,j,k) = hy_flux(HY_XMOM,i,j,k) &
                   +cvisc*(hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELX,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELX,i,j,k))

              hy_flux(HY_YMOM,i,j,k) =  hy_flux(HY_YMOM,i,j,k) &
                   +cvisc*(hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELY,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELY,i,j,k))

               hy_flux(HY_ZMOM,i,j,k) = hy_flux(HY_ZMOM,i,j,k) &
                   +cvisc*(hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELZ,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELZ,i,j,k))
              
              hy_flux(HY_MASS,i,j,k) = hy_flux(HY_MASS,i,j,k) &
                   +cvisc*( hy_rope(HY_DENS,i-1,j,k) - hy_rope(HY_DENS,i,j,k) )

              hy_flux(HY_ENER,i,j,k) = hy_flux(HY_ENER,i,j,k) + cvisc*( VenerLo - VenerHi )

#ifdef SPARK_GLM
              hy_flux(HY_FMGX:HY_FPSI,i,j,k) = &
                   hy_flux(HY_FMGX:HY_FPSI,i,j,k) &
                   +cvisc*(/hy_rope(HY_MAGX,i-1,j,k)                 - hy_rope(HY_MAGX,i,j,k)&
                   ,        hy_rope(HY_MAGY,i-1,j,k)                 - hy_rope(HY_MAGY,i,j,k)&
                   ,        hy_rope(HY_MAGZ,i-1,j,k)                 - hy_rope(HY_MAGZ,i,j,k)&
                   ,        hy_rope(HY_PSIB,i-1,j,k)                 - hy_rope(HY_PSIB,i,j,k)/)
#endif
              ! Here, we compute the species and mass scalar
              ! fluxes based on the density flux and the hy_reconstructed
              ! mass scalar interface values
              
              
#if NSPECIES+NMASS_SCALARS>0
              ! AH: TODO: Potentially make loop explicit
              if (hy_flux(HY_MASS ,i,j,k) > 0.) then
                 hy_flux(HY_NUM_FLUX+1:NFLUXES ,i,j,k) = hy_uPlus(HY_NUM_VARS+1:NRECON, i-1,j,k)*hy_flux(HY_MASS ,i,j,k)
              else
                 hy_flux(HY_NUM_FLUX+1:NFLUXES ,i,j,k) = hy_uMinus(HY_NUM_VARS+1:NRECON ,i,j,k)*hy_flux(HY_MASS ,i,j,k)
              end if
#endif
     @M loop_end_3d
     call Timers_stop("cvisc")

     call Timers_start("flux")
     ! ***************
     ! Fluxes computed for one face of this zone
     ! Save the fluxes
     ! ***************
     select case(dir)
     case(IAXIS)
        !$omp target teams distribute parallel do simd collapse(4) &
        !$omp default(none) &
        !$omp private(i, j, k, v) &
        !$omp shared(lim, dir, stage, hy_flux, hy_flx) &
        !$omp map(from: hy_flx)
        @M hy_loop_plus(lim,1,0,0)
              do v = 1, NFLUXES
                 hy_flx(v,i,j,k) = hy_flux(v,i,j,k)
              end do
        @M loop_end_3d
     case (JAXIS)
        !$omp target teams distribute parallel do simd collapse(4) &
        !$omp default(none) &
        !$omp private(i, j, k, v) &
        !$omp shared(lim, dir, stage, hy_flux, hy_fly) &
        !$omp map(from: hy_fly)
        @M hy_loop_plus(lim,1,0,0)
              do v = 1, NFLUXES
                 hy_fly(v,j,i,k) = hy_flux(v,i,j,k)
              end do
        @M loop_end_3d
     case (KAXIS)
        !$omp target teams distribute parallel do simd collapse(4) &
        !$omp default(none) &
        !$omp private(i, j, k, v) &
        !$omp shared(lim, dir, stage, hy_flux, hy_flz) &
        !$omp map(from: hy_flz)
        @M hy_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              hy_flz(v,j,k,i) = hy_flux(v,i,j,k)
           end do
        @M loop_end_3d
     end select
     call Timers_stop("flux")        
     !release pointers
     !$omp target exit data map(release: hy_flux, hy_rope, hy_uPlus, hy_uMinus, hy_flat, hy_shck, hy_grv)
     nullify(hy_flux)
     nullify(hy_rope)
     nullify(hy_uPlus)
     nullify(hy_uMinus)
     nullify(hy_flat)
     nullify(hy_shck)
     nullify(hy_grv)
     
     
  end do ! dir

  !$omp target exit data map(release: lim, klim, limgc, stage, dir)
  nullify(hy_grav)
  nullify(hy_flat3d)
  @M hy_nullFl
  
  
  
contains
  
  !!Set loop dimensions based on the direction of the pencil set
  
  !! the 'pencil' holds a 1D array of the solution data to be operated
  !! on.  It is unrolled this way so that all data that are needed for
  !! interpolation and flux calculation are truly contiguous in memory
  !! space.  And so that it all fits in cache at once...
  !! The maximum amount of calculation is done on these data prior to
  !! reseting the pencil data to a new ray through the block.
  !! If I were talented at ASCII art, I would make a diagram...
  
  
  !~ Flattening has not been tested yet in FLASH5, only 1D & 2D runs so far.
  subroutine flattening(limits)
    !! This follows Miller & Colella 2002
    implicit none
    integer, parameter :: kx = 1
    integer, parameter :: ky = K2D
    integer, parameter :: kz = K3D
    integer, intent(IN), dimension(LOW:HIGH,MDIM) :: limits
    !real, intent(OUT) :: hy_flat3d(GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC)
    !real :: hy_flatTilde(NDIM,GRID_IHI_GC,GRID_JHI_GC,GRID_KHI_GC)
    real :: hy_flatTilde(NDIM,limits(LOW,IAXIS)-kx:limits(HIGH,IAXIS)+kx,&
         limits(LOW,JAXIS)-ky:limits(HIGH,JAXIS)+ky,&
         limits(LOW,KAXIS)-kz:limits(HIGH,KAXIS)+kz)
    real :: beta, Z
    real, parameter :: betaMin = 0.75, betaMax = 0.85
    real, parameter :: Zmin = 0.25, Zmax = 0.75
    integer :: i,j,k

    do k=limits(LOW,KAXIS)-kz, limits(HIGH,KAXIS)+kz
       do j=limits(LOW,JAXIS)-ky, limits(HIGH,JAXIS)+ky
          do i=limits(LOW,IAXIS)-kx, limits(HIGH,IAXIS)+kx
             !1e-99 used to be TINY(1.0) but that produced Seg Faults
             beta = abs(hy_starState(PRES_VAR,i+1,j,k)-hy_starState(PRES_VAR,i-1,j,k)) &
                  / max(1e-99, abs(hy_starState(PRES_VAR,i+2,j,k)-hy_starState(PRES_VAR,i-2,j,k)))
             Z    = abs(hy_starState(PRES_VAR,i+1,j,k)-hy_starState(PRES_VAR,i-1,j,k)) &
                  / (hy_starState(GAMC_VAR,i,j,k)*hy_starState(PRES_VAR,i,j,k))
             hy_flatTilde(IAXIS,i,j,k) = max(0.,min(1.,(betaMax-beta)/(betaMax-betaMin)))
             if (hy_starState(VELX_VAR,i+1,j,k)<hy_starState(VELX_VAR,i,j,k)) then
                hy_flatTilde(IAXIS,i,j,k) = max(hy_flatTilde(IAXIS,i,j,k), &
                     &                   min(1., (Zmax-Z)/(Zmax-Zmin)))
             else
                hy_flatTilde(IAXIS,i,j,k) = 1.0
             end if
#if NDIM>1
             beta = abs(hy_starState(PRES_VAR,i,j+1,k)-hy_starState(PRES_VAR,i,j-1,k)) &
                  / max(1.e-99,abs(hy_starState(PRES_VAR,i,j+2,k)-hy_starState(PRES_VAR,i,j-2,k)))
             Z    = abs(hy_starState(PRES_VAR,i,j+1,k)-hy_starState(PRES_VAR,i,j-1,k)) &
                  / (hy_starState(GAMC_VAR,i,j,k)*hy_starState(PRES_VAR,i,j,k))
             hy_flatTilde(JAXIS,i,j,k) = max(0.,min(1.,(betaMax-beta)/(betaMax-betaMin)))
             if (hy_starState(VELY_VAR,i,j+1,k)<hy_starState(VELY_VAR,i,j,k)) then
                hy_flatTilde(JAXIS,i,j,k) = max(hy_flatTilde(JAXIS,i,j,k), &
                     &                   min(1., (Zmax-Z)/(Zmax-Zmin)))
             else
                hy_flatTilde(JAXIS,i,j,k) = 1.0
             end if
#if NDIM==3
             beta = abs(hy_starState(PRES_VAR,i,j,k+1)-hy_starState(PRES_VAR,i,j,k-1)) &
                  / max(1.e-99,abs(hy_starState(PRES_VAR,i,j,k+2)-hy_starState(PRES_VAR,i,j,k-2)))
             Z    = abs(hy_starState(PRES_VAR,i,j,k+1)-hy_starState(PRES_VAR,i,j,k-1)) &
                  / (hy_starState(GAMC_VAR,i,j,k)*hy_starState(PRES_VAR,i,j,k))
             hy_flatTilde(KAXIS,i,j,k) = max(0.,min(1.,(betaMax-beta)/(betaMax-betaMin)))
             if (hy_starState(VELZ_VAR,i,j,k+1)<hy_starState(VELZ_VAR,i,j,k)) then
                hy_flatTilde(KAXIS,i,j,k) = max(hy_flatTilde(KAXIS,i,j,k), &
                     &                   min(1., (Zmax-Z)/(Zmax-Zmin)))
             else
                hy_flatTilde(KAXIS,i,j,k) = 1.0
             end if
#endif
#endif
          end do
       end do
    end do
    do k=limits(LOW,KAXIS)-kz, limits(HIGH,KAXIS)+kz
       do j=limits(LOW,JAXIS)-ky, limits(HIGH,JAXIS)+ky
          do i=limits(LOW,IAXIS)-kx, limits(HIGH,IAXIS)+kx
             hy_flat3d(i,j,k) = minval(hy_flatTilde(1:NDIM,i,j,k))
#ifdef FLAT_VAR
             hy_starState(FLAT_VAR,i,j,k) = hy_flat3d(i,j,k)
#endif
          end do
       end do
    end do
  end subroutine flattening
  
end subroutine hy_rk_getFaceFlux


