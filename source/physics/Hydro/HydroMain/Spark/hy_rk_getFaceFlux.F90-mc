!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!> @ingroup HydroSpark
!!
!! @brief Computes interfacial fluxes through reconstruction and solving Riemann
!!
!! @details
!! The reconstruction method and Riemann Solver are implemented as macros,
!! so one can implement new reconstruction/Riemann solver by redefining
!! corresponding macros.
!!
!! @note
!! Initially stores grid data in @p p_rope by permuting indices <tt> i,j,k </tt>,
!! depending on the direction of the flux.
!! Thus, the <tt>i</tt>-index is always the direction where this subroutine
!! solves interfacial fluxes. See @p hy_setRope macro.
!! The index limits are determined by the input paramters @p lim and @p limgc,
!! and they also should be permutated indeces. See @p hy_calc_lim macro.
!!
!! @param starState      Pointer to input solution data
!! @param flat3d         Flattening limiter
!! @param flx,fly,flz    Output fluxes
!! @param lim            Permutated index limits for interior of the part of tile
!! @param limgc          Permutated index limits for outerior of the part of tile
!! @param stage          Current RK stage
!! @param hybridRiemann  On/Off switch for hybrid Riemann solver
!! @param cvisc          Artificial viscosity constant
!! @param C_hyp        Global maximum hyperbolic speed; Only used for GLM
!! @param tinyZero       A tiny number to check unphysical negativity
!! @param smalld         Density cutoff value
!! @param smallp         Pressure cutoff value
!! @param smallx         Abundance cutoff value
!! @param a_[*]          Scratch spaces for internal calculations
!!
!<
!!NOVARIANTS
!!Reorder(4):starState,fl[xyz]

subroutine hy_rk_getFaceFlux (starState, flat3d, flx, fly, flz, &
                              lim, limgc, stage, &
                              hybridRiemann, cvisc, C_hyp, tinyZero, smalld, smallp, smallx, &
                              a_flux, a_flat, a_shck, a_rope, a_uPlus, a_uMinus)

  use Hydro_data, ONLY : hy_threadWithinBlock

  implicit none

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

  real, dimension(:,:,:,:), pointer :: starState, flx, fly, flz
  real, dimension(:,:,:), pointer :: flat3d
  integer, dimension(LOW:HIGH, MDIM, NDIM, MAXSTAGE), intent(IN) :: lim, limgc
  integer, intent(IN) :: stage
  logical, intent(IN) :: hybridRiemann
  real, intent(IN) :: cvisc, C_hyp, smalld, smallp, smallx, tinyZero
  real, dimension(:), target, intent(IN) :: a_flux, a_flat, a_shck, a_rope, a_uPlus, a_uMinus

  real, dimension(:,:,:,:), pointer :: p_rope, p_uPlus, p_uMinus, p_flux
  real, dimension(:,:,:), pointer :: p_flat, p_shck

  integer :: i, j, k, s, n, v, dir, ierr
  real :: avisc, VenerLo, VenerHi
  real :: spcSumInv
  real, dimension(NSPECIES) :: spc
  real  :: u2, E, B2, UB, Ptot

  logical :: inShock
  @M hy_recon_declare
  @M hy_riemann_declare

  logical :: offload = .false.

#ifdef OMP_OL
  offload = .true.
#endif

  @M hy_DIR_TARGET_enter_data(to, [coeff1p1, coeff1p2, coeff1p3, coeff1m1, coeff1m2, coeff1m3, linWp, linWm])
  @M hy_DIR_TARGET_enter_data(to, [lim, limgc, stage, dir])


  !  Begin loop over zones
  @M hy_DIR_HOST_parallel_if_threaded &
  @M hy_DIR_HOST_getFaceFlux_shared &
  @M hy_DIR_HOST_getFaceFlux_private
  do dir = 1, NDIM
     ! call Timers_start("prepare_scratch")
     @M hy_DIR_TARGET_update_to([dir])

     p_flux(1:NFLUXES,@M hy_bounds(limgc)) => a_flux
     p_flat(@M hy_bounds(limgc)) => a_flat
     p_shck(@M hy_bounds(limgc)) => a_shck

     p_rope(1:NRECON,@M hy_bounds(limgc)) => a_rope
     p_uPlus(1:NRECON,@M hy_bounds(limgc)) => a_uPlus
     p_uMinus(1:NRECON,@M hy_bounds(limgc)) => a_uMinus

     @M hy_DIR_TARGET_enter_data(alloc, [p_flux, p_flat, p_shck, p_rope, p_uPlus, p_uMinus])
     ! call Timers_stop("prepare_scratch")

     ! call Timers_start("setRope")
     @M hy_DIR_HOST_do_collapse(2)
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_setRope_private &
     @M hy_DIR_TARGET_setRope_shared
     @M hy_permute_loop(limgc, lim)
        if (dir == IAXIS) then
           @M hy_setRope(i,j,k)
        else if (dir == JAXIS) then
           @M hy_setRope(j,i,k)
        else if (dir == KAXIS) then
           @M hy_setRope(j,k,i)
        endif
     @M hy_break_loop
     ! call Timers_stop("setRope")



     ! call Timers_start("recon")
     @M hy_DIR_TARGET_parallel_loop(4) &
     @M hy_DIR_TARGET_recon_private &
     @M hy_DIR_TARGET_recon_shared
     @M hy_inner_loop_ext_i(lim)
        do v=1,NRECON
           @M hy_recon
        enddo
     @M hy_break_loop
     ! call Timers_stop("recon")

     ! call Timers_start("setrem")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_normalize_species_private &
     @M hy_DIR_TARGET_normalize_species_shared
     @M hy_inner_loop_ext_i(lim)
        ! Limit and renormalize the species.
        @M hy_normalize_species( p_uPlus )
        @M hy_normalize_species( p_uMinus )
     @M hy_break_loop
     ! call Timers_stop("setrem")

     ! call Timers_start("riemann")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_riemann_private &
     @M hy_DIR_TARGET_riemann_shared
     @M hy_inner_loop_plus(lim,1,0,0)
        VL = p_uPlus(1:HY_NUM_VARS,i-1,j,k)
        VR = p_uMinus(1:HY_NUM_VARS,i,j,k) 
        inShock = any(p_shck(i-1:i,j,k) /= 0.0)
        @M hy_riemann
        p_flux(1:HY_NUM_FLUX,i,j,k) = Fstar(1:HY_NUM_FLUX)
     @M hy_break_loop
     ! call Timers_stop("riemann")

     ! call Timers_start("avisc")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_avisc_private &
     @M hy_DIR_TARGET_avisc_shared
     @M hy_inner_loop_plus(lim,1,0,0)
        ! Add artificial viscosity for strong-shock capturing
        avisc = cvisc*max(-(p_rope(HY_VELX+dir-1,i,j,k) - p_rope(HY_VELX+dir-1,i-1,j,k)),0.)
        ! Construct minus and plus TOTAL energy densities
        VenerLo = p_rope(HY_DENS,i-1,j,k) &
                  *0.5*(dot_product(p_rope(HY_VELX:HY_VELZ,i-1,j,k),p_rope(HY_VELX:HY_VELZ,i-1,j,k)))&
                  + p_rope(HY_RHOE,i-1,j,k)
        VenerHi = p_rope(HY_DENS,i,j,k) &
                  *0.5*(dot_product(p_rope(HY_VELX:HY_VELZ,i,j,k),p_rope(HY_VELX:HY_VELZ,i,j,k)))&
                  + p_rope(HY_RHOE,i,j,k)

        p_flux(HY_MASS:HY_ENER,i,j,k) = &
              p_flux(HY_MASS:HY_ENER,i,j,k) &
                 + avisc*(/ p_rope(HY_DENS,i-1,j,k) - p_rope(HY_DENS,i,j,k), &
                            p_rope(HY_DENS,i-1,j,k)*p_rope(HY_VELX,i-1,j,k) - p_rope(HY_DENS,i,j,k)*p_rope(HY_VELX,i,j,k), &
                            p_rope(HY_DENS,i-1,j,k)*p_rope(HY_VELY,i-1,j,k) - p_rope(HY_DENS,i,j,k)*p_rope(HY_VELY,i,j,k), &
                            p_rope(HY_DENS,i-1,j,k)*p_rope(HY_VELZ,i-1,j,k) - p_rope(HY_DENS,i,j,k)*p_rope(HY_VELZ,i,j,k), &
                            VenerLo - VenerHi &
                         /)

              
#ifdef SPARK_GLM
        p_flux(HY_FMGX:HY_FPSI,i,j,k) = &
              p_flux(HY_FMGX:HY_FPSI,i,j,k) &
                 + avisc*(/ p_rope(HY_MAGX,i-1,j,k) - p_rope(HY_MAGX,i,j,k), &
                            p_rope(HY_MAGY,i-1,j,k) - p_rope(HY_MAGY,i,j,k), &
                            p_rope(HY_MAGZ,i-1,j,k) - p_rope(HY_MAGZ,i,j,k), &
                            p_rope(HY_PSIB,i-1,j,k) - p_rope(HY_PSIB,i,j,k) &
                         /)
#endif
              ! Here, we compute the species and mass scalar
              ! fluxes based on the density flux and the hy_reconstructed
              ! mass scalar interface values
#if NSPECIES+NMASS_SCALARS>0
              ! AH: TODO: Potentially make loop explicit
         if (p_flux(HY_MASS ,i,j,k) > 0.) then
            p_flux(HY_NUM_FLUX+1:NFLUXES,i,j,k) = p_uPlus(HY_NUM_VARS+1:NRECON,i-1,j,k)*p_flux(HY_MASS,i,j,k)
         else
            p_flux(HY_NUM_FLUX+1:NFLUXES,i,j,k) = p_uMinus(HY_NUM_VARS+1:NRECON,i,j,k)*p_flux(HY_MASS,i,j,k)
         end if
#endif
     @M hy_break_loop
     ! call Timers_stop("avisc")

     ! call Timers_start("flux")
     ! ***************
     ! Fluxes computed for one face of this zone
     ! Save the fluxes
     ! ***************
     select case(dir)
     case(IAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(flx)
        @M hy_inner_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              flx(v,i,j,k) = p_flux(v,i,j,k)
           end do
        @M hy_break_loop
     case (JAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(fly)
        @M hy_inner_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              fly(v,j,i,k) = p_flux(v,i,j,k)
           end do
        @M hy_break_loop
     case (KAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(flz)
        @M hy_inner_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              flz(v,j,k,i) = p_flux(v,i,j,k)
           end do
        @M hy_break_loop
     end select
     ! call Timers_stop("flux")
     @M hy_permute_loop_end
     @M hy_DIR_HOST_end_do
     !release pointers
     @M hy_DIR_TARGET_exit_data(release, [p_flux, p_rope, p_uPlus, p_uMinus, p_flat, p_shck])
     nullify(p_flux)
     nullify(p_rope)
     nullify(p_uPlus)
     nullify(p_uMinus)
     nullify(p_flat)
     nullify(p_shck)
  end do ! dir
  @M hy_DIR_HOST_end_parallel

  @M hy_DIR_TARGET_exit_data(release, [lim, limgc, stage, dir])

end subroutine hy_rk_getFaceFlux


