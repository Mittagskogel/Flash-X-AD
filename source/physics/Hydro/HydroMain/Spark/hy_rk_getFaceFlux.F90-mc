!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!> @ingroup HydroSpark
!!
!! @brief Computes interfacial fluxes through reconstruction and solving Riemann
!!
!! @details
!! The reconstruction method and Riemann Solver are implemented as macros,
!! so one can implement new reconstruction/Riemann solver by redefining
!! corresponding macros.
!!
!! @note
!! Initially stores grid data in @p hy_rope by permuting indices <tt> i,j,k </tt>,
!! depending on the direction of the flux.
!! Thus, the <tt>i</tt>-index is always the direction where this subroutine
!! solves interfacial fluxes. See the "hy_setRope" macro.
!!
!! @param hy_starState  Pointer to input solution data
!! @param blkLimits     Index limits for interior of the tile
!! @param blkLimitsGC   Index limits for exterior of the tile
!! @param limits        sets limits of the fluxes.
!!
!! @todo
!! The input arguments should be reconsidered.
!! "limits" looks unnecessary, and the permutating limits,
!! "lim" and "limgc" could be input arguments.
!! "dir" and "stage" as well.
!<
!!NOVARIANTS
!!Reorder(4):hy_starState,hy_fl[xyz]

subroutine hy_rk_getFaceFlux (hy_starState, blklimits, blkLimitsGC, limits)
  use Hydro_data, ONLY : hy_threadWithinBlock,hy_smalldens, &
       hy_smallE, hy_smallpres, hy_smallX, hy_cvisc, hy_flattening
      
  use Hydro_data, ONLY : hya_flx, hya_fly, hya_flz, hya_flat3d 
  use Hydro_data, ONLY : hya_starState,hya_rope, hya_uPlus, hya_uMinus, hya_flat,&
       hya_shck, hya_flux
  use Hydro_data, ONLY : hy_del, hy_tiny, hy_hybridRiemann, hy_C_hyp
  use Hydro_data, ONLY : lim,limgc,gCells, dir,stage
  use Timers_interface, ONLY : Timers_start, Timers_stop

  implicit none

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

  real,dimension(:,:,:,:),pointer ::hy_starState
  integer, intent(IN), dimension(LOW:HIGH,MDIM) :: limits, blkLimits, blkLimitsGC
  integer :: i,j,k, n, g, v,  ierr
  real :: cvisc, VenerLo, VenerHi
  integer :: s
  real :: spcSumInv
  real, dimension(NSPECIES) :: spc
  real  :: u2,E,B2,UB,Ptot

  logical :: inShock
!!  real, dimension(HY_NUM_VARS) :: VL, VR
  real :: rope(5)
  real,dimension(:,:,:,:),pointer::hy_rope, hy_uPlus, hy_uMinus,hy_flux,&
       hy_flx, hy_fly, hy_flz
  real,dimension(:,:,:),pointer :: hy_flat,hy_shck,hy_flat3d
  @M hy_recon_declare
  @M hy_riemann_declare

  logical :: offload = .false.

#ifdef OMP_OL
  offload = .true.
#endif

  @M hy_DIR_TARGET_enter_data(to, [coeff1p1, coeff1p2, coeff1p3, coeff1m1, coeff1m2, coeff1m3, linWp, linWm])
  hy_flat3d(@M bounds_3d(blkLimitsGC))=>hya_flat3d

  @M hy_map_fl
  
  @M hy_DIR_TARGET_enter_data(alloc, [lim, limgc, stage, dir])


  !  Begin loop over zones
  @M hy_DIR_HOST_parallel_if_threaded &
  @M hy_DIR_HOST_getFaceFlux_shared &
  @M hy_DIR_HOST_getFaceFlux_private
  do dir = 1, NDIM
     ! call Timers_start("prepare_scratch")
     @M hy_DIR_TARGET_update_to([lim, limgc, dir, stage])

     hy_flux(1:NFLUXES,@M hy_bounds(limgc))=>hya_flux
     hy_flat(@M hy_bounds(limgc))=>hya_flat
     hy_shck(@M hy_bounds(limgc))=>hya_shck
     
     hy_rope(1:NRECON,@M hy_bounds(limgc)) => hya_rope
     hy_uPlus(1:NRECON,@M hy_bounds(limgc)) => hya_uPlus
     hy_uMinus(1:NRECON,@M hy_bounds(limgc)) => hya_uMinus

     @M hy_DIR_TARGET_enter_data(alloc, [hy_flux, hy_flat, hy_shck, hy_rope, hy_uPlus, hy_uMinus])
     ! call Timers_stop("prepare_scratch")

     ! call Timers_start("setRope")
     @M hy_DIR_HOST_do_collapse(2)
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_setRope_private &
     @M hy_DIR_TARGET_setRope_shared
     @M hy_permute_loop(limgc, lim)
        if (dir == IAXIS) then
           @M hy_setRope(i,j,k)
        else if (dir == JAXIS) then
           @M hy_setRope(j,i,k)
        else if (dir == KAXIS) then
           @M hy_setRope(j,k,i)
        endif
     @M hy_break_loop
     ! call Timers_stop("setRope")



     ! call Timers_start("recon")
     @M hy_DIR_TARGET_parallel_loop(4) &
     @M hy_DIR_TARGET_recon_private &
     @M hy_DIR_TARGET_recon_shared
     @M hy_inner_loop_ext_i(lim)
        do v=1,NRECON
           @M hy_recon
        enddo
     @M hy_break_loop
     ! call Timers_stop("recon")

     ! call Timers_start("setrem")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_normalize_species_private &
     @M hy_DIR_TARGET_normalize_species_shared
     @M hy_inner_loop_ext_i(lim)
        ! Limit and renormalize the species.
        @M hy_normalize_species( hy_uPlus )
        @M hy_normalize_species( hy_uMinus )
     @M hy_break_loop
     ! call Timers_stop("setrem")

     ! call Timers_start("riemann")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_riemann_private &
     @M hy_DIR_TARGET_riemann_shared
     @M hy_inner_loop_plus(lim,1,0,0)
        VL = hy_uPlus(1:HY_NUM_VARS,i-1,j,k)
        VR = hy_uMinus(1:HY_NUM_VARS,i,j,k) 
        inShock = any(hy_shck(i-1:i,j,k) /= 0.0)
        @M hy_riemann
        hy_flux(1:HY_NUM_FLUX,i,j,k) = Fstar(1:HY_NUM_FLUX)
     @M hy_break_loop
     ! call Timers_stop("riemann")

     ! call Timers_start("cvisc")
     @M hy_DIR_TARGET_parallel_loop(3) &
     @M hy_DIR_TARGET_avisc_private &
     @M hy_DIR_TARGET_avisc_shared
     @M hy_inner_loop_plus(lim,1,0,0)
        ! Add artificial viscosity for strong-shock capturing
        cvisc = hy_cvisc*max(-(hy_rope(HY_VELX+dir-1,i,j,k) - hy_rope(HY_VELX+dir-1,i-1,j,k)),0.)
        ! Construct minus and plus TOTAL energy densities
        VenerLo = hy_rope(HY_DENS,i-1,j,k) &
                  *0.5*(dot_product(hy_rope(HY_VELX:HY_VELZ,i-1,j,k),hy_rope(HY_VELX:HY_VELZ,i-1,j,k)))&
                  + hy_rope(HY_RHOE,i-1,j,k)
        VenerHi = hy_rope(HY_DENS,i,j,k) &
                  *0.5*(dot_product(hy_rope(HY_VELX:HY_VELZ,i,j,k),hy_rope(HY_VELX:HY_VELZ,i,j,k)))&
                  + hy_rope(HY_RHOE,i,j,k)

        hy_flux(HY_MASS:HY_ENER,i,j,k) = &
              hy_flux(HY_MASS:HY_ENER,i,j,k) &
                 + cvisc*(/ hy_rope(HY_DENS,i-1,j,k) - hy_rope(HY_DENS,i,j,k), &
                            hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELX,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELX,i,j,k), &
                            hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELY,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELY,i,j,k), &
                            hy_rope(HY_DENS,i-1,j,k)*hy_rope(HY_VELZ,i-1,j,k) - hy_rope(HY_DENS,i,j,k)*hy_rope(HY_VELZ,i,j,k), &
                            VenerLo - VenerHi &
                         /)

              
#ifdef SPARK_GLM
        hy_flux(HY_FMGX:HY_FPSI,i,j,k) = &
              hy_flux(HY_FMGX:HY_FPSI,i,j,k) &
                 + cvisc*(/ hy_rope(HY_MAGX,i-1,j,k) - hy_rope(HY_MAGX,i,j,k), &
                            hy_rope(HY_MAGY,i-1,j,k) - hy_rope(HY_MAGY,i,j,k), &
                            hy_rope(HY_MAGZ,i-1,j,k) - hy_rope(HY_MAGZ,i,j,k), &
                            hy_rope(HY_PSIB,i-1,j,k) - hy_rope(HY_PSIB,i,j,k) &
                         /)
#endif
              ! Here, we compute the species and mass scalar
              ! fluxes based on the density flux and the hy_reconstructed
              ! mass scalar interface values
#if NSPECIES+NMASS_SCALARS>0
              ! AH: TODO: Potentially make loop explicit
         if (hy_flux(HY_MASS ,i,j,k) > 0.) then
            hy_flux(HY_NUM_FLUX+1:NFLUXES,i,j,k) = hy_uPlus(HY_NUM_VARS+1:NRECON,i-1,j,k)*hy_flux(HY_MASS,i,j,k)
         else
            hy_flux(HY_NUM_FLUX+1:NFLUXES,i,j,k) = hy_uMinus(HY_NUM_VARS+1:NRECON,i,j,k)*hy_flux(HY_MASS,i,j,k)
         end if
#endif
     @M hy_break_loop
     ! call Timers_stop("cvisc")

     ! call Timers_start("flux")
     ! ***************
     ! Fluxes computed for one face of this zone
     ! Save the fluxes
     ! ***************
     select case(dir)
     case(IAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(hy_flx) &
        @M hy_DIR_TARGET_map(from, [hy_flx])
        @M hy_inner_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              hy_flx(v,i,j,k) = hy_flux(v,i,j,k)
           end do
        @M hy_break_loop
     case (JAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(hy_fly) &
        @M hy_DIR_TARGET_map(from, [hy_fly])
        @M hy_inner_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              hy_fly(v,j,i,k) = hy_flux(v,i,j,k)
           end do
        @M hy_break_loop
     case (KAXIS)
        @M hy_DIR_TARGET_parallel_loop_simd(3) &
        @M hy_DIR_TARGET_saveFlux_shared(hy_flz) &
        @M hy_DIR_TARGET_map(from, [hy_flz])
        @M hy_inner_loop_plus(lim,1,0,0)
           do v = 1, NFLUXES
              hy_flz(v,j,k,i) = hy_flux(v,i,j,k)
           end do
        @M hy_break_loop
     end select
     ! call Timers_stop("flux")
     @M hy_permute_loop_end
     @M hy_DIR_HOST_end_do
     !release pointers
     @M hy_DIR_TARGET_exit_data(release, [hy_flux, hy_rope, hy_uPlus, hy_uMinus, hy_flat, hy_shck])
     nullify(hy_flux)
     nullify(hy_rope)
     nullify(hy_uPlus)
     nullify(hy_uMinus)
     nullify(hy_flat)
     nullify(hy_shck)
     
     
  end do ! dir
  @M hy_DIR_HOST_end_parallel

  @M hy_DIR_TARGET_exit_data(release, [lim, limgc, stage, dir])
  nullify(hy_flat3d)
  @M hy_nullFl

end subroutine hy_rk_getFaceFlux


