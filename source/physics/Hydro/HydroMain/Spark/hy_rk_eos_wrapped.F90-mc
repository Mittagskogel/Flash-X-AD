!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file

!> @ingroup HydroSpark
!!
!<


!!REORDER(4): solnData
!!NOVARIANTS
subroutine hy_rk_eos_wrapped(stage, mode, idxRange, solnData, &
                             loGC, mask)

   use Hydro_data, ONLY: eos_gasConstant => hy_eos_gasConstant, &
                         eos_gamma => hy_eos_gamma, &
                         eos_singleSpeciesA => hy_eos_singleSpeciesA, &
                         eos_singleSpeciesZ => hy_eos_singleSpeciesZ, &
                         eos_eintSwitch => hy_eos_eintSwitch, &
                         eos_smalle => hy_eos_smalle, &
                         eos_gammam1 => hy_eos_gammam1

   @M hy_DIR_TARGET_routine(vector)

   implicit none

#include "constants.h"
#include "Eos.h"
#include "Simulation.h"
#include "Spark.h"

   integer, intent(in) :: stage, mode, loGC(3)
   integer, dimension(2, MDIM, MAXSTAGE), intent(in) :: idxRange
   real, intent(IN OUT) :: solnData(1:, loGC(1):, loGC(2):, loGC(3):)
   logical, dimension(EOS_VARS+1:EOS_NUM), optional, intent(IN) :: mask

   real, dimension(NSPECIES) :: massFrac

   integer :: i, j, k, n, m, s
   real    :: pres, dens, gamc, temp, abar, zbar, eint, ekin, entr
   integer :: pres_map, dens_map, gamc_map, game_map, temp_map, entr_map
   integer :: eint_map, ener_map, velx_map, vely_map, velz_map, sumy_map, ye_map

   real :: kineticEnergy, internalEnergy
   logical :: pMassFrac_and_mask, pMassFrac, pMask

   real ::  ggprod, ggprodinv, gam1inv

   if (mode == MODE_EOS_NOP) return ! * Return immediately for MODE_EOS_NOP! *

   pMassFrac = NSPECIES > 0
   pMask = present(mask)
   pMassFrac_and_mask = pMassFrac .and. pMask

   ggprod = eos_gammam1*eos_gasConstant
   ggprodinv = 1./ggprod
   gam1inv = 1./eos_gammam1
   gamc = eos_gamma
   abar = eos_singleSpeciesA
   zbar = eos_singleSpeciesZ

   pres_map = PRES_VAR
   dens_map = DENS_VAR
   temp_map = TEMP_VAR
   gamc_map = GAMC_VAR
   game_map = NONEXISTENT
   eint_map = NONEXISTENT
   ener_map = NONEXISTENT
   velx_map = NONEXISTENT
   vely_map = NONEXISTENT
   velz_map = NONEXISTENT
   sumy_map = NONEXISTENT
   ye_map = NONEXISTENT
   entr_map = NONEXISTENT
#ifdef GAME_VAR
   game_map = GAME_VAR
#endif
#ifdef EINT_VAR
   eint_map = EINT_VAR
#endif
#ifdef ENER_VAR
   ener_map = ENER_VAR
#endif
#ifdef VELX_VAR
   velx_map = VELX_VAR
#endif
#ifdef VELY_VAR
   vely_map = VELY_VAR
#endif
#ifdef VELZ_VAR
   velz_map = VELZ_VAR
#endif
#ifdef SUMY_VAR
   sumy_map = SUMY_VAR
#endif
#ifdef YE_VAR
   ye_map = YE_VAR
#endif
#ifdef ENTR_VAR
   entr_map = ENTR_VAR
#endif
   if (pMassFrac) then
      @M hy_DIR_parallel_loop(3) &
      @M hy_DIR_firstprivate([ggprod, ggprodinv, gam1inv, gamc, abar, zbar]) &
      @M hy_DIR_private([pres, dens, temp, eint, ekin, entr]) &
      @M hy_DIR_private([kineticEnergy, internalEnergy, massFrac])
      do k = idxRange(LOW, KAXIS, stage), idxRange(HIGH, KAXIS, stage)
      do j = idxRange(LOW, JAXIS, stage), idxRange(HIGH, JAXIS, stage)
      do i = idxRange(LOW, IAXIS, stage), idxRange(HIGH, IAXIS, stage)
         if (velx_map > 0 .AND. vely_map > 0 .AND. velz_map > 0) then
            kineticEnergy = 0.5*(solnData(velx_map, i, j, k)**2+ &
                                 solnData(vely_map, i, j, k)**2+ &
                                 solnData(velz_map, i, j, k)**2)
         else
            kineticEnergy = 0.0
         end if
         !!
         ekin = kineticEnergy
         !! kineticEnergy holds velocity vector information -- 1/2 * Vmag**2
         !! internalEnergy holds eint (directly)  or energyTotal - ekinetic (calculated),
         !!          depending upon eintSwitch
         if (eint_map /= NONEXISTENT) then
            internalEnergy = solnData(eint_map, i, j, k)
            if (ener_map /= NONEXISTENT) then
            if (solnData(ener_map, i, j, k)-kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
               internalEnergy = solnData(ener_map, i, j, k)-kineticEnergy
            end if
            end if
         else if (game_map /= NONEXISTENT) then ! This case should be usable for R(elativistic)HD - KW
            internalEnergy = solnData(pres_map, i, j, k)/solnData(dens_map, i, j, k)/ &
                             (solnData(game_map, i, j, k)-1.0)
            if (ener_map /= NONEXISTENT) then
            if (solnData(ener_map, i, j, k)-kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
               internalEnergy = solnData(ener_map, i, j, k)-kineticEnergy
            end if
            end if
         else if (ener_map /= NONEXISTENT) then
            internalEnergy = solnData(ener_map, i, j, k)-kineticEnergy
         else
            internalEnergy = eos_smalle
         end if
         !!
         internalEnergy = max(internalEnergy, eos_smalle)
         eint = internalEnergy
         !!
         pres = solnData(pres_map, i, j, k)
         dens = solnData(dens_map, i, j, k)
         temp = solnData(temp_map, i, j, k)
         gamc = solnData(gamc_map, i, j, k)
         if ((ye_map /= NONEXISTENT) .and. (sumy_map /= NONEXISTENT)) then
         !! cal says abar=1/sumy
         !! cal says zbar=ye / sumy and he claims sumy are never zero
            abar = 1.0/solnData(sumy_map, i, j, k)
            zbar = solnData(ye_map, i, j, k)/solnData(sumy_map, i, j, k)
         end if
         if (entr_map /= NONEXISTENT) entr = solnData(entr_map, i, j, k)
         do s = 1, NSPECIES
            massFrac(s) = solnData(s, i, j, k)
         end do
         ! density, temperature taken as input
         if (mode == MODE_DENS_TEMP) then
            pres = eos_gasConstant*dens*temp/abar
            eint = ggprod*temp/abar
            entr = (pres/dens+eint)/temp

            ! density, internal energy taken as input
         elseif (mode == MODE_DENS_EI) then
            pres = dens*eint*gam1inv
            temp = eint*ggprodinv*abar
            entr = (pres/dens+eint)/temp

            ! density, pressure taken as input
         elseif (mode == MODE_DENS_PRES) then
            eint = pres*eos_gammam1/dens
            temp = eint*ggprodinv*abar
            entr = (pres/dens+eint)/temp

            ! unrecognized value for mode
         else
            print *, "[hy_rk_eos_wrapped] Unrecognized input mode given to Eos"
         end if
         solnData(pres_map, i, j, k) = pres
         solnData(temp_map, i, j, k) = temp
         solnData(gamc_map, i, j, k) = gamc
         if (eint_map /= NONEXISTENT) solnData(eint_map, i, j, k) = eint
         if (ener_map /= NONEXISTENT) solnData(ener_map, i, j, k) = eint+ekin
         if (entr_map /= NONEXISTENT) solnData(entr_map, i, j, k) = entr
         if (game_map /= NONEXISTENT) solnData(game_map, i, j, k) = pres/(eint*dens)+1
      end do
      end do
      end do
   else
      @M hy_DIR_parallel_loop(3) &
      @M hy_DIR_firstprivate([ggprod, ggprodinv, gam1inv, gamc, abar, zbar]) &
      @M hy_DIR_private([pres, dens, temp, eint, ekin, entr]) &
      @M hy_DIR_private([kineticEnergy, internalEnergy, massFrac])
      do k = idxRange(LOW, KAXIS, stage), idxRange(HIGH, KAXIS, stage)
      do j = idxRange(LOW, JAXIS, stage), idxRange(HIGH, JAXIS, stage)
      do i = idxRange(LOW, IAXIS, stage), idxRange(HIGH, IAXIS, stage)
         if (velx_map > 0 .AND. vely_map > 0 .AND. velz_map > 0) then
            kineticEnergy = 0.5*(solnData(velx_map, i, j, k)**2+ &
                                 solnData(vely_map, i, j, k)**2+ &
                                 solnData(velz_map, i, j, k)**2)
         else
            kineticEnergy = 0.0
         end if
         !!
         ekin = kineticEnergy
         !! kineticEnergy holds velocity vector information -- 1/2 * Vmag**2
         !! internalEnergy holds eint (directly)  or energyTotal - ekinetic (calculated),
         !!          depending upon eintSwitch
         if (eint_map /= NONEXISTENT) then
            internalEnergy = solnData(eint_map, i, j, k)
            if (ener_map /= NONEXISTENT) then
            if (solnData(ener_map, i, j, k)-kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
               internalEnergy = solnData(ener_map, i, j, k)-kineticEnergy
            end if
            end if
         else if (game_map /= NONEXISTENT) then ! This case should be usable for R(elativistic)HD - KW
            internalEnergy = solnData(pres_map, i, j, k)/solnData(dens_map, i, j, k)/ &
                             (solnData(game_map, i, j, k)-1.0)
            if (ener_map /= NONEXISTENT) then
            if (solnData(ener_map, i, j, k)-kineticEnergy > max(eos_smalle, eos_eintSwitch*kineticEnergy)) then
               internalEnergy = solnData(ener_map, i, j, k)-kineticEnergy
            end if
            end if
         else if (ener_map /= NONEXISTENT) then
            internalEnergy = solnData(ener_map, i, j, k)-kineticEnergy
         else
            internalEnergy = eos_smalle
         end if
         !!
         internalEnergy = max(internalEnergy, eos_smalle)
         eint = internalEnergy
         !!
         pres = solnData(pres_map, i, j, k)
         dens = solnData(dens_map, i, j, k)
         temp = solnData(temp_map, i, j, k)
         gamc = solnData(gamc_map, i, j, k)
         if ((ye_map /= NONEXISTENT) .and. (sumy_map /= NONEXISTENT)) then
         !! cal says abar=1/sumy
         !! cal says zbar=ye / sumy and he claims sumy are never zero
            abar = 1.0/solnData(sumy_map, i, j, k)
            zbar = solnData(ye_map, i, j, k)/solnData(sumy_map, i, j, k)
         end if
         if (entr_map /= NONEXISTENT) entr = solnData(entr_map, i, j, k)
         ! density, temperature taken as input
         if (mode == MODE_DENS_TEMP) then
            pres = eos_gasConstant*dens*temp/abar
            eint = ggprod*temp/abar
            entr = (pres/dens+eint)/temp

            ! density, internal energy taken as input
         elseif (mode == MODE_DENS_EI) then
            pres = dens*eint*gam1inv
            temp = eint*ggprodinv*abar
            entr = (pres/dens+eint)/temp

            ! density, pressure taken as input
         elseif (mode == MODE_DENS_PRES) then
            eint = pres*eos_gammam1/dens
            temp = eint*ggprodinv*abar
            entr = (pres/dens+eint)/temp

            ! unrecognized value for mode
         else
            print *, "[hy_rk_eos_wrapped] Unrecognized input mode given to Eos"
         end if
         solnData(pres_map, i, j, k) = pres
         solnData(temp_map, i, j, k) = temp
         solnData(gamc_map, i, j, k) = gamc
         if (eint_map /= NONEXISTENT) solnData(eint_map, i, j, k) = eint
         if (ener_map /= NONEXISTENT) solnData(ener_map, i, j, k) = eint+ekin
         if (entr_map /= NONEXISTENT) solnData(entr_map, i, j, k) = entr
         if (game_map /= NONEXISTENT) solnData(game_map, i, j, k) = pres/(eint*dens)+1
      end do
      end do
      end do
   end if

end subroutine hy_rk_eos_wrapped
