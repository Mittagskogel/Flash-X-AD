[hy_check_config]
definition =

[hy_scratch_use]
definition=
  use Hydro_data,ONLY : hya_starState,hya_tmpState, &
       hya_uPlus, hya_uMinus, hya_Vc, hya_grav, hya_flat3d, hya_flat,&
       hya_rope, hya_flux, hya_shck, &
       hya_flx, hya_fly, hya_flz, hya_fluxBufX, hya_fluxBufY, hya_fluxBufZ,&
       hya_fareaX,hya_fareaY,hya_fareaZ,hya_cvol, &
       hya_xCenter,hya_xLeft,hya_xRight, &
       hya_yCenter,hya_yLeft,hya_yRight, &
       hya_zCenter

[hy_declare_scr_ptr]
definition=
  real, pointer,dimension(:,:,:,:) :: hy_tmpState,hy_starState,hy_flx,hy_fly,hy_flz,&
       hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ, &
       hy_rope, hy_flux, hy_uPlus, hy_uMinus
  real, pointer, dimension(:,:,:,:) :: hy_grav   ! this should be a separate line to prevent REORDER
  real, pointer, dimension(:,:,:) :: hy_flat3d
  real,pointer,dimension(:,:,:) ::hy_fareaX,hy_fareaY,hy_fareaZ,hy_cvol
  real,pointer,dimension(:) :: hy_xCenter,hy_xLeft,hy_xRight,hy_yCenter,hy_yLeft,hy_yRight,hy_zCenter


[hy_mapflxGC]
definition=
   1:NFLUXES,@M bounds_3d(blkLimitsGC)

[hy_mapflyGC]
definition=
   1:NFLUXES,@M bounds_3d(blkLimitsGC)

[hy_mapflzGC]
definition=
   1:NFLUXES,@M bounds_3d(blkLimitsGC)

[hy_mapflx]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)

[hy_mapfly]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0)

[hy_mapflz]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1)

[hy_mapFluxBuf]
definition=
   hy_fluxBufX(@M hy_mapflx)=>hya_fluxBufX
   hy_fluxBufY(@M hy_mapfly)=>hya_fluxBufY
   hy_fluxBufZ(@M hy_mapflz)=>hya_fluxBufZ

[hy_map_fareas]
definition =
           hy_fareaX(@M bounds_3d(blkLimitsGC))=>hya_fareaX
           hy_fareaY(@M bounds_3d(blkLimitsGC))=>hya_fareaY
           hy_fareaZ(@M bounds_3d(blkLimitsGC))=>hya_fareaZ

[hy_map_geom]
definition=
           @M hy_map_fareas
           hy_cvol(@M bounds_3d(blkLimitsGC))=>hya_cvol
           hy_xCenter(@M bounds_i(blkLimitsGC))=>hya_xCenter
           hy_xLeft(@M bounds_i(blkLimitsGC))=>hya_xLeft
           hy_xRight(@M bounds_i(blkLimitsGC))=>hya_xRight
           hy_yCenter(@M bounds_j(blkLimitsGC))=>hya_yCenter
           hy_yLeft(@M bounds_j(blkLimitsGC))=>hya_yLeft
           hy_yRight(@M bounds_j(blkLimitsGC))=>hya_yRight
           hy_zCenter(@M bounds_k(blkLimitsGC))=>hya_zCenter


[hy_nullFluxBuf]
definition=
   nullify(hy_fluxBufX)
   nullify(hy_fluxBufY)
   nullify(hy_fluxBufZ)

[hy_map_fl]
definition=
   hy_flx(@M hy_mapflxGC)=>hya_flx
   hy_fly(@M hy_mapflyGC)=>hya_fly
   hy_flz(@M hy_mapflzGC)=>hya_flz

[hy_nullFl]
definition=
   nullify(hy_flx)
   nullify(hy_fly)
   nullify(hy_flz)

[hy_map_tmp_states]
definition=
        hy_starState(1:NUNK_VARS,@M bounds_3d(blkLimitsGC))=>hya_starState
        hy_tmpState(1:NUNK_VARS,@M bounds_3d(blkLimitsGC))=>hya_tmpState

[hy_map_grav]
definition=
   hy_grav(1:MDIM, @M bounds_3d(blkLimitsGC))=>hya_grav

[hy_nullGrav]
definition=
   nullify(hy_grav)

[hy_map_flat3d]
definition=
   hy_flat3d(@M bounds_3d(blkLimitsGC))=>hya_flat3d

[hy_nullFlat3d]
definition=
   nullify(hy_flat3d)

[hy_map_faceFlux_scr]
definition=
   hy_rope(1:NRECON, @M bounds_3d(blkLimitsGC))=>hya_rope
   hy_flux(1:NFLUXES, @M bounds_3d(blkLimitsGC))=>hya_flux
   hy_uPlus(1:NRECON, @M bounds_3d(blkLimitsGC))=>hya_uPlus
   hy_uMinus(1:NRECON, @M bounds_3d(blkLimitsGC))=>hya_uMinus

[hy_nullFaceFlux_scr]
definition=
   nullify(hy_rope)
   nullify(hy_flux)
   nullify(hy_uPlus)
   nullify(hy_uMinus)


[hy_map_scr_ptrs]
definition=
        @M hy_map_fl
        @M hy_mapFluxBuf
        @M hy_map_grav
        @M hy_map_flat3d
        @M hy_map_faceFlux_scr

[hy_release_tmp_states]
definition=
        nullify(hy_starState)
        nullify(hy_tmpState)


[hy_release_scr_ptrs]
definition=
        @M hy_nullFl
        @M hy_nullFluxBuf
        @M hy_nullGrav
        @M hy_nullFlat3d
        @M hy_nullFaceFlux_scr



[hy_setLims]
args=ng
definition=
  limits = blkLimits
  do dir=1,NDIM
     limits(LOW ,dir) = blkLimits(LOW ,dir) - ng
     limits(HIGH,dir) = blkLimits(HIGH,dir) + ng
  end do

[hy_updateState]
definition=
 #ifdef GPOT_VAR
  ! First reset GPOT_VAR.
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       Uin(GPOT_VAR,@M bounds_3d(blkLimits))
 #endif
  Uin(:,@M bounds_3d(blkLimits)) = &
       hy_starState(:,@M bounds_3d(blkLimits))

[hy_saveGlobalState]
definition=


[hy_saveState]
definition=
  @M hy_DIR_parallel_loop_simd(3) &
  @M hy_DIR_shared([blkLimitsGC, Uin, starState, tmpState]) &
  @M hy_DIR_private([v])
  @M loop_3d(blkLimitsGC)
      ! update temp vars with solution data
      do v=1,NUNK_VARS
         starState(v,i,j,k)=Uin(v,i,j,k)
         tmpState(v,i,j,k)=Uin(v,i,j,k)
      end do
  @M loop_end_3d

[hy_stages_t]
definition = 
  do stage=1,last_stage 

[hy_end_stages_t]
definition =
   end do

[hy_stages_nt]
definition = 

[hy_end_stages_nt]
definition = 


[hy_fill_geom]
definition=
           @M hy_map_geom
           call Grid_getCellFaceAreas(IAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaX)
           call Grid_getCellVolumes(level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_cvol)
           call Grid_getCellCoords(IAXIS, CENTER, level, blkLimitsGC(LOW,:), blkLimitsGC(HIGH,:), hy_xCenter)
           call Grid_getCellCoords(IAXIS, LEFT_EDGE, level, blkLimitsGC(LOW,:), blkLimitsGC(HIGH,:), hy_xLeft)
           call Grid_getCellCoords(IAXIS, RIGHT_EDGE, level, blkLimitsGC(LOW,:), blkLimitsGC(HIGH,:), hy_xRight)
           if(NDIM>1) then
              call Grid_getCellFaceAreas(JAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaY)
              call Grid_getCellCoords(JAXIS, CENTER, level, blkLimitsGC(LOW,:), blkLimitsGC(HIGH,:), hy_yCenter)
              call Grid_getCellCoords(JAXIS, LEFT_EDGE, level, blkLimitsGC(LOW,:), blkLimitsGC(HIGH,:), hy_yLeft)
              call Grid_getCellCoords(JAXIS, RIGHT_EDGE, level, blkLimitsGC(LOW,:), blkLimitsGC(HIGH,:), hy_yRight)
           endif
           if(NDIM>2) then
              call Grid_getCellFaceAreas(KAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaZ)
              call Grid_getCellCoords(KAXIS, CENTER, level, blkLimitsGC(LOW,:), blkLimitsGC(HIGH,:), hy_zCenter)
           endif


[hy_release_geom]
definition=
              @M hy_release_fareas
              nullify(hy_cvol)
              nullify(hy_xCenter)
              nullify(hy_xLeft)
              nullify(hy_xRight)
              nullify(hy_yCenter)
              nullify(hy_yLeft)
              nullify(hy_yRight)
              nullify(hy_zCenter)


[hy_fill_fareasYZ]
definition=
           if (NDIM > 1) then
              call Grid_getCellFaceAreas(JAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaY)
           end if
           if (NDIM > 2) then
              call Grid_getCellFaceAreas(KAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaZ)
           end if

[hy_release_fareasYZ]
definition=
              nullify(hy_fareaY)
              nullify(hy_fareaZ)

[hy_fill_fareas]
definition=
           @M hy_map_fareas
           call Grid_getCellFaceAreas(IAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaX)
           if (NDIM > 1) then
              call Grid_getCellFaceAreas(JAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaY)
           end if
           if (NDIM > 2) then
              call Grid_getCellFaceAreas(KAXIS,level,blkLimitsGC(LOW,:),blkLimitsGC(HIGH,:),hy_fareaZ)
           end if

[hy_release_fareas]
definition=
              nullify(hy_fareaX)
              nullify(hy_fareaY)
              nullify(hy_fareaZ)

[hy_DIR_setRope_private]
definition=
  !$omp private(n)

[hy_DIR_setRope_shared]
definition=
  !$omp shared(lim, limgc, dir, stage, starState, flat3d, p_rope, p_shck, p_flat)

[hy_setRope]
args=ix,jx,kx
definition=
  p_rope(HY_DENS,i,j,k) = starState(DENS_VAR,ix,jx,kx)
  p_rope(HY_VELX,i,j,k) = starState(VELX_VAR,ix,jx,kx)
  p_rope(HY_VELY,i,j,k) = starState(VELY_VAR,ix,jx,kx)
  p_rope(HY_VELZ,i,j,k) = starState(VELZ_VAR,ix,jx,kx)
  p_rope(HY_PRES,i,j,k) = starState(PRES_VAR,ix,jx,kx)
  p_rope(HY_GAMC,i,j,k) = starState(GAMC_VAR,ix,jx,kx)
  p_rope(HY_RHOE,i,j,k) = starState(DENS_VAR,ix,jx,kx)*starState(EINT_VAR,ix,jx,kx)
 #ifdef SPARK_GLM
  p_rope(HY_MAGX,i,j,k) = starState(MAGX_VAR,ix,jx,kx)
  p_rope(HY_MAGY,i,j,k) = starState(MAGY_VAR,ix,jx,kx)
  p_rope(HY_MAGZ,i,j,k) = starState(MAGZ_VAR,ix,jx,kx)
  p_rope(HY_PSIB,i,j,k) = starState(PSIB_VAR,ix,jx,kx)
 #endif
 #if NSPECIES+NMASS_SCALARS>0
  do n=SPECIES_BEGIN, MASS_SCALARS_END
     p_rope(HY_NUM_VARS+1+n-SPECIES_BEGIN,i,j,k) = starState(n,ix,jx,kx)
  enddo
 #endif
 #ifdef SHOK_VAR
    p_shck(i,j,k) = starState(SHOK_VAR,ix,jx,kx)
 #else
    p_shck(i,j,k) = 0.0
 #endif
    p_flat(i,j,k) = flat3d(ix,jx,kx)


[hy_recon_declare]
definition=
  real :: invSumAlpha, abs_betadiff
  real, dimension(5) :: stencil
  real, dimension(3) :: W5p, W5m, betaWeno, Alpha5, omega
  real :: mags, betaSum
  !! Set WENO5 coefficients once and for all
  !u_{1,i+1/2}= 2/6*u_{i-2} -7/6*u_{i-1} +11/6*u_{i}
  real, dimension(3) :: coeff1p1 = (/ 2./6., -7./6., 11./6./)
  !u_{2,i+1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3) :: coeff1p2 = (/-1./6.,  5./6.,  2./6./)
  !u_{3,i+1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3) :: coeff1p3 = (/ 2./6.,  5./6., -1./6./)
  ! linear weights for i+1/2, (gamma1,gamma2,gamma3)
  real, dimension(3) :: linWp   = (/0.1, 0.6, 0.3/)
  !u_{1,i-1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3) :: coeff1m1 = (/-1./6.,  5./6.,  2./6./)
  !u_{2,i-1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3) :: coeff1m2 = (/ 2./6.,  5./6., -1./6./)
  !u_{3,i-1/2}=11/6*u_{i-2} -7/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3) :: coeff1m3 = (/ 11./6.,-7./6.,  2./6./)
  ! linear weights for i-1/2, (gamma1,gamma2,gamma3)
  real, dimension(3) :: linWm   = (/0.3, 0.6, 0.1/)

  real, parameter :: epsilon = 1.e-36
  real, parameter :: n13o12 = 13./12.

  integer, parameter :: cntr = 3   ! five-point stencil, center idx == 3




[hy_riemann_declare]
definition=
  real:: speed
  real :: SL,SR,cfL,cfR,aL2,aR2,velNL,velNR
  real :: dStarL,dStarR,totalPresL,totalPresR
  real :: BxStar,ByStar,BzStar,Bn_hll,pStar,qStar
  real :: denomL,denomR,numerL,numerR
  real, dimension(HY_NUM_FLUX) :: UL,UR,Uhll,UCstarR,UCstarL
  real, dimension(HY_NUM_FLUX) :: FL,FR
  real :: magBL2,magBR2,magNL,magNR
  real :: Bn_glm, Psi_glm
  real, dimension(HY_NUM_VARS) :: VL, VR
  real, dimension(HY_NUM_FLUX) :: Fstar

[hy_DIR_normalize_species_private]
definition=
  @M hy_DIR_private([s, spc, spcSumInv])

[hy_DIR_normalize_species_shared]
definition=
  @M hy_DIR_shared([limits, scr_uPlus, scr_uMinus])


[hy_normalize_species]
args=hy_u
definition=
  hy_u(HY_DENS ,i,j,k) = max(smalld, hy_u(HY_DENS ,i,j,k))
  hy_u(HY_PRES ,i,j,k) = max(smallp, hy_u(HY_PRES ,i,j,k))
 #if NSPECIES>0
  spc(1:NSPECIES) = hy_u(HY_NUM_VARS+1:HY_NUM_VARS+NSPECIES ,i,j,k)
  do s=1,NSPECIES
     spc(s) = max(smallx, min(1.0,spc(s)))
  end do
  spcSumInv = 1./sum(spc(1:NSPECIES))
  spc(1:NSPECIES) = spc(1:NSPECIES)*spcSumInv
  hy_u(HY_NUM_VARS + 1:HY_NUM_VARS + NSPECIES, i, j, k) = spc(1:NSPECIES)
 #endif

[hy_loop]
args=limits
definition=
    do k=limits(LOW,KAXIS,dir,stage),limits(HIGH,KAXIS,dir,stage)
         do j=limits(LOW,JAXIS,dir,stage),limits(HIGH,JAXIS,dir,stage)
             do i=limits(LOW,IAXIS,dir,stage),limits(HIGH,IAXIS,dir,stage)

[hy_loop_plus]
args=limits,p1,p2,p3
definition=
    do k=limits(LOW,KAXIS,dir,stage),limits(HIGH,KAXIS,dir,stage)+K3D*p3
         do j=limits(LOW,JAXIS,dir,stage),limits(HIGH,JAXIS,dir,stage)+K2D*p2
             do i=limits(LOW,IAXIS,dir,stage),limits(HIGH,IAXIS,dir,stage)+p1

[hy_bounds]
args=limits
definition=
    limits(LOW,IAXIS,dir,stage):limits(HIGH,IAXIS,dir,stage),&
    limits(LOW,JAXIS,dir,stage):limits(HIGH,JAXIS,dir,stage),&
    limits(LOW,KAXIS,dir,stage):limits(HIGH,KAXIS,dir,stage)


[hy_calc_lim]
definition=
     select case(dir)
     case (IAXIS)
        lim(:,:,dir,stage) = limits(:,:)
        gCells(1) = (limits(LOW,IAXIS) - blkLimitsGC(LOW,IAXIS))
        gCells(2) = (limits(LOW,JAXIS) - blkLimitsGC(LOW,JAXIS))
        gCells(3) = (limits(LOW,KAXIS) - blkLimitsGC(LOW,KAXIS))
     case (JAXIS)
        lim(:,1,dir,stage) = limits(:,JAXIS)
        lim(:,2,dir,stage) = limits(:,IAXIS)
        lim(:,3,dir,stage) = limits(:,KAXIS)
        gCells(1) = (limits(LOW,JAXIS) - blkLimitsGC(LOW,JAXIS))
        gCells(2) = (limits(LOW,IAXIS) - blkLimitsGC(LOW,IAXIS))
        gCells(3) = (limits(LOW,KAXIS) - blkLimitsGC(LOW,KAXIS))
     case (KAXIS)
        lim(:,1,dir,stage) = limits(:,KAXIS)
        lim(:,2,dir,stage) = limits(:,IAXIS)
        lim(:,3,dir,stage) = limits(:,JAXIS)
        gCells(1) = (limits(LOW,KAXIS) - blkLimitsGC(LOW,KAXIS))
        gCells(2) = (limits(LOW,IAXIS) - blkLimitsGC(LOW,IAXIS))
        gCells(3) = (limits(LOW,JAXIS) - blkLimitsGC(LOW,JAXIS))
     end select
     limgc(LOW,:,dir,stage)=lim(LOW,:,dir,stage)-gCells(:)
     limgc(HIGH,:,dir,stage)=lim(HIGH,:,dir,stage)+gCells(:)

[hy_DIR_flat3d_shared]
definition =
  !$omp shared(blkLimitsGC, hy_flat3d)

[hy_DIR_saveFlux_shared]
args = flux
definition =
  @M hy_DIR_shared([limits, scr_flux, flux])
