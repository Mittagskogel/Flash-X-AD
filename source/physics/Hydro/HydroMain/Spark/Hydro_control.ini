[hy_break_loop]
args=n1,n2
definition=
    @M loop_end_3d
    call Timers_stop("n1")
    call Timers_start("n2")
    @M loop_3d(klim)

[hy_scratch_use]
definition=
  use Hydro_data,ONLY : hya_starState,hya_tmpState, &
       hya_uPlus, hya_uMinus, hya_Vc, hya_grav, hya_flat3d, hya_flat, hya_grv,&
       hya_rope, hya_flux, hya_shck, &
       hya_flx, hya_fly, hya_flz, hya_fluxBufX, hya_fluxBufY, hya_fluxBufZ,&
       hya_farea,hya_cvol,hya_xCenter,hya_xLeft,hya_xRight,hya_yCenter,hya_zCenter

[hy_declare_scr_ptr]
definition=
  real, pointer,dimension(:,:,:,:) :: hy_tmpState,hy_starState,hy_flx,hy_fly,hy_flz,&
       hy_fluxBufX,hy_fluxBufY,hy_fluxBufZ
  real,pointer,dimension(:,:,:) ::hy_farea,hy_cvol
  real,pointer,dimension(:) :: hy_xCenter,hy_xLeft,hy_xRight,hy_yCenter,hy_zCenter


[hy_mapflxGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,1,0,0)

[hy_mapflyGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,1,0)

[hy_mapflzGC]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,0,1)

[hy_mapflx]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)

[hy_mapfly]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0)

[hy_mapflz]
definition=
   1:NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1)

[hy_mapFluxBuf]
definition=
   hy_fluxBufX(@M hy_mapflx)=>hya_fluxBufX
   hy_fluxBufY(@M hy_mapfly)=>hya_fluxBufY
   hy_fluxBufZ(@M hy_mapflz)=>hya_fluxBufZ

[hy_map_geom]
definition=
           hy_farea(@M bounds_3d(blkLimitsGC))=>hya_farea
           hy_cvol(@M bounds_3d(blkLimitsGC))=>hya_cvol
           hy_xCenter(@M bounds_i(blkLimitsGC))=>hya_xCenter
           hy_xLeft(@M bounds_i(blkLimitsGC))=>hya_xLeft
           hy_xRight(@M bounds_i(blkLimitsGC))=>hya_xRight
           hy_yCenter(@M bounds_j(blkLimitsGC))=>hya_yCenter
           hy_zCenter(@M bounds_k(blkLimitsGC))=>hya_zCenter


[hy_nullFluxBuf]
definition=
   nullify(hy_fluxBufX)
   nullify(hy_fluxBufY)
   nullify(hy_fluxBufZ)

[hy_map_fl]
definition=
   hy_flx(@M hy_mapflxGC)=>hya_flx
   hy_fly(@M hy_mapflyGC)=>hya_fly
   hy_flz(@M hy_mapflzGC)=>hya_flz

[hy_nullFl]
definition=
   nullify(hy_flx)
   nullify(hy_fly)
   nullify(hy_flz)

[hy_map_tmp_states]
definition=
        hy_starState(1:NUNK_VARS,@M bounds_3d(blkLimitsGC))=>hya_starState
        hy_tmpState(1:NFLUXES,@M bounds_3d(blkLimitsGC))=>hya_tmpState

[hy_map_scr_ptrs]
definition=
        @M hy_map_fl
        @M hy_mapFluxBuf

[hy_release_tmp_states]
definition=
        nullify(hy_starState)
        nullify(hy_tmpState)


[hy_release_scr_ptrs]
definition=
        @M hy_nullFl
        @M hy_nullFluxBuf



[hy_setLims]
args=ng
definition=
  limits = blkLimits
  do i=1,NDIM
     limits(LOW ,i) = blkLimits(LOW ,i) - ng
     limits(HIGH,i) = blkLimits(HIGH,i) + ng
  end do

[hy_updateState]
definition=
 #ifdef GPOT_VAR
  ! First reset GPOT_VAR.
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       Uin(GPOT_VAR,@M bounds_3d(blkLimits))
 #endif
  Uin(:,@M bounds_3d(blkLimits)) = hy_starState(:,@M bounds_3d(blkLimits))

[hy_saveGlobalState]
definition=


[hy_saveState]
definition=
  !$omp target teams distribute collapse(3)
  @M loop_3d(blkLimitsGC)
      ! update temp vars with solution data
      !$omp parallel do simd
      do v=1,NUNK_VARS
         hy_starState(v,i,j,k)=Uin(v,i,j,k)
      end do
      hy_tmpState(HY_MASS,i,j,k) = Uin(DENS_VAR,i,j,k)
      hy_tmpState(HY_XMOM:HY_ZMOM,i,j,k)= Uin(DENS_VAR,i,j,k)*Uin(VELX_VAR:VELZ_VAR,i,j,k)
      hy_tmpState(HY_ENER,i,j,k) = Uin(DENS_VAR,i,j,k)*Uin(ENER_VAR,i,j,k)
      !$omp parallel do simd
      do v=SPECIES_BEGIN,MASS_SCALARS_END
         hy_tmpState(v-SPECIES_BEGIN+HY_NUM_FLUX+1,i,j,k) = &
            Uin(v,i,j,k)*Uin(DENS_VAR,i,j,k)
      end do
  @M loop_end_3d

[hy_stages_t]
definition = 
  do stage=1,last_stage 

[hy_end_stages_t]
definition =
   end do

[hy_stages_nt]
definition = 

[hy_end_stages_nt]
definition = 


[hy_fill_geom]
definition=
           @M hy_map_geom
           call Grid_getCellFaceAreas(IAXIS,level,loGC,hiGC,hy_farea)
           call Grid_getCellVolumes(level,loGC,hiGC,hy_cvol)
           call Grid_getCellCoords(IAXIS, CENTER, level, loGC, hiGC, hy_xCenter)
           call Grid_getCellCoords(IAXIS, LEFT_EDGE, level, loGC, hiGC, hy_xLeft)
           call Grid_getCellCoords(IAXIS, RIGHT_EDGE, level, loGC, hiGC, hy_xRight)
           !$omp target update to &
           !$omp ( hy_farea, hy_cvol, hy_xCenter, hy_xLeft, hy_xRight )
           if(NDIM>1) then
              call Grid_getCellCoords(JAXIS, CENTER, level, loGC, hiGC, hy_yCenter)
              !$omp target update to &
              !$omp ( hy_yCenter )
           endif
           if(NDIM>2) then
              call Grid_getCellCoords(KAXIS, CENTER, level, loGC, hiGC, hy_zCenter)
              !$omp target update to &
              !$omp ( hy_zCenter )
           endif


[hy_release_geom]
definition=
              nullify(hy_xCenter)
              nullify(hy_xLeft)
              nullify(hy_xRight)
              nullify(hy_farea)
              nullify(hy_cvol)
	      nullify(hy_yCenter)
              nullify(hy_zCenter)

[hy_setRope]
args=ix,jx,kx
definition=
  hy_rope(HY_DENS,i,j,k) = hy_starState(DENS_VAR,ix,jx,kx)
  hy_rope(HY_VELX,i,j,k) = hy_starState(VELX_VAR,ix,jx,kx)
  hy_rope(HY_VELY,i,j,k) = hy_starState(VELY_VAR,ix,jx,kx)
  hy_rope(HY_VELZ,i,j,k) = hy_starState(VELZ_VAR,ix,jx,kx)
  hy_rope(HY_PRES,i,j,k) = hy_starState(PRES_VAR,ix,jx,kx)
  hy_rope(HY_GAMC,i,j,k) = hy_starState(GAMC_VAR,ix,jx,kx)
  hy_rope(HY_RHOE,i,j,k) = hy_starState(DENS_VAR,ix,jx,kx)*hy_starState(EINT_VAR,ix,jx,kx)
 #ifdef SPARK_GLM
  hy_rope(HY_MAGX,i,j,k) = hy_starState(MAGX_VAR,ix,jx,kx)
  hy_rope(HY_MAGY,i,j,k) = hy_starState(MAGY_VAR,ix,jx,kx)
  hy_rope(HY_MAGZ,i,j,k) = hy_starState(MAGZ_VAR,ix,jx,kx)
  hy_rope(HY_PSIB,i,j,k) = hy_starState(PSIB_VAR,ix,jx,kx)
 #endif
 #if NSPECIES+NMASS_SCALARS>0
     do n=SPECIES_BEGIN, MASS_SCALARS_END
        hy_rope(HY_NUM_VARS+1+n-SPECIES_BEGIN,i,j,k)    = hy_starState(n,ix,jx,kx)
     enddo
 #endif
 #ifdef GRAVITY
 #ifdef GPOT_VAR
   hy_grv(i,j,k) = hy_starState(GPOT_VAR,ix,jx,kx)
 #else
    hy_grv(i,j,k) = hy_grav(IAXIS,ix,jx,kx)
 #endif
 #endif
 #ifdef SHOK_VAR
     hy_shck(i,j,k) = hy_starState(SHOK_VAR,ix,jx,kx)
 #else
      hy_shck(i,j,k) = 0.0
 #endif
      hy_flat(i,j,k) = hy_flat3d(ix,jx,kx)


[hy_recon_declare]
definition=
  real :: invSumAlpha
  real, dimension(3) :: W5p, W5m, betaWeno, Alpha5, omega
  real :: mags, betaSum
  !! Set WENO5 coefficients once and for all
  !u_{1,i+1/2}= 2/6*u_{i-2} -7/6*u_{i-1} +11/6*u_{i}
  real, dimension(3), parameter :: coeff1p1(1:3) = (/ 2./6., -7./6., 11./6./)
  !u_{2,i+1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1p2(1:3) = (/-1./6.,  5./6.,  2./6./)
  !u_{3,i+1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3), parameter :: coeff1p3(1:3) = (/ 2./6.,  5./6., -1./6./)
  !(gamma1,gamma2,gamma3)
  real, dimension(3), parameter :: coeff2p(1:3)   = (/0.1, 0.6, 0.3/)
  !u_{1,i-1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1m1(1:3) = (/-1./6.,  5./6.,  2./6./)
  !u_{2,i-1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3), parameter :: coeff1m2(1:3) = (/ 2./6.,  5./6., -1./6./)
  !u_{3,i-1/2}=11/6*u_{i-2} -7/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1m3(1:3) = (/ 11./6.,-7./6.,  2./6./)
  !(gamma1,gamma2,gamma3)
  real, dimension(3), parameter :: coeff2m(1:3)   = (/0.3, 0.6, 0.1/)
  
  real, parameter :: epsilon = 1.e-36
  real, parameter :: n13o12 = 13./12.




[hy_riemann_declare]
definition=
  real:: speed
  real :: SL,SR,cfL,cfR,aL2,aR2,velNL,velNR
  real :: dStarL,dStarR,totalPresL,totalPresR
  real :: BxStar,ByStar,BzStar,Bn_hll,pStar,qStar
  real :: denomL,denomR,numerL,numerR
  real, dimension(HY_NUM_FLUX) :: UL,UR,Uhll,UCstarR,UCstarL
  real, dimension(HY_NUM_FLUX) :: FL,FR
  real :: magBL2,magBR2,magNL,magNR
  real :: Bn_glm, Psi_glm
  real,pointer,dimension(:) :: VL, VR, Fstar

[hy_normalize_species]
args=hy_u
definition=
  hy_u(HY_DENS ,i,j,k) = max(hy_smalldens, hy_u(HY_DENS ,i,j,k))
  hy_u(HY_PRES ,i,j,k) = max(hy_smallpres, hy_u(HY_PRES ,i,j,k))
 #if NSPECIES>0
  spc => hy_u(HY_NUM_VARS+1:HY_NUM_VARS+NSPECIES ,i,j,k)
  spcSum = 0.0
  !$omp parallel do simd &
  !$omp reduction( +: spcSum )
  do s=1,NSPECIES
     spc(s) = max(hy_smallX,min(1.0,spc(s)))
     spcSum = spcSum + spc(s)
  end do
  spcSumInv = 1./spcSum
  !$omp parallel do simd
  do s = 1, NSPECIES
     spc(s) = spc(s)*spcSumInv
  end do
  nullify(s)
 #endif
