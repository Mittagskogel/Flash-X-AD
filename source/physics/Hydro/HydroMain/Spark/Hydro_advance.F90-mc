!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file

!> @ingroup HydroSpark
!!
!<

!!VARIANTS(GPU): Hydro_advance, &
!!               Eos_multiDim, &
!!               hy_rk_getGraveAccel, &
!!               hy_rk_getFlatteningLimiter, &
!!               hy_rk_getFaceFlux, &
!!               hy_rk_updateSoln, &
!!               hy_rk_saveFluxBuf, &
!!               hy_rk_renormAbundance
!!Reorder(4): Uin,hy_starState,hy_tmpState
!!Reorder(4): hy_fl[xyz],hy_fluxBuf[XYZ]
!!Reorder(4): hy_rope,hy_flux,hy_uPlus,hy_uMinus

!#define DISABLE_TRUNC_GETFACEFLUX
!#define DISABLE_TRUNC_UPDATESOLN
!#define EXCLUDE_UPDATESOLN
#define TRUNC_FROM 64
#define TRUNC_TO_E 5
#define TRUNC_TO_M 13

module truncate_Hydro_advance
  implicit none
  interface
     function f__enzyme_truncate_mem_value(x, from, to_e, to_m) result(p_x) bind(c)
       use, intrinsic :: iso_c_binding, only: c_double, c_int
       implicit none

       ! double precision, intent(in) :: x
       ! integer, intent(in) :: from, to
       real(c_double), intent(in), value :: x
       integer(c_int), intent(in), value :: from, to_e, to_m
       double precision :: p_x
     end function f__enzyme_truncate_mem_value
  end interface

  interface
     function f__enzyme_expand_mem_value(x, from, to_e, to_m) result(p_x) bind(c)
       use, intrinsic :: iso_c_binding, only: c_double, c_int
       implicit none

       ! double precision, intent(in) :: x
       ! integer, intent(in) :: from, to
       real(c_double), intent(in), value :: x
       integer(c_int), intent(in), value :: from, to_e, to_m
       double precision :: p_x
     end function f__enzyme_expand_mem_value
  end interface

  interface
     function f__enzyme_reset_shadow_trace() result(count) bind(c)
       use, intrinsic :: iso_c_binding, only: c_long_long
       implicit none

       integer(c_long_long) :: count
     end function f__enzyme_reset_shadow_trace
  end interface

  interface
     subroutine enzyme_fprt_excl_trunc_start() bind(c)
       implicit none
     end subroutine enzyme_fprt_excl_trunc_start
  end interface

  interface
     subroutine enzyme_fprt_excl_trunc_end() bind(c)
       implicit none
     end subroutine enzyme_fprt_excl_trunc_end
  end interface

  public :: truncate_0d, truncate_1d, truncate_2d, truncate_3d, truncate_4d
  public :: f__enzyme_truncate_mem_func_hy_rk_getFaceFlux
  contains
    subroutine truncate_1d(x)
      real, intent(inout) :: x(:)

      integer :: i, n
      n = size(x)

      do i=1,n
         x(i) = f__enzyme_truncate_mem_value(x(i), TRUNC_FROM, TRUNC_TO_E, TRUNC_TO_M)
      end do
    end subroutine truncate_1d

    subroutine truncate_0d(x)
      real, intent(inout) :: x
      real :: tmp(1)

      tmp(1) = x
      call truncate_1d(tmp)
      x = tmp(1)
    end subroutine truncate_0d

    subroutine truncate_2d(x)
      real, intent(inout) :: x(:, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2)])
    end subroutine truncate_2d

    subroutine truncate_3d(x)
      real, intent(inout) :: x(:, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3)])
    end subroutine truncate_3d

    subroutine truncate_4d(x)
      real, intent(inout) :: x(:, :, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call truncate_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3), size(x, 4)])
    end subroutine truncate_4d

    subroutine expand_1d(x)
      real, intent(inout) :: x(:)

      integer :: i, n
      n = size(x)

      do i=1,n
         x(i) = f__enzyme_expand_mem_value(x(i), TRUNC_FROM, TRUNC_TO_E, TRUNC_TO_M)
      end do
    end subroutine expand_1d

    subroutine expand_0d(x)
      real, intent(inout) :: x
      real :: tmp(1)

      tmp(1) = x
      call expand_1d(tmp)
      x = tmp(1)
    end subroutine expand_0d

    subroutine expand_2d(x)
      real, intent(inout) :: x(:, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2)])
    end subroutine expand_2d

    subroutine expand_3d(x)
      real, intent(inout) :: x(:, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3)])
    end subroutine expand_3d

    subroutine expand_4d(x)
      real, intent(inout) :: x(:, :, :, :)
      real :: tmp(size(x))

      tmp = reshape(x, [size(x)])
      call expand_1d(tmp)
      x = reshape(tmp, [size(x, 1), size(x, 2), size(x, 3), size(x, 4)])
    end subroutine expand_4d

    subroutine f__enzyme_truncate_mem_func_hy_rk_getFaceFlux(from, to_e, to_m, &
         stage, starState, flat3d, flx, fly, flz, &
         limits, deltas, &
         scr_rope, scr_flux, scr_uPlus, scr_uMinus, &
         loGC)

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

      implicit none

      integer, intent(in) :: from, to_e, to_m

      integer, intent(IN) :: stage, loGC(3)
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN) :: starState
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: flx, fly, flz
      real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: scr_rope, scr_flux, scr_uPlus, scr_uMinus
      real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(IN) :: flat3d
      integer, dimension(LOW:HIGH, MDIM, MAXSTAGE), intent(IN) :: limits
      real, dimension(MDIM), intent(IN)  :: deltas

      call hy_rk_getFaceFlux(stage, starState, flat3d, flx, fly, flz, &
         limits, deltas, &
         scr_rope, scr_flux, scr_uPlus, scr_uMinus, &
         loGC)
    end subroutine f__enzyme_truncate_mem_func_hy_rk_getFaceFlux
  end module truncate_Hydro_advance

subroutine Hydro_advance(stage_in, Uin, dt, dtOld, &
                         hy_starState, hy_tmpState, &
                         hy_flx, hy_fly, hy_flz, &
                         hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
                         hy_grav, hy_flat3d, &
                         hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
                         deltas, &
                         blkLimits, blkLimitsGC, &
                         lo, loGC, &
                         hy_xCenter, hy_yCenter, hy_zCenter, &
                         hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
                         hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol &
                         @M hy_eos_args)

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"

   use hy_rk_interface, ONLY: hy_rk_getGraveAccel, &
                              hy_rk_getFlatteningLimiter, &
                              hy_rk_getFaceFlux, &
                              hy_rk_updateSoln, &
                              hy_rk_saveFluxBuf, &
                              hy_rk_renormAbundance
   use Eos_interface, ONLY : Eos_multiDim
   use Burn_interface, ONLY : Burn_update

   ! Enzyme
   use truncate_Hydro_advance
   use Eos_data, only: eos_truncate

   ! Enzyme, for getFaceFlux expansion
   use Hydro_data, ONLY : hy_cvisc, &
                          hy_C_hyp, &
                          hy_tiny, &
                          hy_smalldens, &
                          hy_smallpres, &
                          hy_smallX, &
                          hy_limRad, &
                          hy_mp5ZeroTol, &
                          hy_coeffArray, &
                          hy_smallE, &
                          hy_alphaGLM

   @M hy_DIR_TARGET_routine(vector)

   @M hy_DIR_TARGET_routine_vector(hy_rk_getGraveAccel)
   @M hy_DIR_TARGET_routine_vector(hy_rk_getFlatteningLimiter)
   @M hy_DIR_TARGET_routine_vector(hy_rk_getFaceFlux)
   @M hy_DIR_TARGET_routine_vector(hy_rk_updateSoln)
   @M hy_DIR_TARGET_routine_vector(hy_rk_saveFluxBuf)
   @M hy_DIR_TARGET_routine_vector(hy_rk_renormAbundance)
   @M hy_DIR_TARGET_routine_vector(Eos_multiDim_GPU)

   implicit none

   integer, intent(IN) :: stage_in, lo(3), loGC(3)
   real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN OUT) :: Uin
   real, intent(IN) :: dt, dtold
   real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN OUT) :: hy_starState
   real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_flx, hy_fly, hy_flz
   real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN) :: hy_tmpState
   real, dimension(1:, lo(1):, lo(2):, lo(3):), intent(OUT) :: hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ
   real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_rope, hy_flux, hy_uPlus, hy_uMinus
   real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_grav
   real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_flat3d

   integer, dimension(LOW:HIGH, MDIM), intent(IN) :: blkLimits, blkLimitsGC

   real, dimension(MDIM), intent(IN)  :: deltas
   real, dimension(loGC(1):), intent(IN) :: hy_xCenter
   real, dimension(loGC(2):), intent(IN) :: hy_yCenter
   real, dimension(loGC(3):), intent(IN) :: hy_zCenter
   real, dimension(loGC(1):), intent(IN) :: hy_xLeft, hy_xRight
   real, dimension(loGC(2):), intent(IN) :: hy_yLeft, hy_yRight
   real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(IN) :: hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol

   integer, dimension(LOW:HIGH, MDIM, MAXSTAGE) :: limits
   integer :: stage, ng, dir
   integer, parameter :: last_stage = MAXSTAGE

   !Enzyme
#ifdef DISABLE_TRUNC_GETFACEFLUX
   real, dimension(MDIM) :: expand_deltas
   expand_deltas = deltas
   call expand_1d(expand_deltas)
#endif
#ifdef DISABLE_TRUNC_UPDATESOLN
   real, dimension(MDIM) :: expand_deltas
   real, dimension(size(hy_tmpState, 1), size(hy_tmpState, 2), size(hy_tmpState, 3), size(hy_tmpState, 3)) :: expand_hy_tmpState

   expand_deltas = deltas
   ! call expand_1d(expand_deltas)
   expand_hy_tmpState = hy_tmpState
   ! call expand_4d(expand_hy_tmpState)
#endif

   @M hy_eos_declare_scr



   @M hy_setStage_nt

   @M hy_setLimits

   !! Begin loop over stages for the telescoping mode.
   @M hy_stages_t
      ! calculate gravitational acceleration based on current value of GPOT_VAR
      ! This is stored in scratch variable hy_grav
      ! print *, "stage", stage
      ! print *, f_enzyme_reset_shadow_trace(), "errors at beginning of Hydro_advance."
      call hy_rk_getGraveAccel(hy_starState, hy_grav, &
                               hy_xCenter, hy_yCenter, deltas, &
                               blkLimitsGC, loGC)
      ! print *, f_enzyme_reset_shadow_trace(), "errors in hy_rk_getGraveaccel"

      call hy_rk_getFlatteningLimiter(stage, hy_starState, hy_flat3d, limits, loGC)
      ! print *, f_enzyme_reset_shadow_trace(), "errors in hy_rk_getFlatteningLimiter"

#ifdef DISABLE_TRUNC_GETFACEFLUX

      call expand_4d(hy_starState)
      call expand_3d(hy_flat3d)
      call expand_4d(hy_flx)
      call expand_4d(hy_fly)
      call expand_4d(hy_flz)
      call expand_4d(hy_rope)
      call expand_4d(hy_flux)
      call expand_4d(hy_uPlus)
      call expand_4d(hy_uMinus)

      ! Hydro_data
      call expand_0d(hy_cvisc)
      call expand_0d(hy_C_hyp)
      call expand_0d(hy_tiny)
      call expand_0d(hy_smalldens)
      call expand_0d(hy_smallpres)
      call expand_0d(hy_smallX)
      call expand_0d(hy_limRad)
      call expand_0d(hy_mp5ZeroTol)

      call hy_rk_getFaceFlux(stage, hy_starState, hy_flat3d, hy_flx, hy_fly, hy_flz, &
                             limits, expand_deltas, &
                             hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
                             loGC)
      call truncate_4d(hy_starState)
      call truncate_3d(hy_flat3d)
      call truncate_4d(hy_flx)
      call truncate_4d(hy_fly)
      call truncate_4d(hy_flz)
      call truncate_4d(hy_rope)
      call truncate_4d(hy_flux)
      call truncate_4d(hy_uPlus)
      call truncate_4d(hy_uMinus)

      ! Hydro_data
      call truncate_0d(hy_cvisc)
      call truncate_0d(hy_C_hyp)
      call truncate_0d(hy_tiny)
      call truncate_0d(hy_smalldens)
      call truncate_0d(hy_smallpres)
      call truncate_0d(hy_smallX)
      call truncate_0d(hy_limRad)
      call truncate_0d(hy_mp5ZeroTol)
#else
      call hy_rk_getFaceFlux(stage, hy_starState, hy_flat3d, hy_flx, hy_fly, hy_flz, &
                             limits, deltas, &
                             hy_rope, hy_flux, hy_uPlus, hy_uMinus, &
                             loGC)
#endif
      ! print *, f_enzyme_reset_shadow_trace(), "errors in hy_rk_getFaceFlux"
      ! Now update solution based on conservative fluxes
      ! See select_RK_scheme() for explicit outline of C1, C2, & C3
      ! U* = C1 * U0 + C2 * U* + C3 * dt*L(U*)
#ifdef EXCLUDE_UPDATESOLN
      call enzyme_fprt_excl_trunc_start()
#endif
      call hy_rk_updateSoln(stage, hy_starState, hy_tmpState, &
                            hy_grav, hy_flx, hy_fly, hy_flz, &
                            deltas, hy_fareaX, hy_fareaY, hy_fareaZ, hy_cvol, hy_xCenter, &
                            hy_xLeft, hy_xRight, hy_yLeft, hy_yRight, &
                            dt, dtOld, limits, lo, loGC)
#ifdef EXCLUDE_UPDATE_SOLN
      call enzyme_fprt_excl_trunc_end()
#endif
      ! print *, f_enzyme_reset_shadow_trace(), "errors in hy_rk_updateSoln"
      call hy_rk_saveFluxBuf(stage, hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
                             hy_flx, hy_fly, hy_flz, &
                             hy_fareaX, hy_fareaY, hy_fareaZ, &
                             blkLimits, lo, loGC)
      ! print *, f_enzyme_reset_shadow_trace(), "errors in hy_rk_saveFluxBuf"
#if NSPECIES>0
      !Properly normalize species after the update
      call hy_rk_renormAbundance(blkLimitsGC, hy_starState, loGC)
#endif

      @M hy_DIR_update_starState_to_host

      if (eos_truncate) then
         call expand_4d(hy_starState)
         call Eos_multiDim(MODE_DENS_EI, limits(LOW:HIGH,1:MDIM,stage), loGC, hy_starState @M hy_eos_args)
         call truncate_4d(hy_starState)
      else
         call Eos_multiDim(MODE_DENS_EI, limits(LOW:HIGH,1:MDIM,stage), loGC, hy_starState @M hy_eos_args)
      end if

      @M hy_DIR_update_starState_to_device

   @M hy_end_stages_t

   @M hy_updateState

end subroutine Hydro_advance

